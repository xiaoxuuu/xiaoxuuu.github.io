<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>JVM - 小徐&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="小徐&#039;s Blog"><meta name="msapplication-TileImage" content="icons/touch-icon-iphone.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="小徐&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="144x144" href="icons/touch-icon-iphone.png"><link rel="apple-touch-icon" sizes="152x152" href="icons/touch-icon-ipad.png"><link rel="apple-touch-icon" sizes="72x72" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="96x96" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="128x128" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="256x256" href="icon/logo.ico"><meta name="description" content="JVM 面试题"><meta property="og:type" content="article"><meta property="og:title" content="JVM"><meta property="og:url" content="https://blog.hr947x.com/548314b5b0e6/"><meta property="og:site_name" content="小徐&#039;s Blog"><meta property="og:description" content="JVM 面试题"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/20201217213314510.png"><meta property="og:image" content="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/05/34/39_3.png#alt=39%5C_3.png"><meta property="article:published_time" content="2022-02-15T08:03:00.000Z"><meta property="article:modified_time" content="2022-03-22T12:08:25.000Z"><meta property="article:author" content="小徐"><meta property="article:tag" content="面试"><meta property="article:tag" content="JVM"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://img-blog.csdnimg.cn/20201217213314510.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hr947x.com/548314b5b0e6/"},"headline":"JVM","image":["https://img-blog.csdnimg.cn/20201217213314510.png","https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/05/34/39_3.png#alt=39%5C_3.png"],"datePublished":"2022-02-15T08:03:00.000Z","dateModified":"2022-03-22T12:08:25.000Z","author":{"@type":"Person","name":"小徐"},"publisher":{"@type":"Organization","name":"小徐's Blog","logo":{"@type":"ImageObject","url":{"text":"小徐's Blog"}}},"description":"JVM 面试题"}</script><link rel="canonical" href="https://blog.hr947x.com/548314b5b0e6/"><link rel="icon" href="/img/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">小徐&#039;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">博客</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="踽踽独行" href="https://www.hr947x.com">踽踽独行</a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-15T08:03:00.000Z" title="2/15/2022, 8:03:00 AM">2022-02-15</time>发表</span><span class="level-item"><time dateTime="2022-03-22T12:08:25.000Z" title="3/22/2022, 12:08:25 PM">2022-03-22</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span> / </span><a class="link-muted" href="/categories/%E9%9D%A2%E8%AF%95/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span><span class="level-item">2 小时读完 (大约17800个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">JVM</h1><div class="content"><p>JVM 面试题</p>
<span id="more"></span>

<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="怎样判断-JVM-是-32-位还是-64-位"><a href="#怎样判断-JVM-是-32-位还是-64-位" class="headerlink" title="怎样判断 JVM 是 32 位还是 64 位"></a>怎样判断 JVM 是 32 位还是 64 位</h2><p>可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息。</p>
<h2 id="32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？"><a href="#32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？" class="headerlink" title="32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？"></a>32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？</h2><p>理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。</p>
<h2 id="编译期常量是什么"><a href="#编译期常量是什么" class="headerlink" title="编译期常量是什么"></a>编译期常量是什么</h2><p>公共静态不可变（<code>public static final</code>）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的 JAR。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p>
<h2 id="对象分配内存是否线程安全"><a href="#对象分配内存是否线程安全" class="headerlink" title="对象分配内存是否线程安全"></a>对象分配内存是否线程安全</h2><p>对象创建十分频繁，即使修改一个指针的位置在并发下也不是线程安全的，可能正给对象 A 分配内存，指针还没来得及修改，对象 B 又使用了指针来分配内存。</p>
<p>解决方法</p>
<ol>
<li>  CAS 加失败重试保证更新原子性。</li>
<li>  把内存分配按线程划分在不同空间，即每个线程在 Java 堆中预先分配一小块内存，叫做本地线程分配缓冲 TLAB，哪个线程要分配内存就在对应的 TLAB 分配，TLAB 用完了再进行同步。</li>
</ol>
<h2 id="Java-程序是怎样运行的"><a href="#Java-程序是怎样运行的" class="headerlink" title="Java 程序是怎样运行的"></a>Java 程序是怎样运行的</h2><ol>
<li><p>首先通过 Javac 编译器将 <code>.java</code> 转为 JVM 可加载的 <code>.class</code> 字节码文件。</p>
</li>
<li><p>javac 是由 Java 编写的程序，编译过程可以分为：</p>
<ol>
<li>词法解析：通过空格分割出单词、操作符、控制符等信息，形成 token 信息流，传递给语法解析器；</li>
<li>语法解析：把 token 信息流按照 Java 语法规则组装成语法树；</li>
<li>语义分析：检查关键字使用是否合理、类型是否匹配、作用域是否正确等；</li>
<li>字节码生成：将前面各个步骤的信息转换为字节码；</li>
</ol>
</li>
<li><p>字节码必须通过类加载过程加载到 JVM 后才可以执行，执行有三种模式，解释执行、JIT 编译执行、JIT 编译与解释器混合执行（主流 JVM 默认执行的方式）。混合模式的优势在于解释器在启动时先解释执行，省去编译时间。</p>
</li>
<li><p>之后通过即时编译器 JIT 把字节码文件编译成本地机器码。</p>
</li>
<li><p>Java 程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会认定其为「热点代码」，热点代码的检测主要有基于采样和基于计数器两种方式，为了提高热点代码的执行效率，虚拟机会把它们编译成本地机器码，尽可能对代码优化，在运行时完成这个任务的后端编译器被称为即时编译器。</p>
</li>
<li><p>还可以通过静态的提前编译器 AOT 直接把程序编译成与目标机器指令集相关的二进制代码。</p>
</li>
</ol>
<h2 id="说一下-Java-对象的创建过程"><a href="#说一下-Java-对象的创建过程" class="headerlink" title="说一下 Java 对象的创建过程"></a>说一下 Java 对象的创建过程</h2><ol>
<li>  类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li>
<li>  分配内存：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有「指针碰撞」和「空闲列表」两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。选择以上 2 种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是「标记-清除」，还是「标记-整理」（也称作「标记-压缩」），值得注意的是，复制算法内存也是规整的。</li>
<li>  在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：CAS + 失败重试：CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。TLAB：为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
<li>  初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li>  设置对象头：初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li>
<li>  执行 init 方法：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>
</ol>
<h2 id="64-位-JVM-中，int-的长度是多少"><a href="#64-位-JVM-中，int-的长度是多少" class="headerlink" title="64 位 JVM 中，int 的长度是多少"></a>64 位 JVM 中，int 的长度是多少</h2><p>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的 Java 虚拟机中，int 类型的长度是相同的。</p>
<h2 id="守护线程和本地线程区别"><a href="#守护线程和本地线程区别" class="headerlink" title="守护线程和本地线程区别"></a>守护线程和本地线程区别</h2><p>Java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。</p>
<p>任何线程都可以设置为守护线程和用户线程，通过方法 <code>Thread.setDaemon(booleon);</code>true 则把该线程设置为守护线程，反之则为用户线程。<code>Thread.setDaemon()</code> 必须在 <code>Thread.start()</code> 之前调用，否则运行时会抛出异常。</p>
<p><strong>区别</strong>：</p>
<p>唯一的区别是判断虚拟机 JVM 何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。也可以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的线程；比如 JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线程时，Java 虚拟机会自动离开。</p>
<p><strong>扩展</strong>：</p>
<p>Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break 的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。</p>
<h2 id="Java-会存在内存泄漏吗"><a href="#Java-会存在内存泄漏吗" class="headerlink" title="Java 会存在内存泄漏吗"></a>Java 会存在内存泄漏吗</h2><p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java 是有 GC 垃圾回收机制的，也就是说，不再被使用的对象，会被 GC 自动回收掉，自动从内存中清除</p>
<p>但是，即使这样，Java 也还是存在着内存泄漏的情况，Java 导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是 Java 中内存泄露的发生场景。</p>
<h2 id="Java-对象的布局"><a href="#Java-对象的布局" class="headerlink" title="Java 对象的布局"></a>Java 对象的布局</h2><p>对象头区域此处存储的信息包括两部分：</p>
<ol>
<li>  对象自身的运行时数据(MarkWord)，占 8 字节 存储 hashCode、GC 分代年龄、锁类型标记、偏向锁线程 ID、CAS 锁指向线程 LockRecord 的指针等， synconized 锁的机制与这个部分( markwork )密切相关，用 markword 中最低的三位代表锁的状态，其中一位是偏向锁位，另外两位是普通锁位。</li>
<li>  对象类型指针(Class Pointer)，占 4 字节 对象指向它的类元数据的指针、 JVM 就是通过它来确定是哪个 Class 的实例。</li>
</ol>
<p>实例数据区域 此处存储的是对象真正有效的信息，比如对象中所有字段的内容</p>
<p>对齐填充区域 JVM 的实现 HostSpot 规定对象的起始地址必须是 8 字节的整数倍，换句话来说，现在 64 位的 OS 往外读取数据的时候一次性读取 64bit 整数倍的数据，也就是 8 个字节，所以 HotSpot 为了高效读取对象，就做了「对齐」，如果一个对象实际占的内存大小不是 8byte 的整数倍时，就「补位」到 8byte 的整数倍。所以对齐填充区域的大小不是固定的。</p>
<h2 id="stackoverflow-错误、permgen-space-错误"><a href="#stackoverflow-错误、permgen-space-错误" class="headerlink" title="stackoverflow 错误、permgen space 错误"></a>stackoverflow 错误、permgen space 错误</h2><p>stackoverflow 错误主要出现在虚拟机栈中（线程请求的栈深度大于虚拟机栈锁允许的最大深度）</p>
<p>permgen space 错误（针对 JDK7 之前版本）：</p>
<ul>
<li>  大量加载 class 文件</li>
<li>  常量池内存溢出</li>
</ul>
<h2 id="Java-有哪些引用类型"><a href="#Java-有哪些引用类型" class="headerlink" title="Java 有哪些引用类型"></a>Java 有哪些引用类型</h2><ol>
<li>强引用：这种引用属于最普通最强硬的一种存在，只有在和 GC Roots 断绝关系时，才会被消灭掉。</li>
<li>软引用：软引用用于维护一些可有可无的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。可以看到，这种特性非常适合用在缓存技术上。比如网页缓存、图片缓存等。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。</li>
<li>弱引用：弱引用对象相比较软引用，要更加无用一些，它拥有更短的生命周期。当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。弱引用拥有更短的生命周期，在 Java 中，用 java.lang.ref.WeakReference 类来表示。它的应用场景和软引用类似，可以在一些对内存更加敏感的系统里采用。</li>
<li>虚引用：这是一种形同虚设的引用，在现实场景中用的不是很多。虚引用必须和引用队列（ReferenceQueue）联合使用。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。实际上，虚引用的 get，总是返回 null。</li>
</ol>
<h2 id="对象的访问定位有哪几种方式"><a href="#对象的访问定位有哪几种方式" class="headerlink" title="对象的访问定位有哪几种方式"></a>对象的访问定位有哪几种方式</h2><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有 2 种：</p>
<ul>
<li>句柄：如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</li>
<li>直接指针：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</li>
</ul>
<p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="描述一下-JVM-加载-class-文件的原理机制"><a href="#描述一下-JVM-加载-class-文件的原理机制" class="headerlink" title="描述一下 JVM 加载 class 文件的原理机制"></a>描述一下 JVM 加载 class 文件的原理机制</h2><ol>
<li>  JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中各类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。</li>
<li>  由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的 .class 文件中的数据读入到内存中，通常是创建一个字节数组读入 .class 文件，然后产生与所加载类对应的 Class 对象。</li>
<li>加载完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后 JVM 对类进行初始化：<ol>
<li>  如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类;</li>
<li>  果类中存在初始化语句，就依次执行这些初始化语句。</li>
</ol>
</li>
<li>  类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader 的子类）。</li>
<li>  从 JDK2 开始，类加载过程采取了父亲委托机制（PDM）。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。</li>
</ol>
<p><strong>类加载器的说明：</strong></p>
<ol>
<li>  Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）；</li>
<li>  Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap；</li>
<li>  System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性</li>
</ol>
<p>java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。</p>
<h2 id="Class-文件"><a href="#Class-文件" class="headerlink" title="Class 文件"></a>Class 文件</h2><p>Class 文件是一组以 8 位字节为基础单位的二进制流。各个数据项严格按顺序排列。</p>
<p>Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据。这样的伪结构仅仅有两种数据类型：无符号数和表。</p>
<ul>
<li>  无符号数：是基本数据类型。以 u1、u2、u4、u8 分别代表 1 个字节、2 个字节、4 个字节、8 个字节的无符号数，能够用来描写叙述数字、索引引用、数量值或者依照 UTF-8 编码构成的字符串值。</li>
<li>  表：由多个无符号数或者其它表作为数据项构成的复合数据类型。全部表都习惯性地以 _info 结尾。</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器是 JVM 的组成部分之一。将字节码文件加载进 JVM，JDK 有三个类加载器：</p>
<ul>
<li>  <code>BootstrapClassLoader 根类加载器</code>：ExtClassLoader 的加载，加载 <code>%JAVA_HOME%/lib</code> 下的 jar 包和 class 文件；</li>
<li>  <code>ExtClassLoader 扩展类加载器</code>：AppClassLoader 的加载器，加载 <code>%JAVA_HOME%/lib/ext</code> 文件夹下的的 jar 包和 class 类，开发者可以直接使用标准扩展类加载器；</li>
<li>  <code>AppClassLoader 系统加载器</code>：加载自定义的类，负责加载 classpath 下的类文件。线程上下文加载器（每个加载器都可以访问这个加载器）；</li>
<li>  <code>CustomClassLoader 抽象类加载器</code>：用户自定义的类加载器，继承 ClassLoader 即可实现自定义类加载器；</li>
</ul>
<p>JVM 默认采用的是双亲委派类加载机制，即先加载父类在加载子类，对上面四个类加载器采用自顶向下加载</p>
<h2 id="类加载顺序"><a href="#类加载顺序" class="headerlink" title="类加载顺序"></a>类加载顺序</h2><p>有继承关系：</p>
<ol>
<li> 父类的静态字段或静态语句块（依据代码先后顺序）；</li>
<li> 子类的静态字段或静态语句块（依据代码先后顺序）；</li>
<li> 父类普通变量以及语句块加载（依据代码先后顺序）；</li>
<li> 父类构造方法加载；</li>
<li> 子类普通变量以及语句块加载（依据代码先后顺序）；</li>
<li> 子类构造方法加载；</li>
</ol>
<p>无继承关系：</p>
<ol>
<li> 静态字段或静态语句块（依据代码先后顺序）；</li>
<li> 普通变量以及语句块加载（依据代码先后顺序）；</li>
<li> 构造方法加载；</li>
</ol>
<h2 id="JVM-类加载机制"><a href="#JVM-类加载机制" class="headerlink" title="JVM 类加载机制"></a>JVM 类加载机制</h2><p>JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载是类加载过程中的一个阶段， 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象， 作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：</p>
<p>实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080， 将 v 赋值为 8080 的 put static 指令是程序被编译后，存放于类构造器方法之中。</p>
<p><strong>但是注意如果声明为：</strong></p>
<p>public static final int v = 8080;</p>
<p>在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值为 8080。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：</p>
<ul>
<li>  CONSTANT_Class_info</li>
<li>  CONSTANT_Field_info</li>
<li>  CONSTANT_Method_info</li>
</ul>
<p>等类型的常量。</p>
<p><strong>符号引用</strong></p>
<p>符号引用与虚拟机实现的布局无关， 引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。</p>
<p><strong>直接引用</strong></p>
<p>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。</p>
<p><strong>类构造器</strong></p>
<p>初始化阶段是执行类构造器方法的过程。方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子方法执行之前，父类的方法已经执行完毕， 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成()方法。</p>
<p><strong>注意以下几种情况不会执行类初始化：</strong></p>
<ul>
<li>  通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li>
<li>  定义对象数组，不会触发该类的初始化。</li>
<li>  常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</li>
<li>  通过类名获取 Class 对象，不会触发类的初始化。</li>
<li>  通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</li>
<li>  通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。</li>
</ul>
<h2 id="类初始化的情况"><a href="#类初始化的情况" class="headerlink" title="类初始化的情况"></a>类初始化的情况</h2><ol>
<li>遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 字节码指令时，还未初始化。典型场景包括 new 实例化对象、读取或设置静态字段、调用静态方法。</li>
<li>对类反射调用时，还未初始化。</li>
<li>初始化类时，父类还未初始化。</li>
<li>虚拟机启动时，会先初始化包含 main 方法的主类。</li>
<li>使用 JDK7 的动态语言支持时，如果 MethodHandle 实例的解析结果为指定类型的方法句柄且句柄对应的类还未初始化。</li>
<li>接口定义了默认方法，如果接口的实现类初始化，接口要在其之前初始化。</li>
<li>其余所有引用类型的方式都不会触发初始化，称为被动引用。被动引用实例：<ol>
<li>子类使用父类的静态字段时，只有父类被初始化。</li>
<li>通过数组定义使用类。</li>
<li>常量在编译期会存入调用类的常量池，不会初始化定义常量的类。</li>
</ol>
</li>
<li>接口和类加载过程的区别：初始化类时如果父类没有初始化需要初始化父类，但接口初始化时不要求父接口初始化，只有在真正使用父接口时（如引用接口中定义的常量）才会初始化。</li>
</ol>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul>
<li>  堆：heap</li>
<li>  栈：stack</li>
<li>  方法区：method area</li>
<li>  永久代：PermGen</li>
<li>  元空间：MetaSpace</li>
<li>  新生代：</li>
<li>  老年代</li>
<li>Survivor<ul>
<li>  From Survivor</li>
<li>  To Survivor</li>
</ul>
</li>
<li>  Eden</li>
<li></li>
</ul>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>寄存器：我们无法控制。</p>
<p>静态域：static 定义的静态成员。</p>
<p>常量池：编译时被确定并保存在 .class 文件中的（final）常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法和名称和描述符）。</p>
<p>非 RAM 存储：硬盘等永久存储空间。</p>
<p>堆内存：new 创建的对象和数组，由 Java 虚拟机自动垃圾回收器管理,存取速度慢。</p>
<p>栈内存：基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可以共享，但是大小与生存期必须确定，缺乏灵活性。</p>
<h2 id="W-JVM-内存区域"><a href="#W-JVM-内存区域" class="headerlink" title="W JVM 内存区域"></a><code>W</code> JVM 内存区域</h2><p>JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。</p>
<p>线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。</p>
<p>线程共享区域随虚拟机的启动/关闭而创建/销毁。</p>
<p>直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于Channel与 Buffer的IO方式, 它可以使用Native函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。</p>
<h2 id="W-内存结构"><a href="#W-内存结构" class="headerlink" title="W 内存结构"></a><code>W</code> 内存结构</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/suifeng629/article/details/82462164">JVM内存划分_疯一样的女子-CSDN博客_jvm内存</a></p>
<ol>
<li>程序计数器<ul>
<li>  当前线程所执行的字节码的行号指示器，循环、异常处理、线程恢复等基础功能都需要依赖这个计数器；</li>
<li>  此内存区域是唯一在 Java 虚拟机规范中没有规定任何 OOM 情况的区域；</li>
</ul>
</li>
<li>Java 虚拟机栈<ul>
<li>  每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息；</li>
<li>  方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程，当方法被调用入栈，完成调用出栈。所有的栈帧都出栈后，线程就结束了；</li>
<li>局部变量表存放了编译器可知的各种基本数据类型、对象引用、returnAddress 类型。局部变量表所需的内存空间在编译器完成分配。当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小；<ul>
<li>  对象引用：reference 类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置；</li>
<li>  returnAddress：指向了一条字节码指令的地址；</li>
</ul>
</li>
<li>  StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度；</li>
<li>  OutOfMemoryError：如果虚拟机栈可以动态扩展但无法申请到足够的内存；</li>
</ul>
</li>
<li>本地方法栈<ul>
<li>  虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法。</li>
</ul>
</li>
<li>堆 heap<ul>
<li>  Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此区域的唯一目的就是存放对象实例；</li>
<li>  GC 的主要区域，因此很多时候也被称为 GC 堆；</li>
<li>  从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB）</li>
<li>  从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代，在细致一点的有 Eden 空间，From Survivor 空间，To Survivor 空间等；</li>
</ul>
</li>
<li>方法区<ul>
<li>各个线程共享内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据；<ul>
<li>  运行时常量池：用于存放类加载后的各种字面量和符号引用；</li>
<li>  Class 文件常量池：存放类的版本，字段，方法，接口等描述信息；</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="JDK8-与元数据"><a href="#JDK8-与元数据" class="headerlink" title="JDK8 与元数据"></a>JDK8 与元数据</h2><p>在 JDK8 中， 永久代已经被移除，被一个称为「元数据区」（元空间）的区域所取代。</p>
<p>元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 nativememory, 字符串池和类的静态变量放入 Java 堆中， 这样可以加载多少类的元数据就不再由 MaxPermSize 控制, 而由系统的实际可用空间来控制。</p>
<h2 id="Java-中堆和栈有什么区别"><a href="#Java-中堆和栈有什么区别" class="headerlink" title="Java 中堆和栈有什么区别"></a>Java 中堆和栈有什么区别</h2><p>JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p>
<h2 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆 heap"></a>堆 heap</h2><h3 id="Java-堆的结构是什么样子的？什么是堆中的永久代（Perm-Gen-space）"><a href="#Java-堆的结构是什么样子的？什么是堆中的永久代（Perm-Gen-space）" class="headerlink" title="Java 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space）"></a>Java 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space）</h3><p>JVM 的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在 JVM 启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。</p>
<p>堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些 对象回收掉之前，他们会一直占据堆内存空间。</p>
<h3 id="说一下堆内存中对象的分配的基本策略"><a href="#说一下堆内存中对象的分配的基本策略" class="headerlink" title="说一下堆内存中对象的分配的基本策略"></a>说一下堆内存中对象的分配的基本策略</h3><p>Eden 区、s0 区、s1 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区 -&gt; Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。另外，大对象和长期存活的对象会直接进入老年代。</p>
<h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 stack</h2><h3 id="栈帧都有哪些数据？"><a href="#栈帧都有哪些数据？" class="headerlink" title="栈帧都有哪些数据？"></a>栈帧都有哪些数据？</h3><p>JVM 的运行是基于栈的，和 C 语言的栈类似，它的大多数数据都是在堆里面的，只有少部分运行时的数据存在于栈上。</p>
<p>在 JVM 中，每个线程栈里面的元素，就叫 <code>栈帧</code>。</p>
<p>栈帧包含：局部变量表、操作数栈、动态连接、返回地址、附加信息等。</p>
<h3 id="什么情况下会发生栈内存溢出？"><a href="#什么情况下会发生栈内存溢出？" class="headerlink" title="什么情况下会发生栈内存溢出？"></a>什么情况下会发生栈内存溢出？</h3><p>栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型。如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常，方法递归调用产生这种结果。如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将抛出一个OutOfMemory 异常。(线程启动过多)。</p>
<h2 id="方法区的作用"><a href="#方法区的作用" class="headerlink" title="方法区的作用"></a>方法区的作用</h2><p><strong>方法区</strong>用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>JDK8 之前使用永久代实现方法区，容易内存溢出，因为永久代有 <code>-XX:MaxPermSize</code> 上限，即使不设置也有默认大小。JDK7 把放在永久代的字符串常量池、静态变量等移出，JDK8 中永久代完全废弃，改用在本地内存中实现的元空间代替，把 JDK7 中永久代剩余内容（主要是类型信息）全部移到元空间。</p>
<p>虚拟机规范对方法区的约束宽松，除和堆一样不需要连续内存和可选择固定大小/可扩展外，还可以不实现垃圾回收。垃圾回收在方法区出现较少，主要目标针对常量池和类型卸载。如果方法区无法满足新的内存分配需求，将抛出 OutOfMemoryError。</p>
<h2 id="运行时常量池的作用"><a href="#运行时常量池的作用" class="headerlink" title="运行时常量池的作用"></a>运行时常量池的作用</h2><p>运行时常量池是方法区的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译器生成的各种字面量与符号引用，这部分内容在类加载后存放到运行时常量池。一般除了保存 Class 文件中描述的符号引用外，还会把符号引用翻译的直接引用也存储在运行时常量池。</p>
<p>运行时常量池相对于 Class 文件常量池的一个重要特征是动态性，Java 不要求常量只有编译期才能产生，运行期间也可以将新的常量放入池中，这种特性利用较多的是 String 的 <code>intern</code> 方法。</p>
<p>运行时常量池是方法区的一部分，受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError。</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p><strong>程序计数器</strong>是一块较小的内存空间，可以看作当前线程所执行字节码的行号指示器。每条线程都要有一个独立的程序计数器，这类内存也称为「线程私有」的内存。字节码解释器工作时通过改变计数器的值选取下一条执行指令。分支、循环、跳转、线程恢复等功能都需要依赖计数器完成。</p>
<p>如果线程正在执行 Java 方法，计数器记录正在执行的虚拟机字节码指令地址（当前指令的地址）。如果是本地方法，计数器值为 Undefined。</p>
<p>这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。</p>
<h2 id="JVM-新生代中为什么要分为-Eden-和-Survivor"><a href="#JVM-新生代中为什么要分为-Eden-和-Survivor" class="headerlink" title="JVM 新生代中为什么要分为 Eden 和 Survivor"></a>JVM 新生代中为什么要分为 Eden 和 Survivor</h2><p>如果没有 Survivor，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发 Major GC。老年代的内存空间远大于新生代，进行一次 Full GC 消耗的时间比 Minor GC 长得多,所以需要分为 Eden 和 Survivor。Survivor 的存在意义，就是减少被送到老年代的对象，进而减少 Full GC 的发生，Survivor 的预筛选保证，只有经历 16 次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。设置两个 Survivor 区最大的好处就是解决了碎片化，刚刚新建的对象在 Eden 中，经历一次 Minor GC，Eden 中的存活对象就会被移动到第一块 survivor space S0，Eden 被清空；等 Eden 区再满了，就再触发一次 Minor GC，Eden 和 S0 中的存活对象又会被复制送入第二块 survivor space S1（这个过程非常重要，因为这种复制算法保证了 S1 中来自 S0 和 Eden 两部分的存活对象占用连续的内存空间，避免了碎片化的发生）</p>
<h2 id="JDK8-为什么要将永久代替换为元空间呢？"><a href="#JDK8-为什么要将永久代替换为元空间呢？" class="headerlink" title="JDK8 为什么要将永久代替换为元空间呢？"></a>JDK8 为什么要将永久代替换为元空间呢？</h2><p>整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会出现 java.lang.OutOfMemoryError。你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX:MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
<h2 id="解释内存中的栈、堆和方法区的用法"><a href="#解释内存中的栈、堆和方法区的用法" class="headerlink" title="解释内存中的栈、堆和方法区的用法"></a>解释内存中的栈、堆和方法区的用法</h2><p>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用 JVM 中的栈空间；而通过 new 关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为 Eden、Survivor（又可分为 From Survivor 和 To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT 编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的 100、”hello” 和常量都是放在常量池中，常量池是方法区的一部分。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发 StackOverflowError，而堆和常量池空间不足则会引发 OutOfMemoryError。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而 “hello” 这个字面量是放在方法区的。</p>
<p><strong>补充1：</strong></p>
<p>较新版本的 Java（从 JDK6 的某个更新开始）中，由于 JIT 编译器的发展和「逃逸分析」技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。</p>
<p><strong>补充2：</strong></p>
<p>运行时常量池相当于 Class 文件常量池具有动态性，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 <code>intern()</code> 方法就是这样的。</p>
<p>看看下面代码的执行结果是什么并且比较一下 JDK7 以前和以后的运行结果是否一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;go&quot;</span>).append(<span class="string">&quot;od&quot;</span>).toString();</span><br><span class="line">System.out.println(s1.intern() == s1);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">System.out.println(s2.intern() == s2);</span><br></pre></td></tr></table></figure>

<h2 id="什么情况下会出现内存溢出，内存泄漏"><a href="#什么情况下会出现内存溢出，内存泄漏" class="headerlink" title="什么情况下会出现内存溢出，内存泄漏"></a>什么情况下会出现内存溢出，内存泄漏</h2><p>内存泄漏的原因很简单：</p>
<ul>
<li>  对象是可达的（一直被引用）</li>
<li>  但是对象不会被使用</li>
</ul>
<p>常见的内存泄漏例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;Object&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            set.add(object);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置为空，该对象不再使用</span></span><br><span class="line">            object = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 但是set集合中还维护object的引用，gc不会回收object对象</span></span><br><span class="line">        System.out.println(set);</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[java.lang.Object@74a14482, </span><br><span class="line">java.lang.Object@677327b6, </span><br><span class="line">java.lang.Object@6d6f6e28, </span><br><span class="line">java.lang.Object@4554617c, </span><br><span class="line">java.lang.Object@45ee12a7, </span><br><span class="line">java.lang.Object@1b6d3586, </span><br><span class="line">java.lang.Object@7f31245a,</span><br><span class="line">java.lang.Object@135fbaa4,</span><br><span class="line">java.lang.Object@1540e19d, </span><br><span class="line">java.lang.Object@14ae5a5]</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>解决这个内存泄漏问题也很简单，将 set 设置为 null，那就可以避免上述内存泄漏问题了。其他内存泄漏得一步一步分析了。</p>
<p><strong>内存溢出的原因：</strong></p>
<ul>
<li>  内存泄露导致堆栈内存不断增大，从而引发内存溢出。</li>
<li>  大量的 jar，class 文件加载，装载类的空间不够，溢出</li>
<li>  操作大量的对象导致堆内存空间已经用满了，溢出</li>
<li>  nio 直接操作内存，内存过大导致溢出</li>
</ul>
<p><strong>解决：</strong></p>
<ul>
<li>  查看程序是否存在内存泄漏的问题</li>
<li>  设置参数加大空间</li>
<li>  代码中是否存在死循环或循环产生过多重复的对象实体、</li>
<li>  查看是否使用了 nio 直接操作内存。</li>
</ul>
<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p><a target="_blank" rel="noopener" href="https://www.pdai.tech/md/java/jvm/java-jvm-x-overview.html">♥JVM相关知识体系详解♥ | Java 全栈知识体系 (pdai.tech)</a></p>
<p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器没有找到所需的类时，子加载器才会尝试去加载该类。</p>
<h2 id="打破双亲委派机制的例子"><a href="#打破双亲委派机制的例子" class="headerlink" title="打破双亲委派机制的例子"></a>打破双亲委派机制的例子</h2><ul>
<li>  JNDI 通过引入线程上下文类加载器，可以在 Thread.setContextClassLoader 方法设置，默认是应用程序类加载器，来加载 SPI 的代码。有了线程上下文类加载器，就可以完成父类加载器请求子类加载器完成类加载的行为。打破的原因，是为了 JNDI 服务的类加载器是启动器类加载，为了完成高级类加载器请求子类加载器（即上文中的线程上下文加载器）加载类。</li>
<li>  Tomcat，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器，加载不了才委派给父加载器。打破的目的是为了完成应用间的类隔离。</li>
<li>  OSGi，实现模块化热部署，为每个模块都自定义了类加载器，需要更换模块时，模块与类加载器一起更换。其类加载的过程中，有平级的类加载器加载行为。打破的原因是为了实现模块热替换。</li>
<li>  JDK9，Extension ClassLoader 被 Platform ClassLoader 取代，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。打破的原因，是为了添加模块化的特性。</li>
</ul>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><ul>
<li>  安全性：避免用户自己编写的类动态替换 Java 的核心类，比如 <code>String.class</code>；</li>
<li>  避免类重复加载：因为 JVM 中区分不同的类不仅仅根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的类；</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201217213314510.png"></p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前主流 VM 垃圾收集都采用「分代收集」(Generational Collection) 算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如 JVM 中的新生代、老年代、永久代， 这样就可以根据各年代特点分别采用最适当的 GC 算法</p>
<h3 id="新生代与复制算法"><a href="#新生代与复制算法" class="headerlink" title="新生代与复制算法"></a>新生代与复制算法</h3><p>目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1:1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</p>
<h3 id="老年代与标记复制算法"><a href="#老年代与标记复制算法" class="headerlink" title="老年代与标记复制算法"></a>老年代与标记复制算法</h3><p><strong>而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。</strong></p>
<p><strong>1、</strong> JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)， 它用来存储 class 类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。</p>
<p><strong>2、</strong> 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代。</p>
<p><strong>3、</strong> 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后， EdenSpace 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 FromSpace 进行清理。</p>
<p><strong>4、</strong> 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。</p>
<p><strong>5、</strong> 在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。</p>
<p><strong>6、</strong> 当对象在 Survivor 去躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被移到老生代中。</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>GC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。</p>
<p><strong>标记 -清除算法</strong></p>
<p>「标记-清除」（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</p>
<p><strong>复制算法</strong></p>
<p>「<strong>复制</strong>」（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p><strong>标记-压缩算法</strong></p>
<p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
<p><strong>分代收集算法</strong></p>
<p>「分代收集」（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法</p>
<h2 id="JVM-年轻代到年老代的晋升过程的判断条件"><a href="#JVM-年轻代到年老代的晋升过程的判断条件" class="headerlink" title="JVM 年轻代到年老代的晋升过程的判断条件"></a>JVM 年轻代到年老代的晋升过程的判断条件</h2><ul>
<li>  部分对象会在 From 和 To 区域中复制来复制去,如此交换 15 次（由 JVM 参数 MaxTenuringThreshold 决定,这个参数默认是 15），最终如果还是存活,就存入到老年代。</li>
<li>  如果对象的大小大于 Eden 的二分之一会直接分配在 old，如果 old 也分配不下，会做一次 majorGC，如果小于 Eden 的一半但是没有足够的空间，就进行 minorgc 也就是新生代 GC。</li>
<li>  minorGC 后，survivor 仍然放不下，则放到老年代</li>
<li>  动态年龄判断 ，大于等于某个年龄的对象超过了 survivor 空间一半 ，大于等于某个年龄的对象直接进入老年代</li>
</ul>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="新生代垃圾收集器"><a href="#新生代垃圾收集器" class="headerlink" title="新生代垃圾收集器"></a>新生代垃圾收集器</h3><p><strong>Serial 收集器</strong></p>
<p>特点： Serial 收集器只能使用一条线程进行垃圾收集工作，并且在进行垃圾收集的时候，所有的工作线程都需要停止工作，等待垃圾收集线程完成以后，其他线程才可以继续工作。</p>
<p><strong>使用算法：复制算法</strong></p>
<p><strong>ParNew 收集器</strong></p>
<p>特点： ParNew 垃圾收集器是Serial收集器的多线程版本。为了利用 CPU 多核多线程的优势，ParNew 收集器可以运行多个收集线程来进行垃圾收集工作。这样可以提高垃圾收集过程的效率。</p>
<p><strong>使用算法：复制算法</strong></p>
<p><strong>Parallel Scavenge 收集器</strong></p>
<p>特点： Parallel Scavenge 收集器是一款多线程的垃圾收集器，但是它又和 ParNew 有很大的不同点。</p>
<p>Parallel Scavenge 收集器和其他收集器的关注点不同。其他收集器，比如 ParNew 和 CMS 这些收集器，它们主要关注的是如何缩短垃圾收集的时间。而 Parallel Scavenge 收集器关注的是如何控制系统运行的吞吐量。这里说的吞吐量，指的是 CPU 用于运行应用程序的时间和 CPU 总时间的占比，吞吐量 = 代码运行时间 / （代码运行时间 + 垃圾收集时间）。如果虚拟机运行的总的 CPU 时间是 100 分钟，而用于执行垃圾收集的时间为 1 分钟，那么吞吐量就是 99%。</p>
<p><strong>使用算法：复制算法</strong></p>
<h3 id="老年代垃圾收集器"><a href="#老年代垃圾收集器" class="headerlink" title="老年代垃圾收集器"></a>老年代垃圾收集器</h3><p><strong>Serial Old 收集器</strong></p>
<p>特点： Serial Old 收集器是 Serial 收集器的老年代版本。这款收集器主要用于客户端应用程序中作为老年代的垃圾收集器，也可以作为服务端应用程序的垃圾收集器。</p>
<p><strong>使用算法：标记-整理</strong></p>
<p><strong>Parallel Old 收集器</strong></p>
<p>特点： Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本这个收集器是在 JDK1.6 版本中出现的，所以在 JDK1.6 之前，新生代的 Parallel Scavenge 只能和 Serial Old 这款单线程的老年代收集器配合使用。Parallel Old 垃圾收集器和 Parallel Scavenge 收集器一样，也是一款关注吞吐量的垃圾收集器，和 Parallel Scavenge 收集器一起配合，可以实现对 Java 堆内存的吞吐量优先的垃圾收集策略。</p>
<p><strong>使用算法：标记-整理</strong></p>
<p><strong>CMS 收集器</strong></p>
<p>特点： CMS 收集器是目前老年代收集器中比较优秀的垃圾收集器。CMS 是 Concurrent Mark Sweep，从名字可以看出，这是一款使用”标记-清除”算法的并发收集器。</p>
<p>CMS 垃圾收集器是一款以获取最短停顿时间为目标的收集器。如下图所示：</p>
<p><img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/05/34/39_3.png#alt=39%5C_3.png"></p>
<p><strong>从图中可以看出，CMS 收集器的工作过程可以分为 4 个阶段：</strong></p>
<p><strong>1、</strong> 初始标记（CMS initial mark）阶段</p>
<p><strong>2、</strong> 并发标记（CMS concurrent mark）阶段</p>
<p><strong>3、</strong> 重新标记（CMS remark）阶段</p>
<p><strong>4、</strong> 并发清除(（CMS concurrent sweep）阶段</p>
<p>使用算法：复制+标记清除</p>
<p><strong>其他</strong></p>
<p><strong>G1 垃圾收集器</strong></p>
<p>特点： 主要步骤：<code>初始标记，并发标记，重新标记，复制清除。</code></p>
<p><strong>使用算法：复制 + 标记整理</strong></p>
<h3 id="你了解过哪些垃圾收集器"><a href="#你了解过哪些垃圾收集器" class="headerlink" title="你了解过哪些垃圾收集器"></a>你了解过哪些垃圾收集器</h3><p>年轻代 Serial 垃圾收集器（单线程，通常用在客户端应用上。因为客户端应用不会频繁创建很多对象，用户也不会感觉出明显的卡顿。相反，它使用的资源更少，也更轻量级。） ParNew 垃圾收集器（多线程，追求降低用户停顿时间，适合交互式应用。） Parallel Scavenge 垃圾收集器（追求 CPU 吞吐量，能够在较短时间内完成指定任务，适合没有交互的后台计算。）</p>
<p>老年代 Serial Old 垃圾收集器 Parallel Old垃圾收集器 CMS 垃圾收集器（以获取最短 GC 停顿时间为目标的收集器，它在垃圾收集时使得用户线程和 GC 线程能够并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。）</p>
<h3 id="Parallel-Old-收集器（多线程标记整理算法）"><a href="#Parallel-Old-收集器（多线程标记整理算法）" class="headerlink" title="Parallel Old 收集器（多线程标记整理算法）"></a>Parallel Old 收集器（多线程标记整理算法）</h3><p>Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6才开始提供。</p>
<p>在 JDK6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量， Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器， 如果系统对吞吐量要求比较高，可以优先考虑新生代Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。</p>
<h3 id="分布式垃圾回收（DGC）是如何工作的"><a href="#分布式垃圾回收（DGC）是如何工作的" class="headerlink" title="分布式垃圾回收（DGC）是如何工作的"></a>分布式垃圾回收（DGC）是如何工作的</h3><p>DGC 叫做分布式垃圾回收。RMI 使用 DGC 来做自动垃圾回收。因为 RMI 包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC 使用引用计数算法来给远程对象提供自动内存管理。</p>
<h2 id="Serial-与-Parallel-GC-的区别"><a href="#Serial-与-Parallel-GC-的区别" class="headerlink" title="Serial 与 Parallel GC 的区别"></a>Serial 与 Parallel GC 的区别</h2><p>Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而parallel 收集器使用多个 GC 线程来执行。</p>
<h2 id="GC-如何判断对象可以被回收"><a href="#GC-如何判断对象可以被回收" class="headerlink" title="GC 如何判断对象可以被回收"></a>GC 如何判断对象可以被回收</h2><ul>
<li>引用计数法（主流虚拟机未采用）：当对象被引用，计数器 +1，引用释放 -1，当计数器为 0 时表示可以释放；<ul>
<li>  缺陷：当 A B 互相引用时，A B 都不会被释放；</li>
</ul>
</li>
<li>可达性分析法：从 GC Roots 开始向下搜索，搜索走过的路径称之为引用链，当一个对象到 GC Roots 没有任何链接时，证明此对象不可用，是可回收对象。<ul>
<li>  虚拟机栈（栈中的本地变量表）中引用的对象；</li>
<li>  方法区中类静态属性引用的对象；</li>
<li>  方法区中常量引用的对象；</li>
<li>  本地方法栈中 JNI（即一般说的 Native 方法）引用的对象；</li>
</ul>
</li>
</ul>
<p>可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会，在虚拟机自动建立的 Finalizer 队列中判断是否需要执行 <code>finalizer()</code> 方法，如未重写，则直接将其回收。当方法执行完成之后，GC 会再次对可达性进行判断。每个对象只能触发一次 <code>finalizer()</code> 方法。</p>
<h2 id="JVM-中一次完整的-GC-流程是怎样的，对象如何晋升到老年代"><a href="#JVM-中一次完整的-GC-流程是怎样的，对象如何晋升到老年代" class="headerlink" title="JVM 中一次完整的 GC 流程是怎样的，对象如何晋升到老年代"></a>JVM 中一次完整的 GC 流程是怎样的，对象如何晋升到老年代</h2><p>当 Eden 区的空间满了， Java 虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor 区。大对象（需要大量连续内存空间的 Java 对象，如那种很长的字符串）直接进入老年态；如果对象在 Eden 出生，并经过第一次 Minor GC 后仍然存活，并且被 Survivor 容纳的话，年龄设为 1，每熬过一次 Minor GC，年龄 +1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行 Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。Major GC 发生在老年代的 GC，清理老年区，经常会伴随至少一次 Minor GC，比 Minor GC 慢 10 倍以上。</p>
<h2 id="Java-内存分配与回收策率以及-Minor-GC-和-Major-GC"><a href="#Java-内存分配与回收策率以及-Minor-GC-和-Major-GC" class="headerlink" title="Java 内存分配与回收策率以及 Minor GC 和 Major GC"></a>Java 内存分配与回收策率以及 Minor GC 和 Major GC</h2><p><strong>1、</strong> 对象优先在堆的 Eden 区分配</p>
<p><strong>2、</strong> 大对象直接进入老年代</p>
<p><strong>3、</strong> 长期存活的对象将直接进入老年代</p>
<p>当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC。Minor GC 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高，回收速度比较快；Full GC/Major GC 发生在老年代，一般情况下，触发老年代 GC 的时候不会触发 Minor GC，但是通过配置，可以在 Full GC 之前进行一次 Minor GC 这样可以加快老年代的回收速度。</p>
<h2 id="简单描述一下（分代）垃圾回收的过程"><a href="#简单描述一下（分代）垃圾回收的过程" class="headerlink" title="简单描述一下（分代）垃圾回收的过程"></a>简单描述一下（分代）垃圾回收的过程</h2><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 <code>1/3</code>，老生代的默认占比是 <code>2/3</code>。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：<code>Eden</code>、<code>To Survivor</code>、<code>From Survivor</code>，它们的默认占比是 <code>8:1:1</code>，它的执行流程如下：</p>
<p><strong>当年轻代中的Eden区分配满的时候，就会触发年轻代的GC（Minor GC）。具体过程如下：</strong></p>
<ul>
<li>在Eden区执行了 <code>第一次</code>GC之后，存活的对象会被移动到其中一个Survivor分区（以下简称from）</li>
<li>Eden区再次GC，这时会采用复制算法，将Eden和from区一起清理。存活的对象会被复制到to区。接下来，只需要清空from区就可以了</li>
</ul>
<h2 id="问与答"><a href="#问与答" class="headerlink" title="问与答"></a>问与答</h2><h3 id="你能保证-GC-执行吗"><a href="#你能保证-GC-执行吗" class="headerlink" title="你能保证 GC 执行吗"></a>你能保证 GC 执行吗</h3><p>不能，虽然你可以调用 <code>System.gc()</code> 或者 <code>Runtime.gc()</code>，但是没有办法保证 GC 的执行。</p>
<h3 id="被引用的对象就一定能存活吗"><a href="#被引用的对象就一定能存活吗" class="headerlink" title="被引用的对象就一定能存活吗"></a>被引用的对象就一定能存活吗</h3><p>不一定，看 Reference 类型，弱引用在 GC 时会被回收，软引用在内存不足的时候，即 OOM 前会被回收，但如果没有在 Reference Chain 中的对象就一定会被回收。</p>
<h3 id="如果对象的引用被置为-null，垃圾收集器是否会立即释放对象占用的内存"><a href="#如果对象的引用被置为-null，垃圾收集器是否会立即释放对象占用的内存" class="headerlink" title="如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存"></a>如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存</h3><p>不会，在下一个垃圾回调周期中，这个对象将是被可回收的，也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。</p>
<h3 id="JVM-出现-fullGC-很频繁，怎么去线上排查问题"><a href="#JVM-出现-fullGC-很频繁，怎么去线上排查问题" class="headerlink" title="JVM 出现 fullGC 很频繁，怎么去线上排查问题"></a>JVM 出现 fullGC 很频繁，怎么去线上排查问题</h3><p><strong>这题就依据 full GC 的触发条件来做：</strong></p>
<ol>
<li>如果有 perm gen 的话(JDK8 就没了)，要给 perm gen 分配空间，但没有足够的空间时，会触发 full gc；</li>
<li>所以看看是不是 perm gen 区的值设置得太小了；</li>
<li><code>System.gc()</code>方法的调用；</li>
<li>当统计得到的 Minor GC 晋升到旧生代的平均大小大于老年代的剩余空间，则会触发 full gc(这就可以从多个角度上看了)；</li>
<li>是不是频繁创建了大对象(也有可能eden区设置过小)(大对象直接分配在老年代中，导致老年代空间不足—&gt;从而频繁 gc)；</li>
<li>是不是老年代的空间设置过小了(Minor GC 几个对象就大于老年代的剩余空间了)</li>
</ol>
<h3 id="你有哪些手段来排查-OOM-的问题？"><a href="#你有哪些手段来排查-OOM-的问题？" class="headerlink" title="你有哪些手段来排查 OOM 的问题？"></a>你有哪些手段来排查 OOM 的问题？</h3><ol>
<li>增加两个参数 <code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof</code>，当 OOM 发生时自动 dump 堆内存信息到指定目录</li>
<li>同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域</li>
<li>使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用</li>
</ol>
<h2 id="生产上如何配置垃圾收集器的"><a href="#生产上如何配置垃圾收集器的" class="headerlink" title="生产上如何配置垃圾收集器的"></a>生产上如何配置垃圾收集器的</h2><p>首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。通常，堆空间我会设置成操作系统的<code>2/3</code>（这是想给其他进程和操作系统预留一些时间），超过8GB的堆优先选用 G1。</p>
<p>接下来，我会对JVM进行初步优化。比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例。</p>
<p>再接下来，就是专项优化，主要判断的依据就是系统容量、访问延迟、吞吐量等。我们的服务是高并发的，所以对STW的时间非常敏感。</p>
<p>我会通过记录详细的GC日志，来找到这个瓶颈点，借用<code>gceasy</code>（重点）这样的日志分析工具，很容易定位到问题。之所以选择采用工具，是因为gc日志看起来实在是太麻烦了，gceasy号称是AI学习分析问题，可视化做的较好。</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="JVM-参数"><a href="#JVM-参数" class="headerlink" title="JVM 参数"></a>JVM 参数</h2><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">参数查询官网地址</a>。建议面试时最好能记住 CMS 和 G1 的参数，特点突出使用较多，被问的概率大。Java 8 为例：</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul>
<li>  <code>-XX:+PrintFlagsFinal</code>：打印 JVM 所有参数的值</li>
<li>  <code>-XX:+PrintGC</code>：打印 GC 信息</li>
<li>  <code>-XX:+PrintGCDetails</code>：打印 GC 详细信息</li>
<li>  <code>-XX:+PrintGCTimeStamps</code>：打印 GC 的时间戳</li>
<li>  <code>-Xloggc:filename</code>：设置 GC log 文件的位置</li>
<li>  <code>-XX:+PrintTenuringDistribution</code>：查看熬过收集后剩余对象的年龄分布信息</li>
</ul>
<h3 id="内存设置"><a href="#内存设置" class="headerlink" title="内存设置"></a>内存设置</h3><ul>
<li>  <code>-Xms</code>：设置堆的初始化内存大小</li>
<li>  <code>-Xmx</code>：设置堆的最大内存</li>
<li>  <code>-Xmn</code>：设置新生代内存大小</li>
<li>  <code>-Xss</code>：设置线程栈大小</li>
<li>  <code>-XX:NewRatio</code>：新生代与老年代比值</li>
<li>  <code>-XX:SurvivorRatio</code>：新生代中 Eden 区与两个 Survivor 区的比值，默认为 8，即Eden:Survivor:Survivor=8:1:1</li>
<li>  <code>-XX:MaxTenuringThreshold</code>：从年轻代到老年代，最大晋升年龄。CMS 下默认为 6，G1 下默认为 15</li>
<li>  <code>-XX:MetaspaceSize</code>：设置元空间的大小，第一次超过将触发 GC</li>
<li>  <code>-XX:MaxMetaspaceSize</code>：元空间最大值</li>
<li>  <code>-XX:MaxDirectMemorySize</code>：用于设置直接内存的最大值，限制通过 DirectByteBuffer 申请的内存</li>
<li>  <code>-XX:ReservedCodeCacheSize</code>：用于设置 JIT 编译后的代码存放区大小，如果观察到这个值有限制，可以适当调大，一般够用即可</li>
</ul>
<h3 id="设置垃圾收集相关"><a href="#设置垃圾收集相关" class="headerlink" title="设置垃圾收集相关"></a>设置垃圾收集相关</h3><ul>
<li>  <code>-XX:+UseSerialGC</code>：设置串行收集器</li>
<li>  <code>-XX:+UseParallelGC</code>：设置并行收集器</li>
<li>  <code>-XX:+UseConcMarkSweepGC</code>：使用 CMS 收集器</li>
<li>  <code>-XX:ParallelGCThreads</code>：设置 Parallel GC 的线程数</li>
<li>  <code>-XX:MaxGCPauseMillis</code>：GC 最大暂停时间 ms</li>
<li>  <code>-XX:+UseG1GC</code>：使用 G1 垃圾收集器</li>
</ul>
<h3 id="CMS-垃圾回收器相关"><a href="#CMS-垃圾回收器相关" class="headerlink" title="CMS 垃圾回收器相关"></a>CMS 垃圾回收器相关</h3><ul>
<li>  <code>-XX:+UseCMSInitiatingOccupancyOnly</code></li>
<li>  <code>-XX:CMSInitiatingOccupancyFraction</code>：与前者配合使用，指定MajorGC的发生时机</li>
<li>  <code>-XX:+ExplicitGCInvokesConcurrent</code>：代码调用 <code>System.gc()</code> 开始并行 FullGC，建议加上这个参数</li>
<li>  <code>-XX:+CMSScavengeBeforeRemark</code>：表示开启或关闭在 CMS 重新标记阶段之前的清除（YGC）尝试，它可以降低 remark 时间，建议加上</li>
<li>  <code>-XX:+ParallelRefProcEnabled</code>：可以用来并行处理 Reference，以加快处理速度，缩短耗时</li>
</ul>
<h3 id="G1-垃圾回收器相关"><a href="#G1-垃圾回收器相关" class="headerlink" title="G1 垃圾回收器相关"></a>G1 垃圾回收器相关</h3><ul>
<li>  <code>-XX:MaxGCPauseMillis</code>：用于设置目标停顿时间，G1 会尽力达成</li>
<li>  <code>-XX:G1HeapRegionSize</code>：用于设置小堆区大小，建议保持默认</li>
<li>  <code>-XX:InitiatingHeapOccupancyPercent</code>：表示当整个堆内存使用达到一定比例（默认是 45%），并发标记阶段就会被启动</li>
<li>  <code>-XX:ConcGCThreads</code>：表示并发垃圾收集器使用的线程数量，默认值随 JVM 运行的平台不同而变动，不建议修改</li>
</ul>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul>
<li>  <code>-XX:+UseCompressedOops</code>：当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从 32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU 缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM 主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过 <code>-XX:+UseCompressedOops</code> 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。</li>
</ul>
<h2 id="重排序实际执行的指令步骤"><a href="#重排序实际执行的指令步骤" class="headerlink" title="重排序实际执行的指令步骤"></a>重排序实际执行的指令步骤</h2><ol>
<li>  编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>  指令级并行的重排序。现代处理器采用了指令级并行技术（ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>  内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<p>这些重排序对于单线程没问题，但是多线程都可能会导致多线程程序出现内存可见性问题。</p>
<h2 id="invokedynamic-指令是干什么的？"><a href="#invokedynamic-指令是干什么的？" class="headerlink" title="invokedynamic 指令是干什么的？"></a>invokedynamic 指令是干什么的？</h2><p>属于比较高级的题目。没看过虚拟机的一般是不知道的。所以如果你不太熟悉，不要气馁。</p>
<p><code>invokedynamic</code> 是 <code>JDK7</code> 之后新加入的字节码指令，使用它可以实现一些动态类型语言的功能。我们使用的 Lambda 表达式，在字节码上就是 invokedynamic 指令实现的。它的功能有点类似反射，但它是使用方法句柄实现的，执行效率更高。</p>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903957060386823">JVM - 掘金 (juejin.cn)</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>JVM</p><p><a href="https://blog.hr947x.com/548314b5b0e6/">https://blog.hr947x.com/548314b5b0e6/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>小徐</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-02-15</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-03-22</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="link-muted mr-2" rel="tag" href="/tags/JVM/">JVM</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/0e756a811773/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">代码</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/67a1548e8c24/"><span class="level-item">线程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#基础"><span class="level-left"><span class="level-item">1</span><span class="level-item">基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#怎样判断-JVM-是-32-位还是-64-位"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">怎样判断 JVM 是 32 位还是 64 位</span></span></a></li><li><a class="level is-mobile" href="#32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？</span></span></a></li><li><a class="level is-mobile" href="#编译期常量是什么"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">编译期常量是什么</span></span></a></li><li><a class="level is-mobile" href="#对象分配内存是否线程安全"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">对象分配内存是否线程安全</span></span></a></li><li><a class="level is-mobile" href="#Java-程序是怎样运行的"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">Java 程序是怎样运行的</span></span></a></li><li><a class="level is-mobile" href="#说一下-Java-对象的创建过程"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">说一下 Java 对象的创建过程</span></span></a></li><li><a class="level is-mobile" href="#64-位-JVM-中，int-的长度是多少"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">64 位 JVM 中，int 的长度是多少</span></span></a></li><li><a class="level is-mobile" href="#守护线程和本地线程区别"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">守护线程和本地线程区别</span></span></a></li><li><a class="level is-mobile" href="#Java-会存在内存泄漏吗"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">Java 会存在内存泄漏吗</span></span></a></li><li><a class="level is-mobile" href="#Java-对象的布局"><span class="level-left"><span class="level-item">1.10</span><span class="level-item">Java 对象的布局</span></span></a></li><li><a class="level is-mobile" href="#stackoverflow-错误、permgen-space-错误"><span class="level-left"><span class="level-item">1.11</span><span class="level-item">stackoverflow 错误、permgen space 错误</span></span></a></li><li><a class="level is-mobile" href="#Java-有哪些引用类型"><span class="level-left"><span class="level-item">1.12</span><span class="level-item">Java 有哪些引用类型</span></span></a></li><li><a class="level is-mobile" href="#对象的访问定位有哪几种方式"><span class="level-left"><span class="level-item">1.13</span><span class="level-item">对象的访问定位有哪几种方式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#类"><span class="level-left"><span class="level-item">2</span><span class="level-item">类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#描述一下-JVM-加载-class-文件的原理机制"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">描述一下 JVM 加载 class 文件的原理机制</span></span></a></li><li><a class="level is-mobile" href="#Class-文件"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Class 文件</span></span></a></li><li><a class="level is-mobile" href="#类加载器"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">类加载器</span></span></a></li><li><a class="level is-mobile" href="#类加载顺序"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">类加载顺序</span></span></a></li><li><a class="level is-mobile" href="#JVM-类加载机制"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">JVM 类加载机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#加载"><span class="level-left"><span class="level-item">2.5.1</span><span class="level-item">加载</span></span></a></li><li><a class="level is-mobile" href="#验证"><span class="level-left"><span class="level-item">2.5.2</span><span class="level-item">验证</span></span></a></li><li><a class="level is-mobile" href="#准备"><span class="level-left"><span class="level-item">2.5.3</span><span class="level-item">准备</span></span></a></li><li><a class="level is-mobile" href="#解析"><span class="level-left"><span class="level-item">2.5.4</span><span class="level-item">解析</span></span></a></li><li><a class="level is-mobile" href="#初始化"><span class="level-left"><span class="level-item">2.5.5</span><span class="level-item">初始化</span></span></a></li></ul></li><li><a class="level is-mobile" href="#类初始化的情况"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">类初始化的情况</span></span></a></li></ul></li><li><a class="level is-mobile" href="#内存"><span class="level-left"><span class="level-item">3</span><span class="level-item">内存</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基本术语"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">基本术语</span></span></a></li><li><a class="level is-mobile" href="#内存分配"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">内存分配</span></span></a></li><li><a class="level is-mobile" href="#W-JVM-内存区域"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">W JVM 内存区域</span></span></a></li><li><a class="level is-mobile" href="#W-内存结构"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">W 内存结构</span></span></a></li><li><a class="level is-mobile" href="#JDK8-与元数据"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">JDK8 与元数据</span></span></a></li><li><a class="level is-mobile" href="#Java-中堆和栈有什么区别"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">Java 中堆和栈有什么区别</span></span></a></li><li><a class="level is-mobile" href="#堆-heap"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">堆 heap</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Java-堆的结构是什么样子的？什么是堆中的永久代（Perm-Gen-space）"><span class="level-left"><span class="level-item">3.7.1</span><span class="level-item">Java 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space）</span></span></a></li><li><a class="level is-mobile" href="#说一下堆内存中对象的分配的基本策略"><span class="level-left"><span class="level-item">3.7.2</span><span class="level-item">说一下堆内存中对象的分配的基本策略</span></span></a></li></ul></li><li><a class="level is-mobile" href="#栈-stack"><span class="level-left"><span class="level-item">3.8</span><span class="level-item">栈 stack</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#栈帧都有哪些数据？"><span class="level-left"><span class="level-item">3.8.1</span><span class="level-item">栈帧都有哪些数据？</span></span></a></li><li><a class="level is-mobile" href="#什么情况下会发生栈内存溢出？"><span class="level-left"><span class="level-item">3.8.2</span><span class="level-item">什么情况下会发生栈内存溢出？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#方法区的作用"><span class="level-left"><span class="level-item">3.9</span><span class="level-item">方法区的作用</span></span></a></li><li><a class="level is-mobile" href="#运行时常量池的作用"><span class="level-left"><span class="level-item">3.10</span><span class="level-item">运行时常量池的作用</span></span></a></li><li><a class="level is-mobile" href="#程序计数器"><span class="level-left"><span class="level-item">3.11</span><span class="level-item">程序计数器</span></span></a></li><li><a class="level is-mobile" href="#JVM-新生代中为什么要分为-Eden-和-Survivor"><span class="level-left"><span class="level-item">3.12</span><span class="level-item">JVM 新生代中为什么要分为 Eden 和 Survivor</span></span></a></li><li><a class="level is-mobile" href="#JDK8-为什么要将永久代替换为元空间呢？"><span class="level-left"><span class="level-item">3.13</span><span class="level-item">JDK8 为什么要将永久代替换为元空间呢？</span></span></a></li><li><a class="level is-mobile" href="#解释内存中的栈、堆和方法区的用法"><span class="level-left"><span class="level-item">3.14</span><span class="level-item">解释内存中的栈、堆和方法区的用法</span></span></a></li><li><a class="level is-mobile" href="#什么情况下会出现内存溢出，内存泄漏"><span class="level-left"><span class="level-item">3.15</span><span class="level-item">什么情况下会出现内存溢出，内存泄漏</span></span></a></li></ul></li><li><a class="level is-mobile" href="#双亲委派机制"><span class="level-left"><span class="level-item">4</span><span class="level-item">双亲委派机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#打破双亲委派机制的例子"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">打破双亲委派机制的例子</span></span></a></li><li><a class="level is-mobile" href="#双亲委派模型"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">双亲委派模型</span></span></a></li></ul></li><li><a class="level is-mobile" href="#垃圾回收"><span class="level-left"><span class="level-item">5</span><span class="level-item">垃圾回收</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#算法"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#分代收集算法"><span class="level-left"><span class="level-item">5.1.1</span><span class="level-item">分代收集算法</span></span></a></li><li><a class="level is-mobile" href="#新生代与复制算法"><span class="level-left"><span class="level-item">5.1.2</span><span class="level-item">新生代与复制算法</span></span></a></li><li><a class="level is-mobile" href="#老年代与标记复制算法"><span class="level-left"><span class="level-item">5.1.3</span><span class="level-item">老年代与标记复制算法</span></span></a></li><li><a class="level is-mobile" href="#垃圾收集算法"><span class="level-left"><span class="level-item">5.1.4</span><span class="level-item">垃圾收集算法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#JVM-年轻代到年老代的晋升过程的判断条件"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">JVM 年轻代到年老代的晋升过程的判断条件</span></span></a></li><li><a class="level is-mobile" href="#垃圾收集器"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">垃圾收集器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#新生代垃圾收集器"><span class="level-left"><span class="level-item">5.3.1</span><span class="level-item">新生代垃圾收集器</span></span></a></li><li><a class="level is-mobile" href="#老年代垃圾收集器"><span class="level-left"><span class="level-item">5.3.2</span><span class="level-item">老年代垃圾收集器</span></span></a></li><li><a class="level is-mobile" href="#你了解过哪些垃圾收集器"><span class="level-left"><span class="level-item">5.3.3</span><span class="level-item">你了解过哪些垃圾收集器</span></span></a></li><li><a class="level is-mobile" href="#Parallel-Old-收集器（多线程标记整理算法）"><span class="level-left"><span class="level-item">5.3.4</span><span class="level-item">Parallel Old 收集器（多线程标记整理算法）</span></span></a></li><li><a class="level is-mobile" href="#分布式垃圾回收（DGC）是如何工作的"><span class="level-left"><span class="level-item">5.3.5</span><span class="level-item">分布式垃圾回收（DGC）是如何工作的</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Serial-与-Parallel-GC-的区别"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">Serial 与 Parallel GC 的区别</span></span></a></li><li><a class="level is-mobile" href="#GC-如何判断对象可以被回收"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">GC 如何判断对象可以被回收</span></span></a></li><li><a class="level is-mobile" href="#JVM-中一次完整的-GC-流程是怎样的，对象如何晋升到老年代"><span class="level-left"><span class="level-item">5.6</span><span class="level-item">JVM 中一次完整的 GC 流程是怎样的，对象如何晋升到老年代</span></span></a></li><li><a class="level is-mobile" href="#Java-内存分配与回收策率以及-Minor-GC-和-Major-GC"><span class="level-left"><span class="level-item">5.7</span><span class="level-item">Java 内存分配与回收策率以及 Minor GC 和 Major GC</span></span></a></li><li><a class="level is-mobile" href="#简单描述一下（分代）垃圾回收的过程"><span class="level-left"><span class="level-item">5.8</span><span class="level-item">简单描述一下（分代）垃圾回收的过程</span></span></a></li><li><a class="level is-mobile" href="#问与答"><span class="level-left"><span class="level-item">5.9</span><span class="level-item">问与答</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#你能保证-GC-执行吗"><span class="level-left"><span class="level-item">5.9.1</span><span class="level-item">你能保证 GC 执行吗</span></span></a></li><li><a class="level is-mobile" href="#被引用的对象就一定能存活吗"><span class="level-left"><span class="level-item">5.9.2</span><span class="level-item">被引用的对象就一定能存活吗</span></span></a></li><li><a class="level is-mobile" href="#如果对象的引用被置为-null，垃圾收集器是否会立即释放对象占用的内存"><span class="level-left"><span class="level-item">5.9.3</span><span class="level-item">如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存</span></span></a></li><li><a class="level is-mobile" href="#JVM-出现-fullGC-很频繁，怎么去线上排查问题"><span class="level-left"><span class="level-item">5.9.4</span><span class="level-item">JVM 出现 fullGC 很频繁，怎么去线上排查问题</span></span></a></li><li><a class="level is-mobile" href="#你有哪些手段来排查-OOM-的问题？"><span class="level-left"><span class="level-item">5.9.5</span><span class="level-item">你有哪些手段来排查 OOM 的问题？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#生产上如何配置垃圾收集器的"><span class="level-left"><span class="level-item">5.10</span><span class="level-item">生产上如何配置垃圾收集器的</span></span></a></li></ul></li><li><a class="level is-mobile" href="#拓展"><span class="level-left"><span class="level-item">6</span><span class="level-item">拓展</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#JVM-参数"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">JVM 参数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#日志"><span class="level-left"><span class="level-item">6.1.1</span><span class="level-item">日志</span></span></a></li><li><a class="level is-mobile" href="#内存设置"><span class="level-left"><span class="level-item">6.1.2</span><span class="level-item">内存设置</span></span></a></li><li><a class="level is-mobile" href="#设置垃圾收集相关"><span class="level-left"><span class="level-item">6.1.3</span><span class="level-item">设置垃圾收集相关</span></span></a></li><li><a class="level is-mobile" href="#CMS-垃圾回收器相关"><span class="level-left"><span class="level-item">6.1.4</span><span class="level-item">CMS 垃圾回收器相关</span></span></a></li><li><a class="level is-mobile" href="#G1-垃圾回收器相关"><span class="level-left"><span class="level-item">6.1.5</span><span class="level-item">G1 垃圾回收器相关</span></span></a></li><li><a class="level is-mobile" href="#JVM"><span class="level-left"><span class="level-item">6.1.6</span><span class="level-item">JVM</span></span></a></li></ul></li><li><a class="level is-mobile" href="#重排序实际执行的指令步骤"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">重排序实际执行的指令步骤</span></span></a></li><li><a class="level is-mobile" href="#invokedynamic-指令是干什么的？"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">invokedynamic 指令是干什么的？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#资料"><span class="level-left"><span class="level-item">7</span><span class="level-item">资料</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-20T05:35:04.000Z">2022-04-20</time></p><p class="title"><a href="/4e2ca58138aa/">Linux sed 教程</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-07T13:14:08.000Z">2022-04-07</time></p><p class="title"><a href="/e7a6f47a5edd/">IDEA 快捷键</a></p><p class="categories"><a href="/categories/%E6%95%99%E7%A8%8B/">教程</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-20T08:38:54.000Z">2022-03-20</time></p><p class="title"><a href="/de4a65c796a3/">Java 基础</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a> / <a href="/categories/%E9%9D%A2%E8%AF%95/Java%E5%9F%BA%E7%A1%80/">Java基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-19T10:01:25.000Z">2022-03-19</time></p><p class="title"><a href="/906fcab3c166/">Java 新特性</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a> / <a href="/categories/%E9%9D%A2%E8%AF%95/Java%E5%9F%BA%E7%A1%80/">Java基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-19T05:27:25.000Z">2022-03-19</time></p><p class="title"><a href="/9d30f1f85362/">macOS 环境搭建</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">小徐&#039;s Blog</a><p class="is-size-7"><span>&copy; 2022 小徐</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="蜀ICP备20016181号-1" href="https://beian.miit.gov.cn/">蜀ICP备20016181号-1</a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>