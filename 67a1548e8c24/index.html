<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>线程 - 小徐&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="小徐&#039;s Blog"><meta name="msapplication-TileImage" content="icons/touch-icon-iphone.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="小徐&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="144x144" href="icons/touch-icon-iphone.png"><link rel="apple-touch-icon" sizes="152x152" href="icons/touch-icon-ipad.png"><link rel="apple-touch-icon" sizes="72x72" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="96x96" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="128x128" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="256x256" href="icon/logo.ico"><meta name="description" content="线程面试题"><meta property="og:type" content="article"><meta property="og:title" content="线程"><meta property="og:url" content="https://blog.hr947x.com/67a1548e8c24/"><meta property="og:site_name" content="小徐&#039;s Blog"><meta property="og:description" content="线程面试题"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2019/08/0816/03/img_2.png#alt=img%5C_2.png"><meta property="article:published_time" content="2022-02-15T08:01:00.000Z"><meta property="article:modified_time" content="2022-03-21T12:55:18.000Z"><meta property="article:author" content="小徐"><meta property="article:tag" content="面试"><meta property="article:tag" content="线程"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2019/08/0816/03/img_2.png#alt=img%5C_2.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hr947x.com/67a1548e8c24/"},"headline":"线程","image":["https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2019/08/0816/03/img_2.png#alt=img%5C_2.png"],"datePublished":"2022-02-15T08:01:00.000Z","dateModified":"2022-03-21T12:55:18.000Z","author":{"@type":"Person","name":"小徐"},"publisher":{"@type":"Organization","name":"小徐's Blog","logo":{"@type":"ImageObject","url":{"text":"小徐's Blog"}}},"description":"线程面试题"}</script><link rel="canonical" href="https://blog.hr947x.com/67a1548e8c24/"><link rel="icon" href="/img/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">小徐&#039;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">博客</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="踽踽独行" href="https://www.hr947x.com">踽踽独行</a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-15T08:01:00.000Z" title="2/15/2022, 8:01:00 AM">2022-02-15</time>发表</span><span class="level-item"><time dateTime="2022-03-21T12:55:18.000Z" title="3/21/2022, 12:55:18 PM">2022-03-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span> / </span><a class="link-muted" href="/categories/%E9%9D%A2%E8%AF%95/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span><span class="level-item">1 小时读完 (大约12836个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">线程</h1><div class="content"><p>线程面试题</p>
<span id="more"></span>

<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p><a target="_blank" rel="noopener" href="https://www.pdai.tech/md/java/thread/java-thread-x-overview.html">♥Java并发知识体系详解♥ | Java 全栈知识体系 (pdai.tech)</a></p>
<h2 id="并发的三大特性"><a href="#并发的三大特性" class="headerlink" title="并发的三大特性"></a>并发的三大特性</h2><ul>
<li>原子性：最小的操作单元，原子性指的是一个或多个操作要么全部执行成功要么全部执行失败<ul>
<li>  synchronized</li>
</ul>
</li>
<li>可见性：多个线程访问同一个变量时，一个线程修改了这个值，其他线程能立马看到修改的值；<ul>
<li>  volatile、synchronized、final</li>
</ul>
</li>
<li>有序性：程序执行的顺序按照代码的先后顺序执行（处理器可能会对指令进行重排序：对那些改变顺序后不会对最终结果造成影响的代码，有可能将他们重排，实际上，有些代码重排后对变量值没影响，但可能会出现线程安全问题）<ul>
<li>  volatile、synchronized</li>
</ul>
</li>
</ul>
<h2 id="并发-并行-串行"><a href="#并发-并行-串行" class="headerlink" title="并发 并行 串行"></a>并发 并行 串行</h2><ul>
<li>  <strong>串行</strong>在时间上不能重叠，前一个任务没执行完，第二个任务不会执行；</li>
<li>  <strong>并行</strong>在时间上重叠的，两个任务在同一时刻互不干扰的运行；</li>
<li>  <strong>并发</strong>允许两个任务彼此干扰，同一时间点只有一个任务运行，交替执行；</li>
</ul>
<p>通俗易懂版：</p>
<ul>
<li>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</li>
<li>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</li>
<li>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</li>
</ul>
<h2 id="Threrad-Runable-的区别"><a href="#Threrad-Runable-的区别" class="headerlink" title="Threrad Runable 的区别"></a>Threrad Runable 的区别</h2><ul>
<li>  Thread 是类，复杂的多线程选择继承 Thread</li>
<li>  Runable 是接口，简单的执行任务实现 Runable；</li>
</ul>
<h2 id="两个线程间共享数据"><a href="#两个线程间共享数据" class="headerlink" title="两个线程间共享数据"></a>两个线程间共享数据</h2><p>在两个线程间共享变量即可实现共享。</p>
<p>一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。</p>
<h2 id="什么是自旋"><a href="#什么是自旋" class="headerlink" title="什么是自旋"></a>什么是自旋</h2><p>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>
<p>忙循环：就是程序员用循环让一个线程等待，不像传统方法 wait(), sleep() 或 yield() 它们都放弃了 CPU 控制，而忙循环不会放弃 CPU，它就是在运行一个空循环。这么做的目的是为了保留 CPU 缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</p>
<h2 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h2><ul>
<li>  多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</li>
<li>  概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</li>
<li>  上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</li>
<li>  Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</li>
</ul>
<h2 id="常用的并发工具类有哪些"><a href="#常用的并发工具类有哪些" class="headerlink" title="常用的并发工具类有哪些"></a>常用的并发工具类有哪些</h2><ul>
<li>  CountDownLatch</li>
<li>  CyclicBarrier</li>
<li>  Semaphore</li>
<li>  Exchanger</li>
</ul>
<h2 id="线程和进程区别"><a href="#线程和进程区别" class="headerlink" title="线程和进程区别"></a>线程和进程区别</h2><p>进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。</p>
<p>一个程序至少有一个进程,一个进程至少有一个线程。</p>
<p>什么是线程和进程?</p>
<p><strong>进程</strong></p>
<p>一个在内存中运行的应用程序。 每个正在系统上运行的程序都是一个进程</p>
<p><strong>线程</strong></p>
<p>进程中的一个执行任务（控制单元）， 它负责在程序里独立执行。</p>
<p>一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据</p>
<p><strong>进程与线程的区别</strong></p>
<p><strong>1、</strong> 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p>
<p><strong>2、</strong> 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>
<p><strong>3、</strong> 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>
<p><strong>4、</strong> 内存分配：同一进程的线程共享本进程的地址空间和资源，而进程与进程之间的地址空间和资源是相互独立的</p>
<p><strong>5、</strong> 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃有可能导致整个进程都死掉。所以多进程要比多线程健壮。</p>
<p><strong>6、</strong> 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p>
<h2 id="进程概念、线程概念、线程与进程联系"><a href="#进程概念、线程概念、线程与进程联系" class="headerlink" title="进程概念、线程概念、线程与进程联系"></a>进程概念、线程概念、线程与进程联系</h2><p>进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。</p>
<p>线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</p>
<p>一个程序运行后至少有一个进程，一个进程中可以包含多个线程,但一个进程中至少包含一个线程。比如使用迅雷软件下载网络文件时，同时下载多个文件，就使用到了多线程下载。</p>
<h2 id="多线程的出现是要解决什么问题的"><a href="#多线程的出现是要解决什么问题的" class="headerlink" title="多线程的出现是要解决什么问题的?"></a>多线程的出现是要解决什么问题的?</h2><p>众所周知，CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：</p>
<ul>
<li>  CPU 增加了缓存，以均衡与内存的速度差异；（导致 <code>可见性</code> 问题）</li>
<li>  操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；（导致 <code>原子性</code> 问题）</li>
<li>  编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。（导致 <code>有序性</code> 问题）</li>
</ul>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="W-线程状态"><a href="#W-线程状态" class="headerlink" title="W 线程状态"></a><code>W</code> 线程状态</h2><ol>
<li><code>NEW 新建</code>：线程刚被创建，但是并未启动。</li>
<li><code>Runnable 就绪</code>：线程对象创建后，当调用线程对象的 start() 方法，该线程处于就绪状态，等待被线程调度选中，获取 CPU 的使用权（线程要想进入运行状态执行，首先必须处于就绪状态中）</li>
<li><code>Running 运行</code>：可运行状态 runnable 的线程获得了 CPU 时间片 timeslice，执行程序代码；</li>
<li><code>Blocked 锁阻塞</code>：处于运行状态中的线程由于某种原因，暂时放弃对 CPU 的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被 CPU 调用以进入到运行状态；<ol>
<li>等待阻塞：运行状态中的线程执行 wait() 方法，JVM 会把该线程放入等待队列 waitting queue 中，使本线程进入到等待阻塞状态；</li>
<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，，则 JVM 会把该线程放入锁池 lock pool 中，线程会进入同步阻塞状态；</li>
<li>其他阻塞：通过调用线程的 sleep() 或 join() 或发出了 I/O 请求时，线程会进入到阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。</li>
</ol>
</li>
<li>等待<ol>
<li><code>Waiting 无限等待</code>：一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用 <code>notify()</code> 或者 <code>notifyAll()</code> 方法才能够唤醒。</li>
<li><code>Timed Waiting 计时等待</code>：同 waiting 状态，有几个方法有超时参数，调用他们将进入 Timed Waiting 状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 <code>Thread.sleep()</code>、<code>Object.wait()</code>。</li>
</ol>
</li>
<li><code>Dead 死亡</code>：因为 <code>run()</code> 方法正常退出而死亡，或者因为没有捕获的异常终止了 <code>run()</code> 方法而死亡，死亡的线程不可再次复生。</li>
</ol>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><ul>
<li>  为所有非守护线程提供服务的线程，任何守护线程都是整个 JVM 的非守护线程的保姆；</li>
<li>例子：GC 垃圾回收线程；<ul>
<li>  为其他线程提供服务支持；</li>
</ul>
</li>
<li>  thread.setDaemon(true) 必须在线程执行前设置，否则会抛出 IllegalThreadException 异常，不能将正在运行的常规线程设置为守护线程；</li>
<li>  守护线程不能去访问固有资源，比如写操作或者计算逻辑，因为随时有可能退出；</li>
<li>  Java 自带的多线程框架，比如 ExecutorService，会将守护线程转换为用户线程，所以使用守护线程就不能使用 Java 的线程池；</li>
</ul>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul>
<li>指的是内存安全，堆是共享内存，可以被所有线程访问<ul>
<li>  当多个线程访问一个对象时，如果不进行额外的同步控制或者其他的协调操作，调用这个对象的行为都可以得到预期的结果或单线程执行的结果，那么就说这个对象是线程安全的；</li>
</ul>
</li>
<li>堆是进程和线程的共有空间，全局堆（未分配空间）和局部堆（用户分配空间）；堆在操作系统对进程初始化时分配，运行过程中也可以向系统要额外的堆，但用完了还，否则会内存泄漏；<ul>
<li>  堆是 Java 虚拟机管理的最大的一块内存，堆存在的目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存；</li>
</ul>
</li>
<li>  栈是每个线程独有的，保存运行状态以及局部自动变量，栈在线程开始时初始化，每个线程的栈互相独立，因此栈是线程安全的，操作系统在切换线程时会自动切换栈，栈空间不需要在高级语言中显式的分配与释放；</li>
</ul>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ul>
<li>  创建：新建了一个线程对象；</li>
<li>  就绪：线程创建完成后，其他线程调用该对象的 start 方法，该线程位于可运行线程池中，变得可运行，等待 CPU 的使用权；</li>
<li>  运行：就绪状态的线程获取了 CPU，执行程序代码；</li>
<li>阻塞：线程因为某种原因放弃 CPU 使用权，暂时终止运行，直到线程进入就绪状态，才有机会转为运行状态；<ul>
<li>  等待阻塞：运行线程的 Object.wait() 方法，释放占用资源，JVM 会把该线程放入等待池中，不能被自动唤醒，依赖其他线程的 notify() 或 notifyAll() 才能唤醒；</li>
<li>  同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，JVM 会把该线程放入锁池中；</li>
<li>  其它阻塞：运行线程执行 Thread.sleep() 或 join() 方法或发出 I/O 请求时，JVM 会把该线程设置为阻塞状态，当 sleep 超时、join 等待线程终止或超时、I/O 处理完成时线程进入就绪状态。</li>
</ul>
</li>
<li>  死亡：线程执行完成或因异常退出，结束线程生命周期；</li>
</ul>
<h2 id="线程的调度策略"><a href="#线程的调度策略" class="headerlink" title="线程的调度策略"></a>线程的调度策略</h2><p><strong>线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行：</strong></p>
<ol>
<li>  线程体中调用了 <code>yield()</code> 方法让出了对 CPU 的占用权利</li>
<li>  线程体中调用了 <code>sleep()</code> 方法使线程进入睡眠状态</li>
<li>  线程由于 IO 操作受到阻塞</li>
<li>  另外一个更高优先级线程出现</li>
<li>  在支持时间片的系统中，该线程的时间片用完</li>
</ol>
<h2 id="线程的几种实现方法"><a href="#线程的几种实现方法" class="headerlink" title="线程的几种实现方法"></a>线程的几种实现方法</h2><ul>
<li>  继承 Thread 类，重写 <code>run()</code> 函数；</li>
<li>  实现 Runnable 接口，重写 <code>run()</code> 函数；</li>
<li>  实现 Callable 接口，重写 <code>call()</code> 函数（可通过调用 <code>FutureTast.get()</code> 获取线程结果）；</li>
</ul>
<p>都是调用 <code>start()</code> 方法启动线程。</p>
<h2 id="线程优先级的理解"><a href="#线程优先级的理解" class="headerlink" title="线程优先级的理解"></a>线程优先级的理解</h2><ul>
<li>  每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int 变量(从1-10)，1 代表最低优先级，10 代表最高优先级。</li>
<li>  Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</li>
</ul>
<h2 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h2><p>在java中有以下3种方法可以终止正在运行的线程：</p>
<p><strong>1、</strong> 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</p>
<p><strong>2、</strong> 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。</p>
<p><strong>3、</strong> 使用interrupt方法中断线程。</p>
<h2 id="唤醒阻塞线程"><a href="#唤醒阻塞线程" class="headerlink" title="唤醒阻塞线程"></a>唤醒阻塞线程</h2><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p>
<ul>
<li>代码示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lijie;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span> &lt; &gt; (<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="type">TaskThred</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskThred</span>(<span class="string">&quot;任务&quot;</span> + i);</span><br><span class="line">            <span class="comment">//executor.execute(t1);是执行线程方法</span></span><br><span class="line">            executor.execute(t1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//executor.shutdown()不再接受新的任务，并且等待之前提交的任务都执行完再关闭，阻塞队列中的任务不会再执行。</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskThred</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String taskName;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TaskThred</span><span class="params">(String taskName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskName = taskName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + taskName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程运行时发生异常"><a href="#线程运行时发生异常" class="headerlink" title="线程运行时发生异常"></a>线程运行时发生异常</h2><p>如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM 会使用 Thread.getUncaughtExceptionHandler()来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException()方法进行处理。</p>
<h2 id="线程调度算法"><a href="#线程调度算法" class="headerlink" title="线程调度算法"></a>线程调度算法</h2><p>计算机通常只有一个 CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU 的使用权才能执行指令。所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待 CPU，JAVA 虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配 CPU 的使用权。（Java是由JVM中的线程计数器来实现线程调度）</p>
<p><strong>有两种调度模型：</strong></p>
<p>分时调度模型和抢占式调度模型。</p>
<ol>
<li>分时调度模型是指让所有的线程轮流获得 cpu 的使用权，并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。</li>
<li>Java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU</li>
</ol>
<h2 id="线程异步-线程同步"><a href="#线程异步-线程同步" class="headerlink" title="线程异步 线程同步"></a>线程异步 线程同步</h2><ul>
<li>线程同步：同时只有一条线程执行一个任务</li>
<li>线程异步：同时有多条线程可以执行执行任务</li>
</ul>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="设计分布式锁需要注意哪些问题"><a href="#设计分布式锁需要注意哪些问题" class="headerlink" title="设计分布式锁需要注意哪些问题"></a>设计分布式锁需要注意哪些问题</h2><ul>
<li>  加锁解锁的原子性；</li>
<li>加锁过期时间防止死锁；<ul>
<li>  守护线程自动给锁续期；</li>
</ul>
</li>
<li>  注意避免锁被别的客户端释放；</li>
</ul>
<p>执行顺序</p>
<ul>
<li>  放进队列；</li>
<li>  使用 redis watch 事务加时间戳；</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁不仅仅是 Java 的问题，实际上是一个操作系统上的问题。指两个或以上的线程在执行过中，因为抢夺资源而造成的一种互相等待现象，若无外力作用，它们都无法继续执行下去。死锁形成需要满足以下条件：</p>
<ul>
<li>  互斥：一个资源每次只能被一个进程使用；</li>
<li>  请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放；</li>
<li>  不剥夺：进程已获得的资源，在未使用完之前，不能强行剥夺；</li>
<li>  循环等待：若干进程之间形成一种头尾相接的循环等待资源的关系；</li>
</ul>
<h2 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h2><ul>
<li>  死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</li>
<li>  多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</li>
</ul>
<h2 id="Java死锁以及如何避免？"><a href="#Java死锁以及如何避免？" class="headerlink" title="Java死锁以及如何避免？"></a>Java死锁以及如何避免？</h2><p>Java 中的死锁是一种编程情况，其中两个或多个线程被永久阻塞，Java 死锁情况出现至少两个线程和两个或更多资源。</p>
<p>Java 发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。</p>
<h2 id="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h2><p><strong>悲观锁：</strong></p>
<p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</p>
<p><strong>乐观锁：</strong></p>
<p>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="volatile-能使得一个非原子操作变成原子操作吗？"><a href="#volatile-能使得一个非原子操作变成原子操作吗？" class="headerlink" title="volatile 能使得一个非原子操作变成原子操作吗？"></a>volatile 能使得一个非原子操作变成原子操作吗？</h2><p><strong>1、</strong> 关键字volatile的主要作用是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同一个实例变量需要加锁进行同步。</p>
<p><strong>2、</strong> 虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double可以保证其操作原子性。</p>
<p><strong>所以从Oracle Java Spec里面可以看到：</strong></p>
<p><strong>1、</strong> 对于64位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时候，可以分成两步，每次对32位操作。</p>
<p><strong>2、</strong> 如果使用volatile修饰long和double，那么其读写都是原子操作</p>
<p><strong>3、</strong> 对于64位的引用地址的读写，都是原子操作</p>
<p><strong>4、</strong> 在实现JVM时，可以自由选择是否把读写long和double作为原子操作</p>
<p><strong>5、</strong> 推荐JVM实现为原子操作</p>
<h2 id="volatile-修饰符的有过什么实践？"><a href="#volatile-修饰符的有过什么实践？" class="headerlink" title="volatile 修饰符的有过什么实践？"></a>volatile 修饰符的有过什么实践？</h2><p>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。</p>
<h2 id="volatile-关键字的作用"><a href="#volatile-关键字的作用" class="headerlink" title="volatile 关键字的作用"></a>volatile 关键字的作用</h2><ol>
<li>对于可见性，Java 提供了 volatile 关键字来保证可见性和禁止指令重排。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile修饰时，它会保证修改的值会立即被更新到主内存中，当有其他线程需要读取时，它会去内存中读取新值。</li>
<li>从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。</li>
<li>volatile 常用于多线程环境下的单次操作(单次读或者单次写)。</li>
</ol>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/qDvd8MYAzBXOsWgzwIbNMA">线程安全(上)–彻底搞懂synchronized(从偏向锁到重量级锁) (qq.com)</a></p>
<h2 id="synchronized-修饰方法和同步代码块有什么区别"><a href="#synchronized-修饰方法和同步代码块有什么区别" class="headerlink" title="synchronized 修饰方法和同步代码块有什么区别"></a>synchronized 修饰方法和同步代码块有什么区别</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/askcto/article/details/105473452">Synchronized修饰方法和同步代码块的区别_askcto的博客-CSDN博客</a></p>
<p>Synchronized 修饰实例方法或静态方法都是通过标识 ACC_SYNCHRONIZED 实现同步。</p>
<p>同步代码块是是采用 monitorenter、monitorexit 两个指令来实现同步。</p>
<h2 id="简述-synchronized-和-Lock-的异同"><a href="#简述-synchronized-和-Lock-的异同" class="headerlink" title="简述 synchronized 和 Lock 的异同"></a>简述 synchronized 和 Lock 的异同</h2><p>java.util.concurrent.locks.Lock 是 JDK5 以后引入的新的 API。</p>
<p>和关键字 synchronized 相比</p>
<p>主要相同点：Lock 能完成 synchronized 所实现的所有功能；</p>
<p>主要不同点：Lock 有比 synchronized 更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且最好在 finally 块中释放（这是释放外部资源的最好的地方）。</p>
<h2 id="当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？"><a href="#当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？" class="headerlink" title="当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？"></a>当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？</h2><p>如果其他方法没有synchronized的话，其他线程是可以进入的。</p>
<p>所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。</p>
<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><h2 id="什么是可重入锁-ReentrantLock"><a href="#什么是可重入锁-ReentrantLock" class="headerlink" title="什么是可重入锁 ReentrantLock"></a>什么是可重入锁 ReentrantLock</h2><p>举例来说明锁的可重入性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnReentrant</span>&#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        inner();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inner</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outer 中调用了 inner，outer 先锁住了 lock，这样 inner 就不能再获取 lock。其实调用 outer 的线程已经获取了 lock 锁，但是不能在 inner 中重复利用已经获取的锁资源，这种锁即称之为不可重入可重入就意味着：线程可以进入任何一个它已经拥有的锁所同步着的代码块。</p>
<p>Synchronized、ReentrantLock 都是可重入的锁，可重入锁相对来说简化了并发编程的开发</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="ThreadLocal-内存泄漏的原因，怎么避免与四种引用"><a href="#ThreadLocal-内存泄漏的原因，怎么避免与四种引用" class="headerlink" title="ThreadLocal 内存泄漏的原因，怎么避免与四种引用"></a>ThreadLocal 内存泄漏的原因，怎么避免与四种引用</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xlgen157387/article/details/78298840">Java多线程编程-（9）-ThreadLocal造成OOM内存溢出案例演示与原理分析_徐刘根的博客-CSDN博客_threadlocal内存溢出</a></p>
<p>内存泄漏就是不再使用的对象或变量占用的内存不能被回收。</p>
<p>由于 ThreadLocalMap 的生命周期与 Thread 一样长，如果没有手动删除 key 就会导致内存泄漏。因此每次使用完 ThreadLocal 都要调用它的 remove() 方法清除数据或将 ThreadLocal 变量定义为 private static，这样就一直存在 ThreadLocal 的强引用，也就能保证任何时候都能通过 ThreadLocal 的弱引用访问到 Entry 的 value，进而清除掉；</p>
<ul>
<li>  强引用：使用最普遍的引用 new，一个对象具有强引用，不会被回收，当内存不足，Java 虚拟机宁愿抛出 OutOfMemoryError 使程序终止也不会回收这种对象；</li>
<li>  软引用 SoftReference：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；</li>
<li>  弱引用 WeakReference：JVM 垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象，可以在缓存中使用弱引用；</li>
<li>  虚引用 PhantomReference：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。</li>
</ul>
<h2 id="ThreadLocal-的原理和使用场景"><a href="#ThreadLocal-的原理和使用场景" class="headerlink" title="ThreadLocal 的原理和使用场景"></a>ThreadLocal 的原理和使用场景</h2><ul>
<li>  每个 Thread 对象中均含有一个由 Entry 对象构成的 ThreadLocalMap 类型的成员变量，它时 Thread 的内部类，存储本线程中所有 ThreadLocal 对象机器对应对的值；</li>
<li>  Entry 继承自 <code>WeakRederence&lt;ThreadLocal&lt;?&gt;&gt;</code>  一个 Entry 的 key 是 ThreadLocal 对象，值为 Object，且是弱引用，当没指向 key 的强引用后，该 key 就会被垃圾回收器回收；</li>
<li>  执行 set/get 方法时，ThreadLocal 会先获取当前线程对象，然后获取当前线程的 ThreadLocalMap 对象，再以当前 ThreadLocal 对象为 key，将值存储进 ThreadLocalMap 中或取出；</li>
<li>  由于每个线程都有私有的 ThreadLocalMap，因此不存在线程安全性问题，从而无需使用同步机制来保证多条线程访问容器的互斥性；</li>
</ul>
<p>使用场景：</p>
<ul>
<li>  进行对象跨层传递的时候，使用 ThreadLocal 可以避免多次传输，打破层次间的约束；</li>
<li>  线程间数据隔离；</li>
<li>  事务操作，存储线程事务信息；</li>
<li>数据库连接，Session 会话信息；<ul>
<li>  Spring 会在事务开始时给当前线程绑定 Jdbc Connection，在整个事务过程中都是使用该线程绑定的 connection 来执行数据库操作，实现了事务的隔离性；</li>
</ul>
</li>
</ul>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="Java-中你怎样唤醒一个阻塞的线程？"><a href="#Java-中你怎样唤醒一个阻塞的线程？" class="headerlink" title="Java 中你怎样唤醒一个阻塞的线程？"></a>Java 中你怎样唤醒一个阻塞的线程？</h2><p>首先 ，wait()、notify() 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行；</p>
<p>其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</p>
<h2 id="sleep-wait-join-yield"><a href="#sleep-wait-join-yield" class="headerlink" title="sleep() wait() join() yield()"></a>sleep() wait() join() yield()</h2><ul>
<li>  锁池：所有需要竞争同步锁的线程都会放在锁池当中，当某个线程获得资源后就会进入就绪队列等待 CPU 资源分配；</li>
<li>等待池：当我们调用 wait() 方法后，线程会放到等待池中，线程不会竞争同步锁，只有调用 notify() 或 notifyAll() 后等待池的线程才会开始竞争锁。<ul>
<li>  notify()：随机从等待池选一个线程到锁池；</li>
<li>  notifyAll()：将等待池所有线程放到锁池；</li>
</ul>
</li>
</ul>
<ol>
<li> sleep() 是 Thread 的静态方法，wait() 是 Object 的方法；</li>
<li>sleep() 不会释放锁，wait() 会释放锁，并进入等待队列；<ul>
<li>  sleep() 释放执行资格却不会释放锁，而是将锁带着休眠；</li>
</ul>
</li>
<li> sleep() 不依赖 synchronized，wait() 依赖；</li>
<li> sleep() 不需要被唤醒（休眠之后自动退出），但是 wait() 需要；</li>
<li> sleep() 一般用于当前线程休眠，wait() 一般用于多线程之间通信；</li>
<li> sleep() 会让出 CPU 执行时间强制上下文切换，而 wait() 不一定，wait() 后还是有可能重新竞争到锁继续执行；</li>
<li> yield() 执行后线程直接进入就绪状态，马上释放 CPU 的执行权，但依然保留 CPU 的执行资格，所以有可能 CPU 下次进行线程调度还会让这个线程获取到执行权继续执行；</li>
<li> join() 执行后线程进入阻塞状态，例如在线程 B 中调用 线程 A 的 join()，那么线程 B 阻塞，直到线程 A 结束或中断；</li>
</ol>
<h2 id="为什么wait和notify方法要在同步块中调用？"><a href="#为什么wait和notify方法要在同步块中调用？" class="headerlink" title="为什么wait和notify方法要在同步块中调用？"></a>为什么wait和notify方法要在同步块中调用？</h2><p>Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p>
<h2 id="Thread-类中的-yield-方法有什么作用？"><a href="#Thread-类中的-yield-方法有什么作用？" class="headerlink" title="Thread 类中的 yield 方法有什么作用？"></a>Thread 类中的 yield 方法有什么作用？</h2><p>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。</p>
<p>当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。</p>
<h2 id="为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"><a href="#为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？" class="headerlink" title="为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？"></a>为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</h2><p>因为Java所有类的都继承了Object，Java想让任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。</p>
<p>有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。</p>
<h2 id="线程的-sleep-方法和-yield-方法有什么区别？"><a href="#线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="线程的 sleep() 方法和 yield() 方法有什么区别？"></a>线程的 sleep() 方法和 yield() 方法有什么区别？</h2><ol>
<li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</li>
<li>线程执行 sleep() 方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；</li>
<li>sleep() 方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；</li>
<li>sleep() 方法比 yield() 方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。</li>
</ol>
<h2 id="为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</h2><p>当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p>
<h2 id="你是如何调用-wait-方法的？使用-if-块还是循环？为什么？"><a href="#你是如何调用-wait-方法的？使用-if-块还是循环？为什么？" class="headerlink" title="你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？"></a>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</h2><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p>
<p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">    <span class="comment">//  判断条件谓词是否得到满足</span></span><br><span class="line">    <span class="keyword">while</span>(!locked) &#123;</span><br><span class="line">    <span class="comment">//  等待唤醒</span></span><br><span class="line">    monitor.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  处理其他的业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么线程通信的方法wait-notify-和notifyAll-被定义在Object-类里？"><a href="#为什么线程通信的方法wait-notify-和notifyAll-被定义在Object-类里？" class="headerlink" title="为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object 类里？"></a>为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object 类里？</h2><p>Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。</p>
<h2 id="Java-中-sleep-方法和-wait-方法的区别？"><a href="#Java-中-sleep-方法和-wait-方法的区别？" class="headerlink" title="Java 中 sleep 方法和 wait 方法的区别？"></a>Java 中 sleep 方法和 wait 方法的区别？</h2><p>虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。</p>
<h2 id="请描述-Thread-类中的-start-与-run-的区别。"><a href="#请描述-Thread-类中的-start-与-run-的区别。" class="headerlink" title="请描述 Thread 类中的 start() 与 run() 的区别。"></a>请描述 Thread 类中的 start() 与 run() 的区别。</h2><p>线程对象调用 run() 方法不开启线程，仅是对象调用方法。线程对象调用 start() 方法开启线程，并让 JVM 调用 run() 方法在开启的线程中执行。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="同步方法和同步块，哪个是更好的选择？"><a href="#同步方法和同步块，哪个是更好的选择？" class="headerlink" title="同步方法和同步块，哪个是更好的选择？"></a>同步方法和同步块，哪个是更好的选择？</h2><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p>
<p>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p>
<p><code>请知道一条原则：同步的范围越小越好。</code></p>
<h2 id="synchronized、volatile、CAS-比较"><a href="#synchronized、volatile、CAS-比较" class="headerlink" title="synchronized、volatile、CAS 比较"></a>synchronized、volatile、CAS 比较</h2><p><strong>1、</strong> synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。</p>
<p><strong>2、</strong> volatile 提供多线程共享变量可见性和禁止指令重排序优化。</p>
<p><strong>3、</strong> CAS 是基于冲突检测的乐观锁（非阻塞）</p>
<h2 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h2><ol>
<li>首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；</li>
<li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li>
<li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>
</ol>
<h2 id="什么是线程组，为什么在Java中不推荐使用？"><a href="#什么是线程组，为什么在Java中不推荐使用？" class="headerlink" title="什么是线程组，为什么在Java中不推荐使用？"></a>什么是线程组，为什么在Java中不推荐使用？</h2><p>ThreadGroup类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</p>
<p>为什么不推荐使用？因为使用有很多的安全隐患吧，没有具体追究，如果需要使用，推荐使用线程池。</p>
<h2 id="同步方法和同步块，哪个是更好的选择？-1"><a href="#同步方法和同步块，哪个是更好的选择？-1" class="headerlink" title="同步方法和同步块，哪个是更好的选择？"></a>同步方法和同步块，哪个是更好的选择？</h2><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p>
<p>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p>
<h2 id="多线程的最佳实践"><a href="#多线程的最佳实践" class="headerlink" title="多线程的最佳实践"></a>多线程的最佳实践</h2><p>这是我在写 Java 并发程序的时候遵循的一些最佳实践：</p>
<ul>
<li>  给线程命名，这样可以帮助调试。</li>
<li>  最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。</li>
<li>  如果可以，更偏向于使用 volatile 而不是 synchronized。</li>
<li>  使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semeaphore。</li>
<li>  优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。</li>
</ul>
<h2 id="在-Java-程序中怎么保证多线程的运行安全？"><a href="#在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="在 Java 程序中怎么保证多线程的运行安全？"></a>在 Java 程序中怎么保证多线程的运行安全？</h2><p>出现线程安全问题的原因一般都是三个原因：</p>
<ol>
<li>线程切换带来的原子性问题 解决办法：使用多线程之间同步synchronized或使用锁(lock)。</li>
<li>缓存导致的可见性问题 解决办法：synchronized、volatile、LOCK，可以解决可见性问题</li>
<li>编译优化带来的有序性问题 解决办法：Happens-Before 规则可以解决有序性问题</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="W-Java-中怎么获取一份线程-dump-文件"><a href="#W-Java-中怎么获取一份线程-dump-文件" class="headerlink" title="W Java 中怎么获取一份线程 dump 文件"></a><code>W</code> Java 中怎么获取一份线程 dump 文件</h2><p>在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java 应用的 dump 文件。在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。如果你使用Tomcat。</p>
<h2 id="W-线程的基本状态以及状态之间的关系？"><a href="#W-线程的基本状态以及状态之间的关系？" class="headerlink" title="W 线程的基本状态以及状态之间的关系？"></a><code>W</code> 线程的基本状态以及状态之间的关系？</h2><p><img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2019/08/0816/03/img_2.png#alt=img%5C_2.png"></p>
<h2 id="Java-中-Semaphore-是什么？"><a href="#Java-中-Semaphore-是什么？" class="headerlink" title="Java 中 Semaphore 是什么？"></a>Java 中 Semaphore 是什么？</h2><p>Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。</p>
<h2 id="什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><a href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？" class="headerlink" title="什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？"></a>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</h2><p>线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="怎么唤醒一个阻塞的线程"><a href="#怎么唤醒一个阻塞的线程" class="headerlink" title="怎么唤醒一个阻塞的线程"></a>怎么唤醒一个阻塞的线程</h2><p>如果线程是因为调用了 wait()、sleep() 或者 join() 方法而导致的阻塞，可以中断线程，并且通过抛出 InterruptedException 来唤醒它；如果线程遇到了 IO 阻塞，无能为力，因为 IO 是操作系统实现的，Java 代码并没有办法直接接触到操作系统。</p>
<figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span> &lt; &gt; (<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="type">TaskThred</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskThred</span>(<span class="string">&quot;任务&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 是执行线程方法</span></span><br><span class="line">            executor.execute(t1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不再接受新的任务，并且等待之前提交的任务都执行完再关闭，阻塞队列中的任务不会再执行。</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskThred</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String taskName;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TaskThred</span><span class="params">(String taskName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskName = taskName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + taskName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写一段简单的死锁代码"><a href="#写一段简单的死锁代码" class="headerlink" title="写一段简单的死锁代码"></a>写一段简单的死锁代码</h2><p>这个笔试的话频率也挺高（遇见笔试的公司要三思啊），所以这里直接给出一个答案（有很多版本的）。</p>
<figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (object2) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;deadlock-demo-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object2) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object1) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;deadlock-demo-2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单的同步方法示例"><a href="#简单的同步方法示例" class="headerlink" title="简单的同步方法示例"></a>简单的同步方法示例</h2><p>下面的例子演示了 100 个线程同时向一个银行账户中存入 1 元钱，在没有使用同步机制和使用同步机制情况下的执行情况：</p>
<h3 id="无同步控制"><a href="#无同步控制" class="headerlink" title="无同步控制"></a>无同步控制</h3><p><strong>银行账户类：</strong></p>
<figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 银行账户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 账户余额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 存款</span></span><br><span class="line"><span class="comment">     * @param money 存入金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newBalance</span> <span class="operator">=</span> balance + money;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟此业务需要一段处理时间</span></span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获得账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>存钱线程类：</strong></p>
<figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 存钱线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddMoneyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存入账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">// 存入金额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddMoneyThread</span><span class="params">(Account account, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        account.deposit(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类：</strong></p>
<figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            service.execute(<span class="keyword">new</span> <span class="title class_">AddMoneyThread</span>(account, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!service.isTerminated()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;账户余额: &quot;</span> + account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在没有同步的情况下，执行结果通常是显示账户余额在 10 元以下，出现这种状况的原因是，当一个线程 A 试图存入 1 元的时候，另外一个线程 B 也能够进入存款的方法中，线程 B 读取到的账户余额仍然是线程 A 存入 1 元钱之前的账户余额，因此也是在原来的余额 0 上面做了加 1 元的操作，同理线程 C 也会做类似的事情，所以最后 100 个线程执行结束时，本来期望账户余额为 100 元，但实际得到的通常在 10 元以下（很可能是 1 元哦）。解决这个问题的办法就是同步，当一个线程对银行账户存钱时，需要将此账户锁定，待其操作完成后才允许其他的线程进行操作，代码有如下几种调整方案：</p>
<h3 id="synchronized-方法级"><a href="#synchronized-方法级" class="headerlink" title="synchronized 方法级"></a>synchronized 方法级</h3><p><strong>在银行账户的存款（deposit）方法上同步（synchronized）关键字</strong></p>
<figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 银行账户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 账户余额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 存款</span></span><br><span class="line"><span class="comment">     * @param money 存入金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">newBalance</span> <span class="operator">=</span> balance + money;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟此业务需要一段处理时间</span></span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获得账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized-字段级"><a href="#synchronized-字段级" class="headerlink" title="synchronized 字段级"></a>synchronized 字段级</h3><p><strong>在线程调用存款方法时对银行账户进行同步</strong></p>
<figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line"> * 存钱线程</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddMoneyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存入账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">// 存入金额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddMoneyThread</span><span class="params">(Account account, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            account.deposit(money); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReentrantLock-锁对象"><a href="#ReentrantLock-锁对象" class="headerlink" title="ReentrantLock 锁对象"></a>ReentrantLock 锁对象</h3><p><strong>通过 JDK5 显示的锁机制，为每个银行账户创建一个锁对象，在存款操作进行加锁和解锁的操作</strong></p>
<figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 银行账户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">accountLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 账户余额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 存款</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param money 存入金额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        accountLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">newBalance</span> <span class="operator">=</span> balance + money;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟此业务需要一段处理时间</span></span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            balance = newBalance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            accountLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获得账户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照上述三种方式对代码进行修改后，重写执行测试代码 Test01，将看到最终的账户余额为 100 元。当然也可以使用 Semaphore 或 CountdownLatch 来实现同步。</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="你如何理解-fiber"><a href="#你如何理解-fiber" class="headerlink" title="你如何理解 fiber"></a>你如何理解 fiber</h2><p>React Fiber 是一种基于浏览器的<strong>单线程调度算法</strong>.</p>
<p>React 16 之前 ，<code>reconcilation</code> 算法实际上是递归，想要中断递归是很困难的，React 16 开始使用了循环来代替之前的递归.</p>
<p><code>Fiber</code>：<strong>一种将 <code>recocilation</code> （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。</strong></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>线程</p><p><a href="https://blog.hr947x.com/67a1548e8c24/">https://blog.hr947x.com/67a1548e8c24/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>小徐</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-02-15</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-03-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="link-muted mr-2" rel="tag" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/548314b5b0e6/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">JVM</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/3a9b80b3a95d/"><span class="level-item">待归档</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#基础"><span class="level-left"><span class="level-item">1</span><span class="level-item">基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#并发的三大特性"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">并发的三大特性</span></span></a></li><li><a class="level is-mobile" href="#并发-并行-串行"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">并发 并行 串行</span></span></a></li><li><a class="level is-mobile" href="#Threrad-Runable-的区别"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Threrad Runable 的区别</span></span></a></li><li><a class="level is-mobile" href="#两个线程间共享数据"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">两个线程间共享数据</span></span></a></li><li><a class="level is-mobile" href="#什么是自旋"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">什么是自旋</span></span></a></li><li><a class="level is-mobile" href="#什么是上下文切换"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">什么是上下文切换</span></span></a></li><li><a class="level is-mobile" href="#常用的并发工具类有哪些"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">常用的并发工具类有哪些</span></span></a></li><li><a class="level is-mobile" href="#线程和进程区别"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">线程和进程区别</span></span></a></li><li><a class="level is-mobile" href="#进程概念、线程概念、线程与进程联系"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">进程概念、线程概念、线程与进程联系</span></span></a></li><li><a class="level is-mobile" href="#多线程的出现是要解决什么问题的"><span class="level-left"><span class="level-item">1.10</span><span class="level-item">多线程的出现是要解决什么问题的?</span></span></a></li></ul></li><li><a class="level is-mobile" href="#线程"><span class="level-left"><span class="level-item">2</span><span class="level-item">线程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#W-线程状态"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">W 线程状态</span></span></a></li><li><a class="level is-mobile" href="#守护线程"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">守护线程</span></span></a></li><li><a class="level is-mobile" href="#线程安全"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">线程安全</span></span></a></li><li><a class="level is-mobile" href="#线程的生命周期"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">线程的生命周期</span></span></a></li><li><a class="level is-mobile" href="#线程的调度策略"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">线程的调度策略</span></span></a></li><li><a class="level is-mobile" href="#线程的几种实现方法"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">线程的几种实现方法</span></span></a></li><li><a class="level is-mobile" href="#线程优先级的理解"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">线程优先级的理解</span></span></a></li><li><a class="level is-mobile" href="#如何停止一个正在运行的线程？"><span class="level-left"><span class="level-item">2.8</span><span class="level-item">如何停止一个正在运行的线程？</span></span></a></li><li><a class="level is-mobile" href="#唤醒阻塞线程"><span class="level-left"><span class="level-item">2.9</span><span class="level-item">唤醒阻塞线程</span></span></a></li><li><a class="level is-mobile" href="#线程运行时发生异常"><span class="level-left"><span class="level-item">2.10</span><span class="level-item">线程运行时发生异常</span></span></a></li><li><a class="level is-mobile" href="#线程调度算法"><span class="level-left"><span class="level-item">2.11</span><span class="level-item">线程调度算法</span></span></a></li><li><a class="level is-mobile" href="#线程异步-线程同步"><span class="level-left"><span class="level-item">2.12</span><span class="level-item">线程异步 线程同步</span></span></a></li></ul></li><li><a class="level is-mobile" href="#锁"><span class="level-left"><span class="level-item">3</span><span class="level-item">锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#设计分布式锁需要注意哪些问题"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">设计分布式锁需要注意哪些问题</span></span></a></li><li><a class="level is-mobile" href="#死锁"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">死锁</span></span></a></li><li><a class="level is-mobile" href="#什么是线程死锁"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">什么是线程死锁</span></span></a></li><li><a class="level is-mobile" href="#Java死锁以及如何避免？"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">Java死锁以及如何避免？</span></span></a></li><li><a class="level is-mobile" href="#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#volatile"><span class="level-left"><span class="level-item">4</span><span class="level-item">volatile</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#volatile-能使得一个非原子操作变成原子操作吗？"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">volatile 能使得一个非原子操作变成原子操作吗？</span></span></a></li><li><a class="level is-mobile" href="#volatile-修饰符的有过什么实践？"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">volatile 修饰符的有过什么实践？</span></span></a></li><li><a class="level is-mobile" href="#volatile-关键字的作用"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">volatile 关键字的作用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#synchronized"><span class="level-left"><span class="level-item">5</span><span class="level-item">synchronized</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#synchronized-修饰方法和同步代码块有什么区别"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">synchronized 修饰方法和同步代码块有什么区别</span></span></a></li><li><a class="level is-mobile" href="#简述-synchronized-和-Lock-的异同"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">简述 synchronized 和 Lock 的异同</span></span></a></li><li><a class="level is-mobile" href="#当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#ReentrantLock"><span class="level-left"><span class="level-item">6</span><span class="level-item">ReentrantLock</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是可重入锁-ReentrantLock"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">什么是可重入锁 ReentrantLock</span></span></a></li></ul></li><li><a class="level is-mobile" href="#ThreadLocal"><span class="level-left"><span class="level-item">7</span><span class="level-item">ThreadLocal</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ThreadLocal-内存泄漏的原因，怎么避免与四种引用"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">ThreadLocal 内存泄漏的原因，怎么避免与四种引用</span></span></a></li><li><a class="level is-mobile" href="#ThreadLocal-的原理和使用场景"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">ThreadLocal 的原理和使用场景</span></span></a></li></ul></li><li><a class="level is-mobile" href="#方法"><span class="level-left"><span class="level-item">8</span><span class="level-item">方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Java-中你怎样唤醒一个阻塞的线程？"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">Java 中你怎样唤醒一个阻塞的线程？</span></span></a></li><li><a class="level is-mobile" href="#sleep-wait-join-yield"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">sleep() wait() join() yield()</span></span></a></li><li><a class="level is-mobile" href="#为什么wait和notify方法要在同步块中调用？"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">为什么wait和notify方法要在同步块中调用？</span></span></a></li><li><a class="level is-mobile" href="#Thread-类中的-yield-方法有什么作用？"><span class="level-left"><span class="level-item">8.4</span><span class="level-item">Thread 类中的 yield 方法有什么作用？</span></span></a></li><li><a class="level is-mobile" href="#为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"><span class="level-left"><span class="level-item">8.5</span><span class="level-item">为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</span></span></a></li><li><a class="level is-mobile" href="#线程的-sleep-方法和-yield-方法有什么区别？"><span class="level-left"><span class="level-item">8.6</span><span class="level-item">线程的 sleep() 方法和 yield() 方法有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><span class="level-left"><span class="level-item">8.7</span><span class="level-item">为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</span></span></a></li><li><a class="level is-mobile" href="#你是如何调用-wait-方法的？使用-if-块还是循环？为什么？"><span class="level-left"><span class="level-item">8.8</span><span class="level-item">你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</span></span></a></li><li><a class="level is-mobile" href="#为什么线程通信的方法wait-notify-和notifyAll-被定义在Object-类里？"><span class="level-left"><span class="level-item">8.9</span><span class="level-item">为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object 类里？</span></span></a></li><li><a class="level is-mobile" href="#Java-中-sleep-方法和-wait-方法的区别？"><span class="level-left"><span class="level-item">8.10</span><span class="level-item">Java 中 sleep 方法和 wait 方法的区别？</span></span></a></li><li><a class="level is-mobile" href="#请描述-Thread-类中的-start-与-run-的区别。"><span class="level-left"><span class="level-item">8.11</span><span class="level-item">请描述 Thread 类中的 start() 与 run() 的区别。</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">9</span><span class="level-item">总结</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#同步方法和同步块，哪个是更好的选择？"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">同步方法和同步块，哪个是更好的选择？</span></span></a></li><li><a class="level is-mobile" href="#synchronized、volatile、CAS-比较"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">synchronized、volatile、CAS 比较</span></span></a></li><li><a class="level is-mobile" href="#synchronized-和-Lock-有什么区别？"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">synchronized 和 Lock 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#什么是线程组，为什么在Java中不推荐使用？"><span class="level-left"><span class="level-item">9.4</span><span class="level-item">什么是线程组，为什么在Java中不推荐使用？</span></span></a></li><li><a class="level is-mobile" href="#同步方法和同步块，哪个是更好的选择？-1"><span class="level-left"><span class="level-item">9.5</span><span class="level-item">同步方法和同步块，哪个是更好的选择？</span></span></a></li><li><a class="level is-mobile" href="#多线程的最佳实践"><span class="level-left"><span class="level-item">9.6</span><span class="level-item">多线程的最佳实践</span></span></a></li><li><a class="level is-mobile" href="#在-Java-程序中怎么保证多线程的运行安全？"><span class="level-left"><span class="level-item">9.7</span><span class="level-item">在 Java 程序中怎么保证多线程的运行安全？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#其他"><span class="level-left"><span class="level-item">10</span><span class="level-item">其他</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#W-Java-中怎么获取一份线程-dump-文件"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">W Java 中怎么获取一份线程 dump 文件</span></span></a></li><li><a class="level is-mobile" href="#W-线程的基本状态以及状态之间的关系？"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">W 线程的基本状态以及状态之间的关系？</span></span></a></li><li><a class="level is-mobile" href="#Java-中-Semaphore-是什么？"><span class="level-left"><span class="level-item">10.3</span><span class="level-item">Java 中 Semaphore 是什么？</span></span></a></li><li><a class="level is-mobile" href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><span class="level-left"><span class="level-item">10.4</span><span class="level-item">什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#代码"><span class="level-left"><span class="level-item">11</span><span class="level-item">代码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#怎么唤醒一个阻塞的线程"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">怎么唤醒一个阻塞的线程</span></span></a></li><li><a class="level is-mobile" href="#写一段简单的死锁代码"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">写一段简单的死锁代码</span></span></a></li><li><a class="level is-mobile" href="#简单的同步方法示例"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">简单的同步方法示例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#无同步控制"><span class="level-left"><span class="level-item">11.3.1</span><span class="level-item">无同步控制</span></span></a></li><li><a class="level is-mobile" href="#synchronized-方法级"><span class="level-left"><span class="level-item">11.3.2</span><span class="level-item">synchronized 方法级</span></span></a></li><li><a class="level is-mobile" href="#synchronized-字段级"><span class="level-left"><span class="level-item">11.3.3</span><span class="level-item">synchronized 字段级</span></span></a></li><li><a class="level is-mobile" href="#ReentrantLock-锁对象"><span class="level-left"><span class="level-item">11.3.4</span><span class="level-item">ReentrantLock 锁对象</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#拓展"><span class="level-left"><span class="level-item">12</span><span class="level-item">拓展</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#你如何理解-fiber"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">你如何理解 fiber</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-20T05:35:04.000Z">2022-04-20</time></p><p class="title"><a href="/4e2ca58138aa/">Linux sed 教程</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-07T13:14:08.000Z">2022-04-07</time></p><p class="title"><a href="/e7a6f47a5edd/">IDEA 快捷键</a></p><p class="categories"><a href="/categories/%E6%95%99%E7%A8%8B/">教程</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-20T08:38:54.000Z">2022-03-20</time></p><p class="title"><a href="/de4a65c796a3/">Java 基础</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a> / <a href="/categories/%E9%9D%A2%E8%AF%95/Java%E5%9F%BA%E7%A1%80/">Java基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-19T10:01:25.000Z">2022-03-19</time></p><p class="title"><a href="/906fcab3c166/">Java 新特性</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a> / <a href="/categories/%E9%9D%A2%E8%AF%95/Java%E5%9F%BA%E7%A1%80/">Java基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-19T05:27:25.000Z">2022-03-19</time></p><p class="title"><a href="/9d30f1f85362/">macOS 环境搭建</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">小徐&#039;s Blog</a><p class="is-size-7"><span>&copy; 2022 小徐</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="蜀ICP备20016181号-1" href="https://beian.miit.gov.cn/">蜀ICP备20016181号-1</a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>