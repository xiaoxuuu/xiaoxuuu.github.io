{"pages":[{"title":"我是谁","text":"Nobody…","link":"/about/index.html"}],"posts":[{"title":"ElasticSearch","text":"无用面试题 引用ElasticSearch 资料汇总 | Java 全栈知识体系 (pdai.tech) 整理Elasticsearch 读取数据使用 RestFul API 向对应的 node 发送查询请求，根据 did 来判断在哪个 shard 上，返回的是 primary 和 replica 的 node 节点集合 这样会负载均衡地把查询发送到对应节点，之后对应节点接收到请求，将 document 数据返回协调节点，协调节点把 document 返回给客户端 解释一下 X-Pack for Elasticsearch 的功能和重要性X-Pack 是与 Elasticsearch 一起安装的扩展程序。 X-Pack 的各种功能包括安全性（基于角色的访问，特权/权限，角色和用户安全性），监视，报告，警报等。 列出 Elasticsearch 各种类型的分析器Elasticsearch Analyzer 的类型为内置分析器和自定义分析器。 Standard Analyzer 标准分析器是默认分词器，如果未指定，则使用该分词器。 它基于 Unicode 文本分割算法，适用于大多数语言。 Whitespace Analyzer 基于空格字符切词。 Stop Analyzer 在 simple Analyzer 的基础上，移除停用词。 Keyword Analyzer 不切词，将输入的整个串一起返回。 自定义分词器的模板 自定义分词器的在 Mapping 的 Setting 部分设置： 1234567891011PUT my_custom_index{ &quot;settings&quot;:{ &quot;analysis&quot;:{ &quot;char_filter&quot;:{}, &quot;tokenizer&quot;:{}, &quot;filter&quot;:{}, &quot;analyzer&quot;:{} } }} 脑海中还是上面的三部分组成的图示。其中： &quot;char_filter&quot;:{}：对应字符过滤部分； &quot;tokenizer&quot;:{}：对应文本切分为分词部分； &quot;filter&quot;:{}：对应分词后再过滤部分； &quot;analyzer&quot;:{}：对应分词器组成部分，其中会包含：1. 2. 3。 请解释有关 Elasticsearch 的 NRT从文档索引（写入）到可搜索到之间的延迟默认一秒钟，因此 Elasticsearch 是近实时（NRT）搜索平台。 也就是说：文档写入，最快一秒钟被索引到，不能再快了。 写入调优的时候，我们通常会动态调整：refresh_interval = 30s 或者更达值，以使得写入数据更晚一点时间被搜索到。 Elasticsearch 的 document 设计在使用 Elasticsearch 时 避免使用复杂的查询语句（Join 、聚合），就是在建立索引时，就根据查询语句建立好对应的元数据。 集群Elasticsearch 中的节点（比如共 20 个），其中的 10 个选了一个 master，另外 10 个选了另一个 master，怎么办 当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题； 当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为 data 节点，避免脑裂问题。 解释一下 Elasticsearch 集群中的索引的概念Elasticsearch 集群可以包含多个索引，与关系数据库相比，它们相当于数据库表 解释一下 Elasticsearch Node节点是 Elasticsearch 的实例。实际业务中，我们会说：ES 集群包含 3 个节点、7 个节点。 这里节点实际就是：一个独立的 Elasticsearch 进程，一般将一个节点部署到一台独立的服务器或者虚拟机、容器中。 不同节点根据角色不同，可以划分为： 主节点 帮助配置和管理在整个集群中添加和删除节点。 数据节点 存储数据并执行诸如 CRUD（创建/读取/更新/删除）操作，对数据进行搜索和聚合的操作。 客户端节点（或者说：协调节点） 将集群请求转发到主节点，将与数据相关的请求转发到数据节点 摄取节点 用于在索引之前对文档进行预处理。 安装运维在安装 Elasticsearch 时，请说明不同的软件包及其重要性这个貌似没什么好说的，去官方文档下载对应操作系统安装包即可。 部分功能是收费的，如机器学习、高级别 kerberos 认证安全等选型要知悉。 Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法 关闭缓存 swap; 堆内存设置为：Min（节点内存/2, 32GB）; 设置最大文件句柄数； 线程池 + 队列大小根据业务需要做调整； 磁盘存储 raid 方式——存储有条件使用 RAID10，增加单节点性能以及避免单节点存储故障。 待解答 能列出 10 个使用 Elasticsearch 作为其搜索引擎或数据库的公司吗？ 解释一下 Elasticsearch Cluster Elasticsearch 索引数据多了怎么办，如何调优，部署 对于 GC 方面，在使用 Elasticsearch 时要注意什么 是否了解字典树 可以列出 X-Pack API 吗？ Elasticsearch 对于大数据量（上亿量级）的聚合如何实现 Elasticsearch 冷热分离 介绍下你们电商搜索的整体技术架构 详细描述一下 Elasticsearch 搜索的过程？ 如何在 Elasticsearch 中搜索数据 Elasticsearch 的文档是什么 ElasticSearch 中的倒排索引是什么 介绍一下你们的个性化搜索方案 Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？","link":"/b5a560cad6c8/"},{"title":"Kafka","text":"Kafka 面试题 简述 Kafka 架构设计 Consumer Group：消费者组，消费者组内每个消费者负责消费不同分区的数据，提高消费能力。逻辑上的一个订阅者； Topic：可以理解为一个队列，Topic 将消息分类，生产者和消费者面向的是同一个 Topic； Partition：为了实现扩展性，提高并发能力，一个 Topic 以多个 Partition 的方式分布到多个 Broker 上，每个 Partition 是一个 有序的队列。一个 Topic 的每个 Partition 都有若干个副本（Replica），一个 Leader 和若干个 Follower。生产者发送数据的对象，以及消费者消费数据的对象，都是 Leader。 Follower 负责实时从 Leader 中同步数据，保持和 Leader 数据的同步。Leader 发生故障时，某个 Follower 还会成为新的 Leader； Offset：消费者消费的位置信息，监控数据消费到什么位置，当消费者挂掉再重新恢复的时候，可以从 消费位置继续消费； Zookeeper：Kafka 集群能够正常工作，需要依赖于 Zookeeper，Zookeeper 帮助 Kafka 存储和管理 集群信息。 Kafka 的性能好在什么地方kafka 不基于内存，而是硬盘存储，因此消息堆积能力更强； 顺序写：利用磁盘的顺序访问速度可以接近内存，Kafka 的消息都是 append 操作，partition 是有序的， 节省了磁盘的寻道时间，同时通过批量操作、节省写入次数，partition 物理上分为多个 segment 存储， 方便删除 传统： 读取磁盘文件数据到内核缓冲区； 将内核缓冲区的数据 copy 到用户缓冲区； 将用户缓冲区的数据 copy 到 socket 的发送缓冲区； 将 socket 发送缓冲区中的数据发送到网卡、进行传输。 零拷贝： 直接将内核缓冲区的数据发送到网卡传输； 使用的是操作系统的指令支持。 Kafka 不太依赖 JVM，主要理由操作系统的 pageCache，如果生产消费速率相当，则直接用 pageCache 交换数据，不需要经过磁盘 IO。","link":"/25df9e36b6e2/"},{"title":"MongoDB","text":"无用面试题 引用♥MongoDB教程 - Mongo知识体系详解♥ | Java 全栈知识体系 (pdai.tech)","link":"/f55036105804/"},{"title":"Netty","text":"无用面试题 待整理Netty常见面试题 Netty 是什么 Netty 是一个 基于 NIO 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。 它极大地简化并优化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。 支持多种协议 如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。 用官方的总结就是：Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发，性能，稳定性和灵活性的方法。 为什么要用 Netty 统一的 API，支持多种传输类型，阻塞和非阻塞的。 简单而强大的线程模型。 自带编解码器解决 TCP 粘包/拆包问题。 自带各种协议栈。 真正的无连接数据包套接字支持。 比直接使用 Java 核心 API 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。 安全性不错，有完整的 SSL/TLS 以及 StartTLS 支持。 社区活跃. 成熟稳定，经历了大型项目的使用和考验，而且很多开源项目都使用到了 Netty，比如我们经常接触的 Dubbo、RocketMQ 等等。 Netty 应用场景 作为 RPC 框架的网络通信工具 ：我们在分布式系统中，不同服务节点之间经常需要相互调用，这个时候就需要 RPC 框架了。不同服务节点之间的通信是如何做的呢？可以使用 Netty 来做。比如我调用另外一个节点的方法的话，至少是要让对方知道我调用的是哪个类中的哪个方法以及相关参数吧！ 实现一个自己的 HTTP 服务器 ：通过 Netty 我们可以自己实现一个简单的 HTTP 服务器，这个大家应该不陌生。说到 HTTP 服务器的话，作为 Java 后端开发，我们一般使用 Tomcat 比较多。一个最基本的 HTTP 服务器可要以处理常见的 HTTP Method 的请求，比如 POST 请求、GET 请求等等。 实现一个即时通讯系统 ：使用 Netty 我们可以实现一个可以聊天类似微信的即时通讯系统，这方面的开源项目还蛮多的，可以自行去 Github 找一找。 实现消息推送系统 ：市面上有很多消息推送系统都是基于 Netty 来做的。","link":"/53a8ff3ff891/"},{"title":"Redis","text":"Redis 面试题 待解答方向：Redis 的几种数据类型，Redis 实现分布式锁，主从，哨兵，集群 是什么概念，在自己电脑上搭建一下。 ♥Redis教程 - Redis知识体系详解♥ | Java 全栈知识体系 (pdai.tech) Redis 6.0 新特性-多线程连环13问！ 一文掌握Redis的三种集群方案 Redis 和 I/O 多路复用 Redis 中的事件循环 Redis 是如何处理命令的（客户端） Redis 客户端有哪些 Jedis： Java 实现客户端，提供了比较全面的 Redis 命令的支持； 使用阻塞 I/O，方法调用都是同步的，程序流需要等到 sockets 处理完 I/O 才能执行。 Jedis 仅支持基本的数据类型如：String、Hash、List、Set、Sorted Set； Jedis 在实现上是直接连接 redis-server，在多个线程间共享一个 Jedis 实例时是线程不安全的，如果想要在多线程场景下使用 Jedis，需要使用连接池，每个线程都使用自己的 Jedis 实例，当连接数量增多时，会消耗较多的物理资源。 Redisson： 提供很多分布式相关操作服务，例如，分布式锁，分布式集合，可通过 Redis 支持延迟队列； 基于 Netty 框架的事件驱动的通信层，其方法调用是异步的。Redisson 的 API 是线程安全的，所以可以操作单个 Redisson 连接来完成各种操作； Lettuce： 用于线程安全同步，异步和响应使用，支持集群，Sentinel，管道和编码器，在一些分布式缓存框架上使用比较多； 支持同步、异步和响应式模式。多个线程可以共享一个连接实例，而不必担心多线程并发问题。它基于优秀 netty NIO 框架构建，支持 Redis 的高级功能，如 Sentinel，集群，流水线，自动重新连接和 Redis 数据模型。 Lettuce 在 5.2.2.RELEASE 解决堆外内存溢出的问题。 为什么 Redis 选择单线程模型为什么 Redis 选择单线程模型 Redis 纯内存操作，CPU 不是主要瓶颈，且使用 I/O 多路复用模型可以并发处理多个客户端连接，所以使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在网络 I/O 操作上。Redis 在 4.0 后引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作（UNLINK），通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。 Redis 使用过程中偶尔连不上 可能是开启了 RDB 备份或AOF 文件满了触发重写导致 fork 子线程引起的主线程阻塞； 如果使用了主从，哨兵或者集群，在数据全量同步时，如过 RDB 文件过大，会占用大量带宽，导致客户端连接不稳定； 有可能是网络出现了波动； Redis 延时队列Redis可通过 zset 来实现。我们可以将有序集合的 value 设置为我们的消息任务，把 value 的 score 设置为消息的到期时间，然后轮询获取有序集合的中的到期消息进行处理。 同一个任务可能会被多个进程取到之后再使用 zrem 进行争抢，那些没抢到的进程都是白取了一次任务，这是浪费。解决办法：将 zrangebyscore 和 zrem 使用 lua 脚本进行原子化操作，这样多个进程之间争抢任务时就不会出现这种浪费了。 Redis 混合持久化Redis4.0 特性。如果开启了混合持久化，AOF 将重写这一刻之前的内存做 RDB 快照处理。并且将 RDB 快照内容和增量的 AOF 修改内存数据的命令存在一起，都写入新的 AOF 文件，新的文件一开始不叫 appendonly.aof，而是等到重写完新的 AOF 文件才会进行改名，覆盖原有的 AOF 文件，完成新旧两个 AOF 文件的替换。于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，因此重启效率大幅得到提升。","link":"/a4e42390dafc/"},{"title":"拓展阅读","text":"拓展阅读 不错的资料站Java 全栈知识体系 dockerDocker 核心技术与实现原理 Stream只加工元素，不存储元素 延迟方法：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为延迟方法。） 终结方法：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调用。本小节中，终结方法包括 count 和 forEach 方法。 Lambda方法引用再一次简化 Lambda 表达式 格式：对象名::方法名称 Lambda 语法的省略规则在 Lambda 标准格式的基础上，使用省略写法的规则为： 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return 关键字及语句分号。 Lambda 表达式的3个组成部分Lambda 标准格式 Lambda 省去面向对象的条条框框，格式由 3 个部分组成：一些参数，一个箭头，一段代码。 Lambda 表达式的标准格式为：格式说明： 小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。 -&gt; 是新引入的语法格式，代表指向动作。 大括号内的语法与传统方法体要求基本一致。 Lambda 的使用前提Lambda 的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意： 使用 Lambda 必须具有接口，且要求接口中有且仅有一个抽象方法。无论是 JDK 内置的 Runnable 、 Comparator 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用 Lambda。 使用 Lambda 必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。","link":"/4eab25ca0299/"},{"title":"无用面试题","text":"无用面试题 MySQLHibernateSession 的 save()、update()、merge()、lock()、saveOrUpdate() 和 persist() 方法分别是做什么的？有什么区别？瞬时态的实例可以通过调用 save()、persist() 或者 saveOrUpdate() 方法变成持久态； 游离态的实例可以通过调用 update()、saveOrUpdate()、lock() 或者 replicate() 变成持久态。save() 和 persist() 将会引发 SQL 的 INSERT 语句，而 update() 或 merge() 会引发 UPDATE 语句。save() 和 update() 的区别在于一个是将瞬时态对象变成持久态，一个是将游离态对象变为持久态。merge() 方法可以完成 save() 和 update() 方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。 对于 persist() 方法，persist() 方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时间； persist() 方法保证当它在一个事务外部被调用的时候并不触发一个 INSERT 语句，当需要封装一个长会话流程的时候，persist()方法是很有必要的； save() 方法不保证第②条，它要返回标识符，所以它会立即执行 INSERT 语句，不管是在事务内部还是外部。至于lock()方法和update()方法的区别，update()方法是把一个已经更改过的脱管状态的对象变成持久状态；lock() 方法是把一个没有更改过的脱管状态的对象变成持久状态。 WebJavaScriptjs如何实现页面刷新呢？ history.go(0) location.reload()","link":"/23348b864b8a/"},{"title":"日常问题处理","text":"面试题 - 日常问题处理 生产环境服务器变慢，如何诊断处理？ 使用 top 指令，服务器中 CPU 和 内存的使用情况，-H 可以按 CPU 使用率降序，-M 内存使用率降序。排除其他进程占用过高的硬件资源，对 Java 服务造成影响。 如果发现 CPU 使用过高，可以使用 top 指令查出 JVM 中占用 CPU 过高的线程，通过 jstack 找到对应的线程代码调用，排查出问题代码。 如果发现内存使用率比较高，可以 dump 出 JVM 堆内存，然后借助 MAT 进行分析，查出大对象或者占用最多的对象来自哪里，为什么会长时间占用这么多；如果 dump 出的堆内存文件正常，此时可以考虑堆外内存被大量使用导致出现问题，需要借助操作系统指令 pmap 查出进程的内存分配情况、gdb dump 出具体内存信息、perf 查看本地函数调用等。 如果 CPU 和 内存使用率都很正常，那就需要进一步开启 GC 日志，分析用户线程暂停的时间、各部分内存区域 GC 次数和时间等指标，可以借助 jstat 或可视化工具 GCeasy 等，如果问题出在 GC 上面的话，考虑是否是内存不够、根据垃圾对象的特点进行参数调优、使用更适合的垃圾收集器；分析 jstack 出来的各个线程状态。如果问题实在比较隐蔽，考虑是否可以开启 jmx，使用 visualmv 等可视化工具远程监控与分析。","link":"/1f2c05056136/"},{"title":"代码","text":"算法：至少得记住二分查找，冒泡排序，链表反转 算法二分查找java实现二分查找-两种方式_maoyuanming0806的博客-CSDN博客_java 二分查找 1234567891011121314151617public static int binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 注意 while (left &lt;= right) { // 注意 int mid = (right + left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] &lt; target) { left = mid + 1; // 注意 } else if (nums[mid] &gt; target) { right = mid - 1; // 注意 } } return -1;} 冒泡排序基础Java基础(冒泡排序)_可爱的糖糖-CSDN博客_java冒泡排序 1234567891011121314151617181920212223public static void bubbleSort(int[] arr) { int temp = 0; boolean flag = false; // 通过外层 for 语句的变换对内部 for 的循环条件做一个更改，从而达到我们数据改变的一个效果 for (int i = 0; i &lt; arr.length - 1; i++) { // 走第一次内循环的时候，我们得排序是走到数组的最后一个元素的 for (int j = 0; j &lt; arr.length - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } // 如果要是一遍冒泡走下来都没有交换过的话说明我们剩下的都也已经排序好了 if (!flag) { break; } else { flag = false; } }} 进阶冒泡排序几乎是个程序员都写得出来，但是面试的时候如何写一个逼格高的冒泡排序却不是每个人都能做到，下面提供一个参考代码： 点击展开代码 >folded12345678910111213141516171819202122import java.util.Comparator;/ * 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换) * @author骆昊 * */public interface Sorter { / * 排序 * @param list 待排序的数组 */ public &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] list); / * 排序 * @param list 待排序的数组 * @param comp 比较两个对象的比较器 */ public &lt;T&gt; void sort(T[] list, Comparator&lt;T&gt; comp);} 点击展开代码 >folded123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Comparator;/ * 冒泡排序 * * @author骆昊 * */public class BubbleSorter implements Sorter { @Override public &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] list) { boolean swapped = true; for (int i = 1, len = list.length; i &lt; len &amp;&amp; swapped; ++i) { swapped = false; for (int j = 0; j &lt; len - i; ++j) { if (list[j].compareTo(list[j + 1]) &gt; 0) { T temp = list[j]; list[j] = list[j + 1]; list[j + 1] = temp; swapped = true; } } } } @Override public &lt;T&gt; void sort(T[] list, Comparator&lt;T&gt; comp) { boolean swapped = true; for (int i = 1, len = list.length; i &lt; len &amp;&amp; swapped; ++i) { swapped = false; for (int j = 0; j &lt; len - i; ++j) { if (comp.compare(list[j], list[j + 1]) &gt; 0) { T temp = list[j]; list[j] = list[j + 1]; list[j + 1] = temp; swapped = true; } } } }} 有序链表合并123456789101112131415161718192021222324252627public static class Node { public int value; public Node next; public Node(int data) { this.value = data; }}public Node merge(Node n1, Node n2) { if (n1 == null) { return n2; } if (n2 == null) { return n1; } Node head = null; if (n1.val &lt;= n2.val) { head = n1; head.next = merge(n1.next, n2); } else { head = n2; head.next = merge(n1, n2.next); } return head;} 链表反转理解单链表的反转(java实现) - 简书 (jianshu.com) 12345678910111213141516171819public static class Node { public int value; public Node next; public Node(int data) { this.value = data; }}public Node reverse(Node head) { if (head == null || head.next == null) { return head; } Node temp = head.next; Node newHead = reverse(head.next); temp.next = head; head.next = null; return newHead;} 代码实现字符串的反转及替换方法很多，可以自己写实现也可以使用 String 或 StringBuffer/StringBuilder 中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示： 12345public static String reverse(String originStr) { if(originStr == null || originStr.length() &lt;= 1) return originStr; return reverse(originStr.substring(1)) + originStr.charAt(0);} 通过反射调用对象的方法请看下面的代码： 12345678910import java.lang.reflect.Method;class MethodInvokeTest { public static void main(String[] args) throws Exception { String str = &quot;hello&quot;; Method m = str.getClass().getMethod(&quot;toUpperCase&quot;); System.out.println(m.invoke(str)); // HELLO }} 日期和时间如何取得年月日、小时分钟秒创建 java.util.Calendar 实例，调用其 get() 方法传入不同的参数即可获得参数所对应的值。Java 8 中可以使用 java.time.LocalDateTime 来获取，代码如下所示。 点击展开代码 >folded1234567891011121314151617181920public class DateTimeTest { public static void main(String[] args) { Calendar cal = Calendar.getInstance(); System.out.println(cal.get(Calendar.YEAR)); System.out.println(cal.get(Calendar.MONTH)); // 0 - 11 System.out.println(cal.get(Calendar.DATE)); System.out.println(cal.get(Calendar.HOUR_OF_DAY)); System.out.println(cal.get(Calendar.MINUTE)); System.out.println(cal.get(Calendar.SECOND)); // Java 8 LocalDateTime dt = LocalDateTime.now(); System.out.println(dt.getYear()); System.out.println(dt.getMonthValue()); // 1 - 12 System.out.println(dt.getDayOfMonth()); System.out.println(dt.getHour()); System.out.println(dt.getMinute()); System.out.println(dt.getSecond()); }} 如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒 到现在的毫秒数？以下方法均可获得该毫秒数。 点击展开代码 >folded123Calendar.getInstance().getTimeInMillis();System.currentTimeMillis();Clock.systemDefaultZone().millis(); // Java 8 如何取得某月的最后一天代码如下所示。 点击展开代码 >folded12Calendar time = Calendar.getInstance();time.getActualMaximum(Calendar.DAY_OF_MONTH); 如何格式化日期利用 java.text.DataFormat 的子类（如 SimpleDateFormat 类）中的 format(Date) 方法可将日期格式化。Java 8 中可以用 java.time.format.DateTimeFormatter 来格式化时间日期，代码如下所示。 点击展开代码 >folded123456789101112131415161718import java.text.SimpleDateFormat;import java.time.LocalDate;import java.time.format.DateTimeFormatter;import java.util.Date;class DateFormatTest { public static void main(String[] args) { SimpleDateFormat oldFormatter = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;); Date date1 = new Date(); System.out.println(oldFormatter.format(date1)); // Java 8 DateTimeFormatter newFormatter = DateTimeFormatter.ofPattern(&quot;yyyy/MM/dd&quot;); LocalDate date2 = LocalDate.now(); System.out.println(date2.format(newFormatter)); }} 补充：Java的时间日期API一直以来都是被诟病的东西，为了解决这一问题，Java 8中引入了新的时间日期API，其中包括LocalDate、LocalTime、LocalDateTime、Clock、Instant等类，这些的类的设计都使用了不变模式，因此是线程安全的设计。 W Java 中，如何计算两个日期之间的差距？你能写出一个正则表达式来判断一个字符串是否是一个数字吗？一个数字字符串，只能包含数字，如 0 到 9 以及 +、- 开头，通过这个信息，你可以下一个如下的正则表达式来判断给定的字符串是不是数字。 点击展开代码 >folded123456789首先要import java.util.regex.Pattern 和 java.util.regex.Matcherpublic boolean isNumeric(String str){ Pattern pattern = Pattern.compile(&quot;[0-9]*&quot;); Matcher isNum = pattern.matcher(str); if( !isNum.matches() ){ return false; } return true; } 如何实现对象克隆？有两种方式： 1)、实现Cloneable接口并重写Object类中的clone()方法； 2)、实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。 点击展开代码 >folded1234567891011121314151617181920212223242526import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class MyUtil { private MyUtil() { throw new AssertionError(); } @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T extends Serializable&gt; T clone(T obj) throws Exception { ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bout); oos.writeObject(obj); ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bin); return (T) ois.readObject(); // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义 // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放 }} 下面是测试代码： 点击展开代码 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.Serializable;/ * 人类 * @author 骆昊 * */class Person implements Serializable { private static final long serialVersionUID = -9102017020286042305L; private String name; // 姓名 private int age; // 年龄 private Car car; // 座驾 public Person(String name, int age, Car car) { this.name = name; this.age = age; this.car = car; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Car getCar() { return car; } public void setCar(Car car) { this.car = car; } @Override public String toString() { return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, car=&quot; + car + &quot;]&quot;; }} 点击展开代码 >folded1234567891011121314151617181920212223242526272829303132333435363738/ * 小汽车类 * @author 骆昊 * */class Car implements Serializable { private static final long serialVersionUID = -5713945027627603702L; private String brand; // 品牌 private int maxSpeed; // 最高时速 public Car(String brand, int maxSpeed) { this.brand = brand; this.maxSpeed = maxSpeed; } public String getBrand() { return brand; } public void setBrand(String brand) { this.brand = brand; } public int getMaxSpeed() { return maxSpeed; } public void setMaxSpeed(int maxSpeed) { this.maxSpeed = maxSpeed; } @Override public String toString() { return &quot;Car [brand=&quot; + brand + &quot;, maxSpeed=&quot; + maxSpeed + &quot;]&quot;; }} 点击展开代码 >folded12345678910111213141516class CloneTest { public static void main(String[] args) { try { Person p1 = new Person(&quot;Hao LUO&quot;, 33, new Car(&quot;Benz&quot;, 300)); Person p2 = MyUtil.clone(p1); // 深度克隆 p2.getCar().setBrand(&quot;BYD&quot;); // 修改克隆的Person对象p2关联的汽车对象的品牌属性 // 原来的Person对象p1关联的汽车不会受到任何影响 // 因为在克隆Person对象时其关联的汽车对象也被克隆了 System.out.println(p1); } catch (Exception e) { e.printStackTrace(); } }} 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。","link":"/0e756a811773/"},{"title":"网络","text":"网络面试题 待整理你所知道网络协议有那些？ HTTP：超文本传输协议 FTP：文件传输协议 SMPT：简单邮件协议 TELNET：远程终端协议 POP3：邮件读取协议 Java 网络编程 TCP 编程 UDP 编程 计算机网络有几层？ 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 （物理层是最底层，应用层是最高层） TCPTCP 协议TCP协议中”三次握手”,第一次握手指的是什么： 答案 第一次握手:客户端向服务器发送请求,等待服务器确认 TCP 三次握手为什么 TCP 建立连接需要三次握手 客户端向服务端发送带有 SYN 的数据段以及客户端开始发送数据段（Segment）的初始序列号 SEQ = 100； 服务端收到数据段时，向客户端发送带有 SYN 和 ACK 的数据段； 通过返回 ACK = 101 确认客户端数据段的初始序列号； 通过发送 SEQ = 300 通知客户端，服务端开始发送数据段的初始序列号； 客户端向服务端发送带有 ACK 的数据段，确认服务端的初始序列号，其中包含 ACK = 301； 如果通信双方的通信次数只有两次，那么发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求，如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果 TCP 建立连接只能通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而造成的过期连接。 所以，TCP 选择使用三次握手来建立连接并在连接引入了 RST 这一控制消息，接收方当收到请求时会将发送方发来的 SEQ+1 发送给对方，这时由发送方来判断当前连接是否是历史连接： 如果当前连接是历史连接，即 SEQ 过期或者超时，那么发送方就会直接发送 RST 控制消息中止这一次连接； 如果当前连接不是历史连接，那么发送方就会发送 ACK 控制消息，通信双方就会成功建立连接； 使用三次握手和 RST 控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的，这也是 TCP 使用三次握手建立连接的最主要原因。 序列号：根据序列号对包排序、去重、丢失补偿 两次握手：无法避免历史错误链接初始化，浪费接收方资源； 四次握手：TCP 的设计可以同时传递 ACK 和 SYN 两个控制信号，减少通信次数，所以四次及更多不必要； UDP为什么 DNS 使用 UDP为什么 DNS 使用 UDP 协议 当 DNS 解析器仅需与一个命名服务器或权威服务器进行链接时，TCP 建立连接的三次握手与销毁连接的四次挥手会消耗大概 300 字节的数据，而 UDP 由于无需握手挥手，则仅需 80 字节左右。实际场景中可能会递归的与多个命名服务器进行通信，会加倍放大 TCP 协议的额外开销。 而由于现如今 IPV6、保证 DNS 请求完整性与传输安全导致 DNS 需要处理的包越来越大，又因为数据包一旦超过传输链路的最大值（一般为 1500 字节），数据包就会被分片传输、丢弃甚至被拒绝，这导致使用 UDP 协议的 DNS 不稳定。 当 DNS 包越大，使用 TCP 带来的收益越高： 当 DNS 数据包大小为 500 字节时，TCP 协议的额外开销为 ~41.2%； 当 DNS 数据包大小为 1100 字节时，TCP 协议的额外开销为 ~20.7%； 当 DNS 数据包大小为 2300 字节时，TCP 协议的额外开销为 ~10.3%； 当 DNS 数据包大小为 4800 字节时，TCP 协议的额外开销为 ~5.0%； DNS 查询在刚设计时主要使用 UDP 协议进行通信，而 TCP 协议也是在 DNS 的演进和发展中被加入到规范的： DNS 在设计之初就在区域传输中引入了 TCP 协议，在查询中使用 UDP 协议； 当 DNS 超过了 512 字节的限制，我们第一次在 DNS 协议中明确了『当 DNS 查询被截断时，应该使用 TCP 协议进行重试』这一规范； 随后引入的 EDNS 机制允许我们使用 UDP 最多传输 4096 字节的数据，但是由于 MTU 的限制导致的数据分片以及丢失，使得这一特性不够可靠； 在最近的几年，我们重新规定了 DNS 应该同时支持 UDP 和 TCP 协议，TCP 协议也不再只是重试时的选择； DNS 查询选择 UDP 或者 TCP 两种不同协议时的主要原因： UDP 协议 DNS 查询的数据包较小、机制简单； UDP 协议的额外开销小、有着更好的性能表现； TCP 协议 DNS 查询由于 DNSSEC 和 IPv6 的引入迅速膨胀，导致 DNS 响应经常超过 MTU 造成数据的分片和丢失，我们需要依靠更加可靠的 TCP 协议完成数据的传输； 随着 DNS 查询中包含的数据不断增加，TCP 协议头以及三次握手带来的额外开销比例逐渐降低，不再是占据总传输数据大小的主要部分； 无论是选择 UDP 还是 TCP，最核心的矛盾就在于需要传输的数据包大小，如果数据包小到一定程度，UDP 协议绝对最佳的选择，但是当数据包逐渐增大直到突破 512 字节以及 MTU 1500 字节的限制时，我们也只能选择使用更可靠的 TCP 协议来传输 DNS 查询和相应。 UDP 协议判断下列说法是否正确 由于UDP面向无连接的协议,可以保证数据完整性,因此在传输重要数据时采用UDP协议. 答案 判断错误,因为面向无连接,容易丢失包,所以不能保证数据完整. 为什么 HTTPS 需要 7 次握手以及 9 倍时延为什么 HTTPS 需要 7 次握手以及 9 倍时延 TCP 协议需要通过三次握手建立 TCP 连接保证通信的可靠性（1.5-RTT）； TLS 协议会在 TCP 协议之上通过四次握手建立 TLS 连接保证通信的安全性（2-RTT）； HTTP 协议会在 TCP 和 TLS 上通过一次往返发送请求并接收响应（1-RTT）； ip 地址和端口号概念 IP地址:互联网协议地址(Internet Protocol Address),俗称IP.IP地址用来给一个网络中的计算机设备做唯一的编号. 端口号:端口号用来给计算机里的应用程序(进程)做唯一的标识,用2个字节表示的整数,取值范围0~65535.","link":"/101b51771e7f/"},{"title":"设计模式","text":"设计模式面试题 资料常用设计模式 - 掘金 (juejin.cn) 设计模式分类 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 Spring 开发中的工厂设计模式Spring IOC 在 Spring IOC 容器创建 bean 的过程是使用了工厂设计模式 Spring 中无论是通过 xml 配置还是通过配置类还是注解进行创建 bean，大部分都是通过简单工厂来进行创建的。 当容器拿到了 beanName 和 class 类型后，动态的通过反射创建具体的某个对象，最后将创建的对象放到 Map 中。 为什么 Spring IOC 要使用工厂设计模式创建 Bean 呢 在实际开发中，如果我们 A 对象调用 B，B 调用 C，C 调用 D 的话我们程序的耦合性就会变高。（耦合大致分为类与类之间的依赖，方法与方法之间的依赖。） 在很久以前的三层架构编程时，都是控制层调用业务层，业务层调用数据访问层时，都是是直接 new 对象，耦合性大大提升，代码重复量很高，对象满天飞 为了避免这种情况，Spring 使用工厂模式编程，写一个工厂，由工厂创建 Bean，以后我们如果要对象就直接管工厂要就可以，剩下的事情不归我们管了。Spring IOC 容器的工厂中有个静态的 Map 集合，是为了让工厂符合单例设计模式，即每个对象只生产一次，生产出对象后就存入到 Map 集合中，保证了实例不会重复影响程序效率。 单例模式 不需要延迟加载单例：枚举或者饿汉式，相对来说枚举性好于饿汉式。 需要延迟加载，可以使用静态内部类或者懒汉式，相对来说静态内部类好于懒汉式。 最好使用饿汉式 主要使用懒汉和懒汉式 饿汉式:类初始化时,会立即加载该对象，线程天生安全,调用效率高。 懒汉式: 类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。 静态内部方式:结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。 枚举单例: 使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞， 缺点没有延迟加载。 双重检测锁方式 (因为JVM本质重排序的原因，可能会初始化多次，不推荐使用) 饿汉式类初始化时,会立即加载该对象，线程天生安全,调用效率高。 12345678910111213141516171819202122package com.lijie;//饿汉式public class Demo1 { // 类初始化时,会立即加载该对象，线程安全,调用效率高 private static Demo1 demo1 = new Demo1(); private Demo1() { System.out.println(&quot;私有Demo1构造参数初始化&quot;); } public static Demo1 getInstance() { return demo1; } public static void main(String[] args) { Demo1 s1 = Demo1.getInstance(); Demo1 s2 = Demo1.getInstance(); System.out.println(s1 == s2); }} 懒汉式类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。 12345678910111213141516171819202122232425package com.lijie;//懒汉式public class Demo2 { //类初始化时，不会初始化该对象，真正需要使用的时候才会创建该对象。 private static Demo2 demo2; private Demo2() { System.out.println(&quot;私有Demo2构造参数初始化&quot;); } public synchronized static Demo2 getInstance() { if (demo2 == null) { demo2 = new Demo2(); } return demo2; } public static void main(String[] args) { Demo2 s1 = Demo2.getInstance(); Demo2 s2 = Demo2.getInstance(); System.out.println(s1 == s2); }} 静态内部类结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。 123456789101112131415161718192021222324package com.lijie;// 静态内部类方式public class Demo3 { private Demo3() { System.out.println(&quot;私有Demo3构造参数初始化&quot;); } public static class SingletonClassInstance { private static final Demo3 DEMO_3 = new Demo3(); } // 方法没有同步 public static Demo3 getInstance() { return SingletonClassInstance.DEMO_3; } public static void main(String[] args) { Demo3 s1 = Demo3.getInstance(); Demo3 s2 = Demo3.getInstance(); System.out.println(s1 == s2); }} 枚举单例式使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞， 缺点没有延迟加载。 12345678910111213141516171819202122232425262728293031package com.lijie;//使用枚举实现单例模式 优点:实现简单、枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞 缺点没有延迟加载public class Demo4 { public static Demo4 getInstance() { return Demo.INSTANCE.getInstance(); } public static void main(String[] args) { Demo4 s1 = Demo4.getInstance(); Demo4 s2 = Demo4.getInstance(); System.out.println(s1 == s2); } //定义枚举 private static enum Demo { INSTANCE; // 枚举元素为单例 private Demo4 demo4; private Demo() { System.out.println(&quot;枚举Demo私有构造参数&quot;); demo4 = new Demo4(); } public Demo4 getInstance() { return demo4; } }} 双重检测锁方式因为JVM本质重排序的原因，可能会初始化多次，不推荐使用 12345678910111213141516171819202122232425262728package com.lijie;//双重检测锁方式public class Demo5 { private static Demo5 demo5; private Demo5() { System.out.println(&quot;私有Demo4构造参数初始化&quot;); } public static Demo5 getInstance() { if (demo5 == null) { synchronized (Demo5.class) { if (demo5 == null) { demo5 = new Demo5(); } } } return demo5; } public static void main(String[] args) { Demo5 s1 = Demo5.getInstance(); Demo5 s2 = Demo5.getInstance(); System.out.println(s1 == s2); }} 单例防止反射漏洞攻击1234567891011121314private static boolean flag = false;private Singleton() { if (flag == false) { flag = !flag; } else { throw new RuntimeException(&quot;单例模式被侵犯！&quot;); }}public static void main(String[] args) {} 单例模式使用注意事项： 使用时不能用反射模式创建单例，否则会实例化一个新的对象 使用懒单例模式时注意线程安全问题 饿单例模式和懒单例模式构造方法都是私有的，因而是不能被继承的，有些单例模式可以被继承（如登记式模式） 依赖注入和工程模式之间有什么不同虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式更清晰。通过依赖注入，你的类就是 POJO，它只知道依赖而不关心它们怎么获取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用 DI 会比使用工厂模式更容易测试。 原型模式的应用场景 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。这时我们就可以通过原型拷贝避免这些消耗。 通过new产生的一个对象需要非常繁琐的数据准备或者权限，这时可以使用原型模式。 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。 Spring 框架中的多例就是使用原型 观察者模式应用场景 关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。事件多级触发场景。 跨系统的消息交换场景，如消息队列、事件总线的处理机制。 1、 定义抽象观察者，每一个实现该接口的实现类都是具体观察者。 1234567package com.lijie;//观察者的接口，用来存放观察者共有方法public interface Observer { // 观察者方法 void update(int state);} 2、 定义具体观察者 1234567891011121314151617package com.lijie;// 具体观察者public class ObserverImpl implements Observer { // 具体观察者的属性 private int myState; public void update(int state) { myState=state; System.out.println(&quot;收到消息,myState值改为：&quot;+state); } public int getMyState() { return myState; }} 3、 定义主题。主题定义观察者数组，并实现增、删及通知操作。 12345678910111213141516171819202122232425package com.lijie;import java.util.Vector;//定义主题，以及定义观察者数组，并实现增、删及通知操作。public class Subjecct { //观察者的存储集合，不推荐ArrayList，线程不安全， private Vector&lt;Observer&gt; list = new Vector&lt;&gt;(); // 注册观察者方法 public void registerObserver(Observer obs) { list.add(obs); } // 删除观察者方法 public void removeObserver(Observer obs) { list.remove(obs); } // 通知所有的观察者更新 public void notifyAllObserver(int state) { for (Observer observer : list) { observer.update(state); } }} 4、 定义具体的，他继承继承Subject类，在这里实现具体业务，在具体项目中，该类会有很多。 123456789101112131415package com.lijie;//具体主题public class RealObserver extends Subjecct { //被观察对象的属性 private int state; public int getState(){ return state; } public void setState(int state){ this.state=state; //主题对象(目标对象)值发生改变 this.notifyAllObserver(state); }} 5、 运行测试 123456789101112131415161718192021222324252627package com.lijie;public class Client { public static void main(String[] args) { // 目标对象 RealObserver subject = new RealObserver(); // 创建多个观察者 ObserverImpl obs1 = new ObserverImpl(); ObserverImpl obs2 = new ObserverImpl(); ObserverImpl obs3 = new ObserverImpl(); // 注册到观察队列中 subject.registerObserver(obs1); subject.registerObserver(obs2); subject.registerObserver(obs3); // 改变State状态 subject.setState(300); System.out.println(&quot;obs1观察者的MyState状态值为：&quot;+obs1.getMyState()); System.out.println(&quot;obs2观察者的MyState状态值为：&quot;+obs2.getMyState()); System.out.println(&quot;obs3观察者的MyState状态值为：&quot;+obs3.getMyState()); // 改变State状态 subject.setState(400); System.out.println(&quot;obs1观察者的MyState状态值为：&quot;+obs1.getMyState()); System.out.println(&quot;obs2观察者的MyState状态值为：&quot;+obs2.getMyState()); System.out.println(&quot;obs3观察者的MyState状态值为：&quot;+obs3.getMyState()); }} 观察者的职责观察者模式主要用于 1 对 N 的通知。当一个对象的状态变化时，他需要及时告知一系列对象，令他们做出相应。 实现有两种方式： 推：每次都会把通知以广播的方式发送给所有观察者，所有的观察者只能被动接收。 拉：观察者只要知道有情况即可，至于什么时候获取内容，获取什么内容，都可以自主决定。 抽象工厂模式和原型模式之间的区别 抽象工厂模式：通常由工厂方法模式来实现。但一个工厂中往往含有多个工厂方法生成一系列的产品。这个模式强调的是客户代码一次保证只使用一个系列的产品。当要切换为另一个系列的产品，换一个工厂类即可。 原型模式：工厂方法的最大缺点就是，对应一个继承体系的产品类，要有一个同样复杂的工厂类的继承体系。我们可以把工厂类中的工厂方法放到产品类自身之中吗？如果这样的话，就可以将两个继承体系为一个。这也就是原型模式的思想，原型模式中的工厂方法为 clone，它会返回一个拷贝（可以是浅拷贝，也可以是深拷贝，由设计者决定）。为了保证用户代码中到时可以通过指针调用 clone 来动态绑定地生成所需的具体的类。这些原型对象必须事先构造好。 原型模式想对工厂方法模式的另一个好处是，拷贝的效率一般对构造的效率要高。","link":"/3d68a730359e/"},{"title":"Icarus美化","text":"这里的内容会出现在 简介和正文 这里的内容只会出现在 简介 .post-summary { display: none; } 来自 iMaeGoo 分享的经验 活用 Bulma 美化 Icarus 文章 - iMaeGoo’s Blog 点击展开代码点击展开代码 >folded1console.log('I love Icarus!'); 鼠标移入显示内容 .heimu { color: #000; background-color: #000; } .heimu:hover { color: #fff; } 右侧的文本需要鼠标移入才可以显示出来。 彩色突出 这里仅仅给出一个样例，更多请移步彩色突出","link":"/8878d434f24c/"},{"title":"字符画生成工具","text":"字符画生成器，可用于项目启动、说明文档等 字符画生成器[Text to ASCII Art Generator (TAAG) (patorjk.com)](http://patorjk.com/software/taag/#p=display&amp;f=Doom&amp;t=Report startup success) doom12345678 ___ _ _ _ / _ \\ (_) | | | | / /_\\ \\_ __ _ ___| |_ __ _ _ __| |_ _ _ _ __ ___ _ _ ___ ___ ___ ___ ___ | _ | '_ \\| | / __| __/ _` | '__| __| | | | '_ \\ / __| | | |/ __/ __/ _ \\/ __/ __|| | | | |_) | | \\__ \\ || (_| | | | |_| |_| | |_) | \\__ \\ |_| | (_| (_| __/\\__ \\__ \\\\_| |_/ .__/|_| |___/\\__\\__,_|_| \\__|\\__,_| .__/ |___/\\__,_|\\___\\___\\___||___/___/ | | | | |_| |_| big12345678 _ _ _ /\\ (_) | | | | / \\ _ __ _ ___| |_ __ _ _ __| |_ _ _ _ __ ___ _ _ ___ ___ ___ ___ ___ / /\\ \\ | '_ \\| | / __| __/ _` | '__| __| | | | '_ \\ / __| | | |/ __/ __/ _ \\/ __/ __| / ____ \\| |_) | | \\__ \\ || (_| | | | |_| |_| | |_) | \\__ \\ |_| | (_| (_| __/\\__ \\__ \\/_/ \\_\\ .__/|_| |___/\\__\\__,_|_| \\__|\\__,_| .__/ |___/\\__,_|\\___\\___\\___||___/___/ | | | | |_| |_| ogre123456 _ _ _ _ /_\\ _ __ (_) ___| |_ __ _ _ __| |_ _ _ _ __ ___ _ _ ___ ___ ___ ___ ___ //_\\\\| '_ \\| | / __| __/ _` | '__| __| | | | '_ \\ / __| | | |/ __/ __/ _ \\/ __/ __|/ _ \\ |_) | | \\__ \\ || (_| | | | |_| |_| | |_) | \\__ \\ |_| | (_| (_| __/\\__ \\__ \\\\_/ \\_/ .__/|_| |___/\\__\\__,_|_| \\__|\\__,_| .__/ |___/\\__,_|\\___\\___\\___||___/___/ |_| |_| slant123456 ___ _ __ __ / | ____ (_) _____/ /_____ ______/ /___ ______ _______ _______________ __________ / /| | / __ \\/ / / ___/ __/ __ `/ ___/ __/ / / / __ \\ / ___/ / / / ___/ ___/ _ \\/ ___/ ___/ / ___ |/ /_/ / / (__ ) /_/ /_/ / / / /_/ /_/ / /_/ / (__ ) /_/ / /__/ /__/ __(__ |__ ) /_/ |_/ .___/_/ /____/\\__/\\__,_/_/ \\__/\\__,_/ .___/ /____/\\__,_/\\___/\\___/\\___/____/____/ /_/ /_/ standard123456 _ _ _ _ / \\ _ __ (_) ___| |_ __ _ _ __| |_ _ _ _ __ ___ _ _ ___ ___ ___ ___ ___ / _ \\ | '_ \\| | / __| __/ _` | '__| __| | | | '_ \\ / __| | | |/ __/ __/ _ \\/ __/ __| / ___ \\| |_) | | \\__ \\ || (_| | | | |_| |_| | |_) | \\__ \\ |_| | (_| (_| __/\\__ \\__ \\/_/ \\_\\ .__/|_| |___/\\__\\__,_|_| \\__|\\__,_| .__/ |___/\\__,_|\\___\\___\\___||___/___/ |_| |_| star wars123456 ___ .______ __ _______.___________. ___ .______ .___________. __ __ .______ _______. __ __ ______ ______ _______ _______. _______. / \\ | _ \\ | | / | | / \\ | _ \\ | || | | | | _ \\ / || | | | / | / || ____| / | / | / ^ \\ | |_) | | | | (----`---| |----` / ^ \\ | |_) | `---| |----`| | | | | |_) | | (----`| | | | | ,----'| ,----'| |__ | (----` | (----` / /_\\ \\ | ___/ | | \\ \\ | | / /_\\ \\ | / | | | | | | | ___/ \\ \\ | | | | | | | | | __| \\ \\ \\ \\ / _____ \\ | | | | .----) | | | / _____ \\ | |\\ \\----. | | | `--' | | | .----) | | `--' | | `----.| `----.| |____.----) | .----) | /__/ \\__\\ | _| |__| |_______/ |__| /__/ \\__\\ | _| `._____| |__| \\______/ | _| |_______/ \\______/ \\______| \\______||_______|_______/ |_______/ ANSI Shadow123456 █████╗ ██████╗ ██╗ ███████╗████████╗ █████╗ ██████╗ ████████╗██╗ ██╗██████╗ ███████╗██╗ ██╗ ██████╗ ██████╗███████╗███████╗███████╗██╔══██╗██╔══██╗██║ ██╔════╝╚══██╔══╝██╔══██╗██╔══██╗╚══██╔══╝██║ ██║██╔══██╗ ██╔════╝██║ ██║██╔════╝██╔════╝██╔════╝██╔════╝██╔════╝███████║██████╔╝██║ ███████╗ ██║ ███████║██████╔╝ ██║ ██║ ██║██████╔╝ ███████╗██║ ██║██║ ██║ █████╗ ███████╗███████╗██╔══██║██╔═══╝ ██║ ╚════██║ ██║ ██╔══██║██╔══██╗ ██║ ██║ ██║██╔═══╝ ╚════██║██║ ██║██║ ██║ ██╔══╝ ╚════██║╚════██║██║ ██║██║ ██║ ███████║ ██║ ██║ ██║██║ ██║ ██║ ╚██████╔╝██║ ███████║╚██████╔╝╚██████╗╚██████╗███████╗███████║███████║╚═╝ ╚═╝╚═╝ ╚═╝ ╚══════╝ ╚═╝ ╚═╝ ╚═╝╚═╝ ╚═╝ ╚═╝ ╚═════╝ ╚═╝ ╚══════╝ ╚═════╝ ╚═════╝ ╚═════╝╚══════╝╚══════╝╚══════╝","link":"/60da66aa736b/"},{"title":"工作代码，暂未分类","text":"暂未分类的工作代码 Java 常用方法实体类集合抽取某字段为集合12345678910public static List&lt;String&gt; getUserIdList(List&lt;HousekeeperDetailsVo&gt; list) { List&lt;String&gt; idList = new ArrayList&lt;&gt;(); if (CollectionUtils.isNotEmpty(list)) { idList = list.stream().map(HousekeeperDetailsVo::getUserId).distinct().collect(Collectors.toList()); } idList.remove(&quot;&quot;); idList.remove(null); return idList;} 实体类集合以某字段为 key 抽取 map12345678public static Map&lt;String, UserVo&gt; toMap(List&lt;UserVo&gt; list) { Map&lt;String, UserVo&gt; map = new HashMap&lt;&gt;(); if (CollectionUtils.isNotEmpty(list)) { list.stream().collect(Collectors.toMap(UserVo::getUserId, k -&gt; k)); } return map;} 实体类集合以某字段为 key 抽取 map List12345678public static Map&lt;String, List&lt;OrderSkuBaseVo&gt;&gt; toListMap(List&lt;OrderSkuBaseVo&gt; list) { Map&lt;String, List&lt;OrderSkuBaseVo&gt;&gt; map = new HashMap&lt;&gt;(); if (CollectionUtils.isNotEmpty(list)) { map = list.stream().collect(Collectors.groupingBy(OrderSkuBaseVo::getOrderId)); } return map;} 实体类集合以某字段为 key 分组为 map List12345678public static Map&lt;String, List&lt;String&gt;&gt; toMap(List&lt;ShopProjectVo&gt; list) { Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); if (CollectionUtils.isNotEmpty(list)) { list.forEach(k -&gt; map.computeIfAbsent(k.getShopId(), v -&gt; new ArrayList&lt;&gt;()).add(k.getProjectId())); } return map;}DistrictInfo 循环从 map 获取数据并设值1list.forEach(k -&gt; k.setList(map.computeIfAbsent(k.getId(), v -&gt; new ArrayList&lt;&gt;()))); JSON 作为出参1xxVo.setVo(JSON.parseObject(JSON.toJSONString(vo))); 循环从 map 获取数据并设值1list.forEach(k -&gt; k.setList(map.computeIfAbsent(k.getId(), v -&gt; new ArrayList&lt;&gt;()))); hibernate 关闭日志12hibernate.show_sql = falsespring.jpa.show-sql = false 通用Chrome 控制台调用接口1234567var body = {&quot;id&quot;: 1}var url = &quot;https://127.0.0.1/query&quot;;var xml = new XMLHttpRequest();xml.open('POST', url, true); xml.setRequestHeader(&quot;Content-type&quot;,&quot;application/json&quot;);xml.setRequestHeader(&quot;X-Requested-With&quot;,&quot;XMLHttpRequest&quot;);xml.send(JSON.stringify(body)); Linux权限12# 授权chmod -R 755 h5/ h5-1/ h5-2/ 启动 jar：1java -server -jar -Dspring.profiles.active=test /home/api/lib/api-1.0-SNAPSHOT.jar &gt;&gt; /home/api/log/startApi.log crontab110 * * * * curl http://127.0.0.1:8080/doSomething 查看端口是否被占用1netstat -tunlp | grep 80 查看服务是否启动1ps aux | grep partner Linux 用户相关操作123456# 新建用户useradd -m 用户名# 设置密码passwd 用户名# 删除用户userdel -r 用户名 压缩解压文件1234# 解压 gz 压缩包tar -xvf html.tar.gz# 压缩文件tar -czvf sync.ar.gz sync/ 防火墙CentOS7 默认的防火墙不是 iptables，而是 firewalle。CentOS 从 7 版本开始默认用的是 firewalld，这个是基于 iptables 的，虽然有 iptables 的核心，但是 iptables 的服务是没安装的。所以只要先关闭 firewalld 服务，再安装 iptables 服务即可 firewall 相关命令12345# 停止 firewallsystemctl stop firewalld.service# 禁止 firewall 开机启动systemctl disable firewalld.service iptables 相关命令1234567891011121314151617181920212223242526# 安装 iptablesyum install -y iptables-services# 编辑配置文件vim /etc/sysconfig/iptables# 重启防火墙systemctl restart iptables.service# 设置防火墙开机启动systemctl enable iptables.service# 禁止 iptables 服务systemctl disable iptables# 暂停服务systemctl stop iptables# 解除禁止 iptablessystemctl enable iptables# 开启服务systemctl start iptables# 查看 iptables 服务状态service iptables status 参考资料CentOS 7配置iptables_Linux教程_Linux公社-Linux系统门户网站 WindowsWindows10 系统多桌面切换快捷键创建新的虚拟桌面：Win + Ctrl + D 关闭当前虚拟桌面：Win + Ctrl + F4 切换虚拟桌面：Win + Ctrl + 方向键左/右 贴靠窗口（窗口可以变为 1/4 大小放置在屏幕 4 个角落）：Win + 上/下/左/右 切换窗口（不是新的，但任务切换界面改进）：Alt + Tab 任务视图（松开键盘界面不会消失）：Win + Tab 查看端口占用123456# 查看端口占用情况netstat -ano | findstr '8080'# 查看占用程序tasklist | findstr 20208# 结束程序taskkill /f /t /im node.exe Nginx刷新配置文件：1nginx -s reload docker12345678# 重启所有docker restart $(docker ps -a | awk '{ print $1}' | tail -n +2) # 进入容器（支持中文输入）docker exec -it f5ae47536740 env LANG=C.UTF-8 bash# 启动容器docker run -d -p 443:443 -p 8002:8002 -v /home/nginx/html:/usr/share/nginx/html --name nginx ngin:1.16.1 待整理 docker 学习 MySQL事务隔离级别【Spring学习33】Spring事务(3)：事务属性之隔离级别(isolation level)_程序老兵的博客-CSDN博客_isolation.default 登录 mysql123mysql -h 127.0.0.1 -u video -ppassword MySQL 8.0 支持 groupBy123select @@global.sql_mode;set GLOBAL sql_mode = 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION '; 修改密码加密方式12345678select host,user,plugin,authentication_string from mysql.user;ALTER USER 'user'@'%' IDENTIFIED WITH mysql_native_password BY 'password';ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'password';CREATE USER 'users'@'%' IDENTIFIED WITH mysql_native_password BY 'password';grant all privileges on *.* to 'video'@'%'; 修改本次连接编码1234567891011# 查询编码情况show variables like 'character_set_%';# 设置编码set character_set_client=utf8;set character_set_results=utf8;set character_set_connection=utf8;set character_set_connection=utf8;# 设置编码，与上四条结果相同set names utf8; 清空数据库数据1TRUNCATE TABLE tf_dept; 修改时区12345select now();set global time_zone = '+8:00';flush privileges;","link":"/5b6bfc5b1631/"},{"title":"待归档","text":"存放暂时未进行分类或学习的文章 GitHub如何配置SSH Key_前端向朔-CSDN博客_github ssh","link":"/3a9b80b3a95d/"},{"title":"摄影后期学习笔记","text":"摄影后期学习笔记 2021.11.17","link":"/0e963f51390f/"},{"title":"高项每日","text":"信息系统项目管理师学习笔记 2021.11.17第一章 信息化和信息系统2、信息质量属性 精确性：对事物状态描述的精准程度； 完整性：对事物状态描述的全面程度，完整信息应包括所有的重要事实； 可靠性：信息的来源、采集方法、传输过程、是可信任的，符合预期； 及时性：指获得信息的时刻与事件发生的时刻的间隔长短； 经济型：信息获取、传输带来的成本在可接受范围内； 可验证性：信息的主要质量属性可被证实或证伪的程度； 安全性：在信息的生命周期中，信息可被非授权访问的可能性，可能性越低，安全性越高； 7、信息化体系六要素 信息资源：信息资源的开发和利用是国家信息化的核心任务； 信息网络：信息网络是信息资源开发与利用的基础设施； 信息技术应用：指把信息技术广泛应用于经济与社会的各个领域，它直接的反应了效率、效果、效益。信息技术应用是信息化体系六要素的龙头，是国家信息化的主阵地； 信息技术与产业：信息化的物质基础； 信息化人才：信息化的成功之本； 信息化政策法规和标准规范：信息化政策和法规、标准、规范用于规范和协调信息化体系要素之间的关系，是国家信息化快速、有序、健康和持续发展的保障； 8、信息化系统的生命周期 4 大：立项、开发、运维、消亡 立项（系统规划）：确定信息系统的发展战略，对建设新系统的要求做出分析和预测，写成可执行报告； 开发： 系统分析：确定新系统的基本目标和逻辑功能要求，即提出新系统的逻辑模型； 系统设计：具体设计实施逻辑模型的技术方案，也就是设计新系统的物理模型； 系统实施：将设计的系统付诸实施的阶段； 系统运行与维护阶段：需要经常进行维护与评价，记录系统运行状态； 消亡阶段； 5 小：系统规划、系统分析、系统设计、系统实施、运行维护 软件生命周期： 可行性分析与项目开发计划 需求分析 概要设计、详细设计 编码、测试 维护","link":"/4204d2c4a428/"},{"title":"Canal 教程","text":"Canal 基础教程 资料引用canal(基于mysql数据库binlog的增量订阅&amp;消费） - 简书 (jianshu.com) 安装MySQL 配置MySQL 开启 binlog 日志 修改 my.cnf 1234567[mysqld]log-bin=mysql-bin # 开启 binlogbinlog-format=ROW # 选择 ROW 模式expire_logs_days = 5 # binlog 有效期 5 天# binlog-rows-query-log-events = true # 在 binlog 日志中存放 SQL 语句，canal 不应开启此选项binlog_row_image = FULL # binlog日志记录所有前镜像和后镜像server_id=1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复 创建 canal 用户 1234CREATE USER canal IDENTIFIED BY 'canal'; GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'canal'@'%';-- GRANT ALL PRIVILEGES ON *.* TO 'canal'@'%' ;FLUSH PRIVILEGES;","link":"/c1088f5c62fd/"},{"title":"ElasticSearch 教程","text":"ElasticSearch 基础教程 安装Docker 安装 ElasticSearch - 知乎 (zhihu.com) 1234567891011121314151617# 镜像拉取docker pull docker.io/elasticsearch:6.5.4# 容器启动docker run -d --name es -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:6.5.4# 进入容器docker exec -it es bash# 安装 IK 分词器# 进入目录cd /usr/share/elasticsearch/plugins/ik# 下载wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.5.4/elasticsearch-analysis-ik-6.5.4.zip# 解压unzip elasticsearch-analysis-ik-7.7.0.zip# 删除压缩包rm -rf elasticsearch-analysis-ik-7.7.0.zip 问题修复ES集群health为yellow解决办法 备份与恢复elasticsearch备份和还原 - 一人一见 - 博客园 (cnblogs.com) 使用12345678# 查询索引 data_assets_test 下的数据curl -XPOST '172.24.3.133:9200/data_assets_test/_search?pretty'# 获取集群索引信息：curl -X GET &quot;172.24.3.133:9200/_cat/indices?v&amp;pretty&quot;# 查看节点curl -X GET &quot;172.24.3.133:9200/_cat/nodes?v&amp;pretty&quot;# 删除索引curl -XDELETE &quot;172.24.3.133:9200/data_assets_test&quot; 参考资料elasticSearch入门-ES入门 Elasticsearch入门，这一篇就够了 Linux安装elasticsearch7.2和kibana7.2最新教程_长草颜团子-CSDN博客_linux安装elasticsearch7 Elasticsearch7.*版本 1.入门 - 简书 (jianshu.com) Elasticsearch通关教程（一）： 基础入门_weixin_33806300的博客-CSDN博客 centos7.x下环境搭建(三)—nodejs安装 - fozero - 博客园 (cnblogs.com) Elasticsearch和Head插件安装 - v-imok - 博客园 (cnblogs.com) linux（centos 7）下安装elasticsearch - head插件(端口占用，防火墙关闭) - 天生一对 - 博客园 (cnblogs.com) GitHub - medcl/elasticsearch-analysis-ik: The IK Analysis plugin integrates Lucene IK analyzer into elasticsearch, support customized dictionary. Linux安装elasticsearch7.2和kibana7.2最新教程_长草颜团子-CSDN博客_linux安装elasticsearch7 Elasticsearch和Head插件安装 - v-imok - 博客园 (cnblogs.com)","link":"/9706489ee644/"},{"title":"Git 教程","text":"Git 基础教程 Linux 安装 Githttps://blog.csdn.net/a1026168656/article/details/83505800 123456789101112131415161718192021# 1 安装 Gityum -y install git# 2 创建 Git 用户useradd git# 3 设置 Git 用户密码passwd git# 4 创建 Git 仓库# 4.1 切换至 Git 用户su - git# 4.2 创建 Git 仓库目录mkdir demo.git# 4.3 切换到 Git 仓库目录cd demo.git/# 4.4 初始化 Git 仓库git init --bare Git 命令首次拉取代码git clone https://gitee.com/hr947x/jhx-pages.git 添加文件进入 Git 版本控制git add --all 提交git commit -m &quot;本次提交修改了什么&quot; 从远程仓仓库更新代码 git pull origin master 把代码推送到远程仓库 git push -u origin master 多仓库12345678910111213141516171819# 查看已有远程仓库git remote -v# 添加多个远程仓库git remote add second http://xxxx/xxx2/xxx.gitgit remote add three http://xxxx/xxx3/xxx.gitgit remote add four http://xxxx/xxx4/xxx.git# 推送代码git push origin mastergit push second mastergit push three mastergit push four master# 移除远程仓库git remote remove origingit remote remove secondgit remote remove threegit remote remove four 本地 git 命令美化编辑用户目录下的 .gitconfig 文件： 12345[user] name = 名字 email = 邮箱[alias] loog = log --pretty=format:'%Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset %s' --abbrev-commit","link":"/32ff698981d1/"},{"title":"Harbor 教程","text":"Harbor 基础教程 资料教程参考网址Docker私有仓库Harbor介绍和部署记录 - 散尽浮华 - 博客园 (cnblogs.com) 须知 Harbor 是基于 docker registry V2 版本，所以 docker 必须大于等于 1.10.0 版本，docker-compose 必须要大于 1.6.0 版本！ 另外，此方法部署 harbor 时，docker 中会启动以下名称的镜像，故如 docker 已有以下名称镜像则需要进行清理，否则部署会失败：harbor-jobservice、nginx、harbor-core、harbor-portal、harbor-db、registryctl、redis、registry、harbor-log 要求 Linux wget docker 架构 部署流程1、下载 harbor 离线安装包Git 地址：Releases · goharbor/harbor (github.com) 1wget https://github.com/goharbor/harbor/releases/download/v2.1.2/harbor-offline-installer-v2.1.2.tgz 2、解压 harbor1tar -zxvf harbor-offline-installer-v2.1.2.tgz 3、调整默认配置进入解压目录，编辑 harbor.yml.tmpl 123456hostname: 修改成 Harbao 部署机自身的 ip 地址harbor_admin_password: harbor 初始管理员密码为 Harbor12345，这里最好修改成自己的密码，默认密码至少 8 位，最好是大小写、数字和特殊字符。data_volume: 镜像存放目录http: http 协议访问端口https: https 协议访问端口，如果配置此项，那么 http 配置会被覆盖log: harbor 日志存放目录 将 harbor.yml.tmpl 重命名为 harbor.yml 另外，在停止 harbor 服务之后，仍然可修改此配置文件，再执行 ./prepare 以达到修改配置的目的 4、执行安装执行目录下 ./install.sh 文件即可。 harbor 的使用启停12345678# 停止docker-compose down -v# 查看日志tail -100 /var/log/harbor/registry.log |grep error# 启动docker-compose up -d# 查看启动情况docker-compose ps login 登录在安装了 docker 的远程主机执行命令： 1docker login ip:端口 基础语法12345678910111213141516# 镜像打标签的命令docker tag 镜像名:标签 私服地址/仓库项目名/镜像名:标签docker tag nginx:1.9.1 ip:端口/api/api:1.0 # 推送到私服的命令docker push 私服地址/仓库项目名/镜像名:标签docker push ip:端口/api/api:1.0 # 从私服拉取镜像的命令docker pull 私服地址/仓库项目名/镜像名:标签docker pull ip:端口/api/api:1.0# 构建容器docker build -t api-docker .# 启动容器docker run -itd -p 23333:23333 -d api-docker Java 打包在 pom.xml 中添加打包插件，对应修改参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;plugin&gt; &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt; &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;configuration&gt; &lt;!-- 基础镜像，来自 dockerhub，如果是私服，需要加上鉴权信息，和 to 下的 auth 节点相同 --&gt; &lt;from&gt; &lt;image&gt;ip:端口/java/java:8&lt;/image&gt; &lt;auth&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;Harbor12345&lt;/password&gt; &lt;/auth&gt; &lt;/from&gt; &lt;!-- 容器相关设置 --&gt; &lt;container&gt; &lt;!-- 创建时间 --&gt; &lt;creationTime&gt;${maven.build.timestamp}&lt;/creationTime&gt; &lt;!-- 放置应用程序内容的容器上的根目录 --&gt; &lt;appRoot&gt;/home/${project.artifactId}&lt;/appRoot&gt; &lt;!--容器在运行时公开的端口 --&gt; &lt;ports&gt;23333&lt;/ports&gt; &lt;!-- 容器中的工作目录 --&gt; &lt;workingDirectory&gt;/home/${project.artifactId}&lt;/workingDirectory&gt; &lt;mainClass&gt;com.demo.api.ApplicationApi&lt;/mainClass&gt; &lt;!-- 指定运行的参数 --&gt; &lt;environment&gt; &lt;spring.profiles.active&gt;prod&lt;/spring.profiles.active&gt; &lt;/environment&gt; &lt;/container&gt; &lt;!-- 构建后的镜像名称以及私服地址、鉴权信息 --&gt; &lt;to&gt; &lt;image&gt;ip:端口/api/api:1.0&lt;/image&gt; &lt;auth&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;Harbor12345&lt;/password&gt; &lt;/auth&gt; &lt;/to&gt; &lt;!--允许非https--&gt; &lt;allowInsecureRegistries&gt;true&lt;/allowInsecureRegistries&gt; &lt;/configuration&gt; &lt;!-- 将jib与mvn构建的生命周期绑定 mvn package自动构造镜像 --&gt; &lt;!-- 打包及推送命令 mvn -DsendCredentialsOverHttp=true clean package --&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;build&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 然后执行命令自动打包上传 mvn -DsendCredentialsOverHttp=true clean package 异常处理connect: connection refused | http: server gave HTTP connect: connection refused http: server gave HTTP response to HTTPS client 请编辑源主机配置文件 vim /etc/docker/daemon.json 的 insecure-registries 12345{ &quot;insecure-registries&quot;: [ &quot;ip:端口&quot; ]} 或 1234567891011{ &quot;registry-mirrors&quot;: [ &quot;https://dockerhub.azk8s.cn&quot;, &quot;https://2b97qcss.mirror.aliyuncs.com&quot;, &quot;https://reg-mirror.qiniu.com&quot;, &quot;http://hub-mirror.c.163.com&quot; ], &quot;insecure-registries&quot;: [ &quot;ip:端口&quot; ]} 再执行 12systemctl daemon-reloadsystemctl restart docker 再次尝试登录即可。 如果使用 http 拉取镜像抛出仓库不受信任异常，执行 vim /etc/docker/daemon.json 在 insecure-registries 添加 https://*.*.*.* 即可。 1234567891011{ &quot;registry-mirrors&quot;: [ &quot;registry.cn-hangzhou.aliyuncs.com&quot;, &quot;https://dockerhub.azk8s.cn&quot;, &quot;https://2b97qcss.mirror.aliyuncs.com&quot;, &quot;https://reg-mirror.qiniu.com&quot; ], &quot;insecure-registries&quot;: [ &quot;*.*.*.*&quot; ]} push 异常unauthorized: unauthorized to access repository: xx/xx, action: push: unauthorized to access repository: xx/xx, action: push 可能是未登录对应私有仓库，建议使用 docker login xx:xx 进行登录，如果登录仍有此现象，请按以下方式尝试： action: push: unauthorized to access repository - InnoLeo - 博客园 (cnblogs.com)","link":"/fda7b3e7c718/"},{"title":"Kettle 教程","text":"Kettle 基础教程 基础 Job：作业，完成整个工作流的控制； 基于步骤； 必须先将当前步骤执行完成，才会执行后续步骤； Transformation：转换，完成针对数据的基础转换 基于数据； 一次性启动所有控件（一个控件一个线程）然后一条记录一条记录逐一流向后续控件； 组件 Spoon：图形化界面； Pan：利用 Pan 可以以命令行的形式调用 Trans； Kitchen：利用 Kitchen 可以使用命令行调用 Job； Carte：轻量级 Web 容器，用于建立专用、远程的 ETL Server；","link":"/406a2c44ee73/"},{"title":"Linux sed 教程","text":"Linux sed 基础教程 引用资料shell脚本——sed详细用法_stan Z的博客-CSDN博客_shell脚本sed sed命令详解+示例_rick_grace的博客-CSDN博客_sed命令","link":"/4e2ca58138aa/"},{"title":"Linux 环境搭建","text":"Linux 环境搭建基础教程 Python卸载卸载 python123456# 卸载 pythonrpm -qa|grep python|xargs rpm -ev --allmatches --nodeps# 删除所有残余文件whereis python |xargs rm -frv#验证删除，返回无结果whereis python 卸载 yum123456# 卸载 yumrpm -qa|grep yum|xargs rpm -ev --allmatches --nodeps# 删除所有残余文件whereis yum |xargs rm -frv# 验证删除，返回无结果whereis yum 安装查看 CentOS 版本1cat /etc/redhat-release 下载 python 安装包镜像下载地址 Index of /7.6.1810/os/x86_64/Packages (centos.org) 安装 python安装地址 Linux误删python导致yum不可用，删除重装方法。 - 北方卧龙 - 博客园 (cnblogs.com) 安装 yum查看已安装的 yum rpm -qa | grep yum python 安装 yum1234wget http://yum.baseurl.org/download/3.2/yum-3.2.28.tar.gztar xvf yum-3.2.28.tar.gzhttps://www.jb51.net/os/RedHat/33569.html GolangLinux下配置Golang开发环境 - 简书 (jianshu.com) rpm 安装 Jdk1、前期准备 FileZilla 或别的 ftp 工具 Linux 服务器 Jdk 这里安装的是 Jdk 8 可进入Jdk 8 官方下载页面下载。 选择 Java SE Development Kit 8u201 分类即可。 为了下面的步骤可以对应，选择 jdk-8u201-linux-x64.rpm。 2、检查是否已经存在 JDK连接 Linux 服务器，使用 java –version 命令，查看是否已经有 Jdk。 3、新建目录使用 mkdir -p /usr/local/app/java 命令新建 Jdk 安装文件夹。（可忽略） 进入目录 cd /usr/local/app/java 4、上传 Jdk便于操作，这里直接使用 FileZilla 上传 Jdk 至第 3 步创建的文件夹中。 5、安装 Jdk安装 Jdk：rpm -ivh jdk-8u201-linux-x64.rpm ivh中， i - install 安装；v - verbose 进度条；h - hash 哈希校验 6、完成此时，运行 java -version 命令结果为： 123java version &quot;1.8.0_201&quot;Java(TM) SE Runtime Environment (build 1.8.0_201-b09)Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode) node下载Node 官方下载地址 选择 LTS 下的 Linux Binaries (x64)：64-bit 将安装包下载至 Linux，解压：tar -xvf node-v16.14.2-linux-x64.tar.xz 移动12345# 移动 node 目录：mv node-v16.14.2-linux-x64 /usr/local/node# 执行文件查看版本：/usr/local/node/bin/node -v 配置环境变量vi /etc/profile 在文件末尾添加：export PATH=$PATH:/usr/local/node/bin 刷新配置：source /etc/profile 配置软连接相当于全局变量，在任何文件夹都能查看版本信息 12ln -s /usr/local/node/bin/node /usr/local/bin/ln -s /usr/local/node/bin/npm /usr/local/bin/ 查看结果12node -vnpm -v wget1yum -y install wget y：安装过程中所有选择均选 yes Git12345# 安装yum -y install git# 查看版本git --version 参考资料Linux 安装python3.7.3 CSDN博客","link":"/13c0826436e5/"},{"title":"Linux 教程","text":"Linux 基础教程 用户操作添加新用户1234567891011useradd &lt;参数&gt; &lt;用户名&gt;-c comment，指定一段注释性描述。-d 目录，指定用户主目录，如果此目录不存在，则同时使用 -m 选项，可以创建主目录。-g 用户组，指定用户所属的用户组。-G 用户组，用户组 指定用户所属的附加组。-s Shell，文件 指定用户的登录 Shell。-u 用户号，指定用户的用户号，如果同时有 -o 选项，则可以重复使用其他用户的标识号。# 新建用户 wwwuseradd –c &quot;普通权限用户&quot; -d /home/www -g www -G docker www 删除用户12345userdel &lt;参数&gt; &lt;用户名&gt;-r 它的作用是把用户的主目录一起删除（包括 /etc/passwd, /etc/shadow, /etc/group等）。userdel -r sam 修改用户12345678usermod &lt;参数&gt; &lt;用户名&gt;常用的选项包括-c, -d, -m, -g, -G, -s, -u 以及 -o 等，这些选项的意义与 useradd 命令中的选项一样，可以为用户指定新的资源值。另外，有些系统可以使用如下选项：-l 新用户名，指定一个新的账号，即将原来的用户名改为新的用户名。usermod -s /bin/ksh -d /home/z –g developer sam此命令将用户 sam 的登录 Shell 修改为 ksh，主目录改为 /home/z，用户组改为 developer。 用户密码设置12345678910111213141516171819202122232425262728passwd &lt;参数&gt; &lt;用户名&gt;-l 锁定口令，即禁用账号。-u 口令解锁。-d 使账号无口令。-f 强迫用户下次登录时修改口令。如果默认用户名，则修改当前用户的口令。例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：代码:$ passwdOld password:******New password:*******Re-enter new password:*******如果是超级用户，可以用下列形式指定任何用户的口令：代码:# passwd samNew password:*******Re-enter new password:*******# 为用户指定空口令passwd -d sam# 锁定某一用户，使其不能登录passwd -l sam 新增用户组12345678910groupadd &lt;参数&gt; &lt;用户组&gt;-g GID，指定新用户组的组标识号（GID）。-o 一般与 -g 选项同时使用，表示新用户组的 GID 可以与系统已有用户组的 GID 相同。# 新增 www 用户组groupadd www# 此命令向系统中增加了一个新组 group2，同时指定新组的组标识号是 101。groupadd -g 101 group2 系统相关12345678# 查看 linux 内核uname -a# 查看操作系统版本cat /proc/version# 查看发行版本cat /etc/redhat-release# 查看 yum 源版本yum --version 跨主机复制文件123456# 将本机文件复制到 168 主机的 /tmp 目录下scp /home/ixdba/etc.tar.gz root@192.168.60.168:/tmpscp /root/images.tar.gz root@172.16.152.19:/r# 将本机文件夹复制到 168 主机的 /tmp 目录下scp -r /home root@192.168.60.168:/tmp 数据盘挂载 df -h 查看磁盘挂载情况 fdisk -l 命令查看要挂载的数据盘名称 格式化新服务器数据盘 mkfs -t ext4 数据盘名称（此处应特别注意不要格式化错盘） 使用mkdir命令创建数据盘挂载点（如：下图中创建/data） vi /etc/fstab 编辑挂载盘，在 fstab 文件中新增一行数据盘配置，配置后保存 使用 mount -a 挂载数据盘 使用 df -h 查看结果 查看文件夹大小1sudo du -sm * | sort -n 文件转换 dos -&gt; unix12345vi 文件# 查看文件格式:set ff:set ff=unix:wq 压缩解压12345678910111213# tar# 解压tar -zxvf xx.tar.gz# 压缩tar -zcvf test.tar.gz test/# zip# 压缩# 解压，把 myfile.zip 文件解压到 /home/sunny/# -o:不提示的情况下覆盖文件;# -d:-d /home/sunny 指明将文件解压缩到/home/sunny目录下。unzip -o -d /home/sunny myfile.zip 登录其他机器1ssh root@192.168.31.27 查看文件夹大小12# 查看根目录du -h --max-depth=1 / 时间123456# 查看时间echo $(date &quot;+%Y-%m-%d %H:%M:%S&quot;)# 查看时间 忽略时区echo $(date -u &quot;+%Y-%m-%d %H:%M:%S&quot;) 引用资料linux 新建用户、用户组 以及为新用户分配权限 - 我的Java路上那些事儿 - BlogJava","link":"/115355ff9fc6/"},{"title":"Maven 教程","text":"Maven 基础教程 Maven安装 Maven1、前期准备 可连接外网的 Linux 服务器 3、使用 wget 下载 Maven安装 wget1yum -y install wget y：安装过程中所有选择均选 yes 4、新建目录使用 mkdir -p /usr/local/app/Maven 命令新建 Jdk 安装文件夹。（可忽略） 进入目录 cd /usr/local/app/Maven 5、下载 Mavenwget http://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.0/binaries/apache-maven-3.6.0-bin.tar.gz 若上面链接失效，请移步 Maven – Download Apache Maven Files 段落中选择 Binary tar.gz archive 右键选择 Link 分类下的 apache-maven-*.*.*-bin.tar.gz 复制链接地址。 使用 wget 命令下载。 6、解压1tar -zxvf apache-maven-3.6.0-bin.tar.gz 记录解压地址1234cd apache-maven-3.6.0pwd[root@localhost apache-maven-3.6.0]# pwd/usr/local/app/Maven/apache-maven-3.6.0 7、配置环境变量Linuxvi /etc/profile 添加环境变量 1234# Mavenexport MAVEN_HOME=你的安装目录export MAVEN_HOMEexport PATH=$PATH:$MAVEN_HOME/bin 保存后 source /etc/profile macOSvi ~/.bash_profile 添加环境变量 12export MAVEN_HOME=/Users/aaron/Mine/Coder/LocalRepositoryexport PATH=$PATH:$MAVEN_HOME/bin 保存后 source ~/.bash_profile 验证结果1234567mvn -version[root@localhost apache-maven-3.6.0]# mvn -versionApache Maven 3.6.0 (97c98ec64a1fdfee7767ce5ffb20918da4f719f3; 2018-10-25T02:41:47+08:00)Maven home: /usr/local/app/Maven/apache-maven-3.6.0Java version: 1.8.0_201, vendor: Oracle Corporation, runtime: /usr/java/jdk1.8.0_201-amd64/jreDefault locale: zh_CN, platform encoding: UTF-8OS name: &quot;linux&quot;, version: &quot;3.10.0-123.el7.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;","link":"/818f1b9fe491/"},{"title":"MongoDB 教程","text":"MongoDB 基础教程 MongoDB 简介NoSQL 数据库（Not Only Sql 非关系型数据库）。C++ 编写，基于分布式文件存储的开源数据库系统。 MongoDB 官网 MongoDB CRUD 操作手册 数据库管理查看所有数据库show dbs; 或者 show databases; 查看当前数据库db; 切换至某数据库use &lt;数据库名称&gt;; 如果此数据库不存在，则新建数据库 删除当前数据库db.dropDatabase(); 集合管理查看所有集合show collections; 创建集合db.createCollection(&quot;&lt;集合名称&gt;&quot;); 删除集合db.&lt;集合名称&gt;.drop(); 基础 CRUD新增向指定集合一次添加一个文档：db.&lt;集合名称&gt;.insertOne(); 12345db.coll.insertOne({ &quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 18, &quot;hobbys&quot;: [&quot;music&quot;, &quot;game&quot;]}) 向指定集合一次添加多个文档：db.&lt;集合名称&gt;.insertMany(); 1234567891011121314db.coll.insertMany( [ { &quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 19, &quot;hobbys&quot;: [&quot;game&quot;] }, { &quot;name&quot;: &quot;Anna&quot;, &quot;age&quot;: 17, &quot;hobbys&quot;: [&quot;movie&quot;, &quot;music&quot;] } ]) 查询基础查询：db.&lt;集合名称&gt;.find(&lt;filter&gt;, &lt;options&gt;); 查询姓名为 Bob 的数据 123db.coll.find({ &quot;name&quot;: &quot;Bob&quot;}) 使用 $in 进行范围查询： 查询爱好包含 games、music 的数据 12345db.coll.find({ &quot;hobbys&quot;: { $in: [&quot;games&quot;, &quot;music&quot;] }}) 用逗号分隔进行多个条件查询： 查询年龄为 18，爱好包含 games、music 的数据 123456db.coll.find({ &quot;age&quot;: 18, &quot;hobbys&quot;: { $in: [&quot;games&quot;, &quot;music&quot;] }}) 使用 $or 表示操作符的条件为 OR 的关系： 查询姓名为 Bob、或者年龄为 17 的数据 1234567db.coll.find({ $or: [{ &quot;name&quot;: &quot;Bob&quot; }, { &quot;age&quot;: 17 }]}) 同时使用 AND 与 OR 查询： 通常情况下，$and 可以省略。 查询姓名为 Tom 或者 爱好为 games、movie 且年龄为 17 的数据 123456789101112db.coll.find({ $or: [{ &quot;name&quot;: &quot;Tom&quot; }, { &quot;hobbys&quot;: { $in: [&quot;games&quot;, &quot;movie&quot;] } }], $and: [{ &quot;age&quot;: 17 }]}) 修改删除了解更多 CRUD 操作","link":"/71a8cfc1fbe2/"},{"title":"MySQL 教程","text":"MySQL 基础教程 基础操作12-- 创建 book 数据，并设置编码与排序规则CREATE DATABASE book CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; 管理用户与权限新建用户123# 新增用户CREATE USER 'users'@'%' IDENTIFIED WITH mysql_native_password BY 'password';CREATE USER 'users'@'%' IDENTIFIED BY 'password'; 修改密码加密方式12345678910111213# 查询用户信息select host,user,plugin,authentication_string from mysql.user;# 编辑用户密码ALTER USER 'users'@'%' IDENTIFIED WITH mysql_native_password BY 'password';ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'password';ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password';# 用户授权grant all privileges on *.* to 'user'@'%';# 刷新使配置生效flush privileges; 授权远程访问12GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION;GRANT ALL PRIVILEGES ON *.* TO 'root'@'192.168.0.77' IDENTIFIED BY 'password' WITH GRANT OPTION; 资料来源 备份与恢复备份参数： –user=root 指定用户； –password=123 指定密码，也可不填写密码，敲下回车后手动输入； –lock-all-tables 备份时锁住所有表，直至备份完成； –lock-tables 备份时锁指定表，直至备份完成； –skip-all-locks 不带锁表语句，可能导致数据不一致； –extended-insert 每个表生成一个 insert 语句，而不是一条数据就生成一条 insert 语句，可有效减少生成备份文件大小； –skip-extended-insert 每条数据生成一条 insert 语句； –complete-insert 生成的 insert 包含列名称； –ignore-table=mysql.user 备份时忽略指定数据库或表； –skip-add-drop-table 不带 DROP TABLE 语句，即不在恢复时删除原表； –skip-comments 不带注释； –skip-disable-keys 不带使表索引失效的语句，可能导致字符集错误； –skip-set-charset 不指定字符集； –no-create-info 不带有 CREATE DATABASE 与 CREATE TABLE 语句； 12mysqldump --host=localhost --user=users --password=password --all-databases &gt; /back.sqlmysqldump --host=localhost --user=uesrs --password=password --databases users &gt; /backUsers.sql 恢复12mysql -h localhost -u root -p &lt; /back.sqlsourced:\\back.sql 二进制恢复：查看是否开启二进制日志：SHOW BINARY LOGS;。 开启二进制日志： 修改配置文件 my.cnf 或 my.ini，在 [mysqld] 配置项下加入下面两行并重启： 123456# 开启日志log-bin# 忽略 mysql 数据库的变动binlog-ignore-db=mysql# 设值 serverIdserver-id=1 查看二进制日志：SHOW BINARY STATUS; 导出二进制文件： 123456# 查询二进制文件位置SHOW VARIABLES WHERE Variable_Name LIKE 'datadir';# 转换为可读文件mysqlbinlog --database=book /var/lib/mysql/34a7f414bf5b-bin.000001 &gt; recovery.txt# 恢复指定的位置节点mysqlbinlog --database=book --stop-position=&quot;7932&quot; /var/lib/mysql/34a7f414bf5b-bin.000001 | mysql --user=xu --password 参考资料 支持 GROUP BY本次启动有效： 123SELECT @@global.sql_mode;set GLOBAL sql_mode = 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION'; 永久有效： 12[mysqld]sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION 时区设置docker 启动： 123456docker run \\-itd \\--restart=always \\-p 3306:3306 \\-e TZ=Asia/Shanghai \\--name mariadb mariadb:10 本次启动有效： 1234567select now();SHOW VARIABLES LIKE &quot;%time_zone%&quot;;set global time_zone = '+8:00';SET time_zone = '+8:00';flush privileges; 时区设置 修改本次连接编码12345678910# 查询编码情况show variables like 'character_set_%';# 设置编码set character_set_client=utf8;set character_set_results=utf8;set character_set_connection=utf8;set character_set_connection=utf8;# 设置编码，与上四条结果相同set names utf8; binlog开启 biglog修改 my.cnf 后重启 MySQL 1234567[mysqld]log-bin=mysql-bin # 开启 binlogbinlog-format=ROW # 选择 ROW 模式expire_logs_days = 5 # binlog 有效期 5 天# binlog-rows-query-log-events = true # 在 binlog 日志中存放 SQL 语句，canal 不应开启此选项binlog_row_image = FULL # binlog日志记录所有前镜像和后镜像server_id=1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复 执行 SQL SHOW VARIABLES LIKE 'log_bin'; 查看是否开启成功 清理 binlog 日志手动删除： 1234567891011121314# 查看日志情况：SHOW MASTER STATUS;SHOW BINARY LOGS;# 删除某个日志文件之前的所有日志文件PURGE BINARY LOGS TO 'mysql-bin.000035';# 删除指定日期以前的日志索引中 binlog 日志文件PURGE MASTER LOGS BEFORE '2022-03-02 00:00:00';# 删除指定日志文件的日志索引中 binlog 日志文件PURGE MASTER LOGS TO 'mysql-bin.000022';# 清理 3 天前 binlog 日志PURGE MASTER LOGS BEFORE DATE_SUB(NOW( ), INTERVAL 3 DAY);# 重置所有的日志RESET MASTER; 设置自动过期： 12345# 查看自动过期时间：SHOW VARIABLES LIKE 'expire_logs_days';# 设置 binlog 多少天过期SET GLOBAL expire_logs_days = 30; 进阶删除重复记录仅保存一条mysql中对数据的去重_L X D.的博客-CSDN博客_mysql数据去重 12345# 选出重复 id 数据SELECT MIN( id ) AS id FROM t_school_basic_info GROUP BY school_code;# 删除DELETE FROM t_school_basic_info WHERE id NOT IN (SELECT dt.id FROM (SELECT MIN( id ) AS id FROM t_school_basic_info GROUP BY school_code) dt); 常见问题处理MySQL 错误：Row size too large (&gt; 8126).mysql5.7 Err 1118 - Row size too large (&gt; 8126)._weixin_33859844的博客-CSDN博客 rpm 安装 MySQL参考资料/var/log/mysqld.log 中找不到临时密码 - pao___pao的博客 - CSDN博客 MySQL service not running on CentOS 7 system centos7下安装mysql5.7（rpm） - wudinaniya的博客 - CSDN博客 1、前期准备 可连接外网的 Linux 服务器 2、卸载 MySql检查 mysql 安装：1rpm -qa | grep mysql 卸载 mysql： 普通卸载：rpm -e mysql 强力卸载（建议）： 1rpm -e --nodeps mysql 卸载 MySQL数据库时，会将其它的依赖文件也删除。 检查 mariadb 安装1rpm -qa | grep mariadb 卸载 mariadb1rpm -e --nodeps 检查出的名称 例如： 1rpm -e --nodeps mariadb-libs-5.5.35-3.el7.x86_64 3、使用 wget 下载 MySQL安装 wget1yum -y install wget y：安装过程中所有选择均选 yes 4、新建目录使用 mkdir -p /usr/local/app/mysql 命令新建 Jdk 安装文件夹。（可忽略） 进入目录 cd /usr/local/app/mysql 5、下载 MySQL这里安装的是 MySQL 5.7.25（适用于 CentOS 7）： 1wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar 若上面链接失效，这里也提供MySql 5.7 官方下载页面地址。 Select Operating System： Cent OS 选项选择 Red Hat Enterprise Linux / Oracle Linux Select OS Version： CentOS 6 选择 Red Hat Enterprise Linux 6 / Oracle Linux 6 (x86, 64-bit) CentOS 7 选择 Red Hat Enterprise Linux 7 / Oracle Linux 7 (x86, 64-bit) Download Packages： 选择 RPM Bundle 。 点击 Download，进入下载页面，滑至底部，右键选择 No thanks, just start my download.复制链接地址。 使用 wget 命令下载： 1wget 链接地址 6、解压1tar -xvf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar 7、安装安装必备依赖： 123yum -y install libaio*yum -y install net-toolsyum -y install perl 请务必依次安装以下 rpm 包 1234rpm -ivh mysql-community-common-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-libs-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-client-5.7.25-1.el7.x86_64.rpmrpm -ivh mysql-community-server-5.7.25-1.el7.x86_64.rpm 8、完成安装A、获取临时密码12grep 'temporary password' /var/log/mysqld.log2019-04-09T13:12:38.587533Z 1 [Note] A temporary password is generated for root@localhost: kS&gt;gQ+xaS4B3 kS&gt;gQ+xaS4B3即为临时密码。（每人均不同） 常见问题：无法获取密码 1234[root@localhost mysql]# grep 'temporary password' /var/log/mysqld.log[root@localhost mysql]# [root@localhost mysql]# grep 'temporary password' /var/log/mysqld.log[root@localhost mysql]# 删除原始数据： rm -rf /var/lib/mysql 重启 mysqld 服务 systemctl restart mysqld 获取临时密码 grep 'temporary password' /var/log/mysqld.log B、运行向导1mysql_secure_installation 修改初始密码：输入刚刚获取的临时密码 12345[root@localhost mysql]# mysql_secure_installationSecuring the MySQL server deployment.Enter password for user root: 设置新密码（输入两次） 12345The existing password for the user account root has expired. Please set a new password.New password: Re-enter new password: 设置验证密码插件：N 123456VALIDATE PASSWORD PLUGIN can be used to test passwordsand improve security. It checks the strength of passwordand allows the users to set only those passwords which aresecure enough. Would you like to setup VALIDATE PASSWORD plugin?Press y|Y for Yes, any other key for No: 提示设置 root user 密码：Y 12Using existing password for root.Change the password for root ? ((Press y|Y for Yes, any other key for No) : 是否删除系统创建的匿名用户：Y 12345678By default, a MySQL installation has an anonymous user,allowing anyone to log into MySQL without having to havea user account created for them. This is intended only fortesting, and to make the installation go a bit smoother.You should remove them before moving into a productionenvironment.Remove anonymous users? (Press y|Y for Yes, any other key for No) : 是否禁止 root 用户远程登录：Y 12345Normally, root should only be allowed to connect from'localhost'. This ensures that someone cannot guess atthe root password from the network.Disallow root login remotely? (Press y|Y for Yes, any other key for No) : 是否删除 test 数据库：Y 123456By default, MySQL comes with a database named 'test' thatanyone can access. This is also intended only for testing,and should be removed before moving into a productionenvironment.Remove test database and access to it? (Press y|Y for Yes, any other key for No) : 重载权限表：Y 1234Reloading the privilege tables will ensure that all changesmade so far will take effect immediately.Reload privilege tables now? (Press y|Y for Yes, any other key for No) : 完整安装流程请直接划至底部 9、启动 mysql 服务1service mysqld start 10、登录 mysql1mysql -uroot -p你的密码 如： 1mysql -uroot -proot 完整安装 mysql 流程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[root@localhost mysql]# mysql_secure_installationSecuring the MySQL server deployment.Enter password for user root: The existing password for the user account root has expired. Please set a new password.New password: Re-enter new password: VALIDATE PASSWORD PLUGIN can be used to test passwordsand improve security. It checks the strength of passwordand allows the users to set only those passwords which aresecure enough. Would you like to setup VALIDATE PASSWORD plugin?Press y|Y for Yes, any other key for No: nUsing existing password for root.Change the password for root ? ((Press y|Y for Yes, any other key for No) : yNew password: Re-enter new password: By default, a MySQL installation has an anonymous user,allowing anyone to log into MySQL without having to havea user account created for them. This is intended only fortesting, and to make the installation go a bit smoother.You should remove them before moving into a productionenvironment.Remove anonymous users? (Press y|Y for Yes, any other key for No) : ySuccess.Normally, root should only be allowed to connect from'localhost'. This ensures that someone cannot guess atthe root password from the network.Disallow root login remotely? (Press y|Y for Yes, any other key for No) : ySuccess.By default, MySQL comes with a database named 'test' thatanyone can access. This is also intended only for testing,and should be removed before moving into a productionenvironment.Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y - Dropping test database...Success. - Removing privileges on test database...Success.Reloading the privilege tables will ensure that all changesmade so far will take effect immediately.Reload privilege tables now? (Press y|Y for Yes, any other key for No) : ySuccess.All done!","link":"/65411b5b7fd1/"},{"title":"MySQL 千万级数据查询优化.md","text":"MySQL 千万级数据查询优化方法 准备数据表school - 用于连表查询 12345678CREATE TABLE `school` ( `school_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '学校 id', `school_name` varchar(32) DEFAULT NULL COMMENT '学校名称', `district_code` varchar(16) DEFAULT NULL COMMENT '区县 code', `city_code` varchar(16) DEFAULT NULL COMMENT '地市 code', `status` tinyint(1) DEFAULT NULL COMMENT '数据状态 1 0', PRIMARY KEY (`school_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC; student_myisam - 用于 MyISAM 引擎测试 123456789101112131415CREATE TABLE `student_myisam` ( `student_id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id', `name` varchar(32) DEFAULT NULL COMMENT '姓名', `gender` tinyint(1) DEFAULT NULL COMMENT '性别', `school_id` int(11) DEFAULT NULL COMMENT '学校 id', `district_code` varchar(16) DEFAULT NULL COMMENT '区县 code', `city_code` varchar(16) DEFAULT NULL COMMENT '地市 code', `hobby` varchar(255) DEFAULT NULL COMMENT '爱好', `chinese_score` int(11) DEFAULT NULL COMMENT '语文成绩', `math_score` int(11) DEFAULT NULL COMMENT '数学成绩', `english_score` int(11) DEFAULT NULL COMMENT '英语成绩', `grade` int(11) DEFAULT NULL COMMENT '年级', `status` tinyint(1) DEFAULT NULL COMMENT '数据状态 1 0', PRIMARY KEY (`student_id`) USING BTREE) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC; student_innodb - 用于 InnoDB 引擎测试 123456789101112131415CREATE TABLE `student_innodb` ( `student_id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id', `name` varchar(32) DEFAULT NULL COMMENT '姓名', `gender` tinyint(1) DEFAULT NULL COMMENT '性别', `school_id` int(11) DEFAULT NULL COMMENT '学校 id', `district_code` varchar(16) DEFAULT NULL COMMENT '区县 code', `city_code` varchar(16) DEFAULT NULL COMMENT '地市 code', `hobby` varchar(255) DEFAULT NULL COMMENT '爱好', `chinese_score` int(11) DEFAULT NULL COMMENT '语文成绩', `math_score` int(11) DEFAULT NULL COMMENT '数学成绩', `english_score` int(11) DEFAULT NULL COMMENT '英语成绩', `grade` int(11) DEFAULT NULL COMMENT '年级', `status` tinyint(1) DEFAULT NULL COMMENT '数据状态 1 0', PRIMARY KEY (`student_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC; 数据样例数据（数据伪造可自行代码批量伪造，也可以使用阿里云数据管理 DMS 工具进行批量新增）： 12345678# school - 伪造 10000 条数据INSERT INTO `canal_a`.`school` (`school_id`, `school_name`, `district_code`, `city_code`, `status`) VALUES (1, '青羊区第1学校', '510105', NULL, 1);# student_innodb - 伪造 40000000 条数据INSERT INTO `canal_a`.`student_innodb` (`student_id`, `name`, `gender`, `school_id`, `district_code`, `city_code`, `hobby`, `chinese_score`, `math_score`, `english_score`, `grade`, `status`) VALUES (1, '屠娣华', 0, 8672, '510521', NULL, '国际象棋,举重,拆电风扇,滑旱冰', 57, 13, 59, 1, 1);# student_myisam 数据与 student_innodb 一致INSERT INTO student_myisam SELECT * FROM student_innodb; 测试COUNTMyISAM 12345678# 耗时 0.018sSELECT COUNT(1) FROM student_myisam;# 耗时 0.017sSELECT COUNT(*) FROM student_myisam;# 耗时 0.018sSELECT COUNT(student_id) FROM student_myisam;# 耗时 8.909sSELECT COUNT(status) FROM student_myisam; InnoDB 12345678# 耗时 11.990sSELECT COUNT(1) FROM student_innodb;# 耗时 11.808sSELECT COUNT(*) FROM student_innodb;# 耗时 12.254sSELECT COUNT(student_id) FROM student_innodb;# 耗时 12.461sSELECT COUNT(status) FROM student_innodb; 使用 EXPLAIN 对 SQL 进行分析： MyISAM 中 COUNT(1)，COUNT(*)，COUNT(主键) 可直接读取，因为 MyISAM 自身维护了一个全表数据行数的字段。COUNT(status) 时进行全表扫描； InnoDB 中 COUNT(1)，COUNT(*)，COUNT(主键) 会走索引，而 COUNT(status) 则进行全表扫描； 条件查询","link":"/7886b7864b5d/"},{"title":"Nacos 教程","text":"Nacos 基础教程 准备 Linux docker docker-compose MySQL 部署新建数据库新建 nacos 数据库，执行 SQL，SQL 地址：点击此处 启动容器参考官方文档「单机模式 Derby」 资料微服务配置中心 Nacos Docker 部署 - 简书","link":"/f8c370f71aa5/"},{"title":"Redis 教程","text":"Redis 基础命令 基础命令12# 登录redis-cli -h 主机 -p 端口 -n 数据库 -a 密码","link":"/b24c6f0b65ab/"},{"title":"TomCat 教程","text":"TomCat 基本操作 安装 TomCat前置条件： wget 1、新建目录使用 mkdir -p /usr/local/app/Tomcat 命令新建 Tomcat 安装文件夹。（可忽略） 进入目录 cd /usr/local/app/Tomcat 2、下载 Tomcat这里安装的是 Tomcat 8.5.39： 1wget http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.39/bin/apache-tomcat-8.5.39.tar.gz 若上面链接失效，这里也提供 Tomcat 8.5.39 官方下载页面 地址。 选择 Core 下对应版本即可 3、解压1tar apache-tomcat-8.5.39.tar.gz 4、启动 Tomcat进入 Tomcat 解压目录下的 bin 文件夹中执行命令：startup.sh 如果您完全遵守上述操作，可直接执行命令启动 Tomcat： 1/usr/local/app/Tomcat/apache-tomcat-8.5.39/bin/startup.sh 5、修改 Tomcat 默认端口部署项目至 Tomcat 后发现每次访问都需要 在网址后面添加 8080 端口才能访问. 我们只需要修改 Tomcat 配置文件： 1vim /usr/local/app/Tomcat/apache-tomcat-8.5.39/conf/server.xml 修改端口： 123&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;","link":"/cf310d2827dd/"},{"title":"docker 教程","text":"docker 基础教程 常用默认情况下 docker 的存放位置为: /var/lib/docker 安装CentOS12345678# 安装依赖包sudo yum install -y yum-utils device-mapper-persistent-data lvm2# 设置阿里云镜像源sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 安装 docker-cesudo yum install -y docker-ce Ubuntu123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 卸载旧版本# 方式一sudo apt-get remove docker docker-engine docker.io containerd runc# 方式二sudo apt-get purge dockersudo apt-get purge docker-cesudo apt-get remove -y docker-*# 删除资源文件（慎重：这是镜像和容器的默认存储位置，不要误删）sudo rm -rf /var/lib/docker# 检查软件更新sudo apt-get update# 允许 apt 通过 https 使用 repository 安装软件包sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common# 添加 docker 官方 GPG keysudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# 国内阿里云版sudo curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add -# 验证 key 的指纹sudo apt-key fingerprint 0EBFCD88# 正常输出为：# pub rsa4096 2017-02-22 [SCEA]# 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88# uid [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;# sub rsa4096 2017-02-22 [S]# 添加稳定版 repositorysudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot;# 国内阿里云版：sudo add-apt-repository \\ &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot;# 检查软件更新sudo apt-get update# 最新版本的 docker ce 和 containerdsudo apt-get install docker-ce docker-ce-cli containerd.io# 查看可获取的版本apt-cache madison docker-cesudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io# 升级版本sudo apt-get update 额外配置12345678910# 验证安装结果docker --versionsudo docker run hello-world# 将非 root 用户加入 docker 组，以允许免 sudo 执行 dockersudo gpasswd -a 用户名 docker# 设置开机自启动并启动 docker-ce（安装成功后默认已设置并启动，可忽略）sudo systemctl enable dockersudo systemctl start docker 基本命令docker 命令123456789101112131415161718192021# systemctl 方式# 守护进程重启sudo systemctl daemon-reload# 重启 docker 服务sudo systemctl restart docker# 关闭 dockersystemctl stop docker.socketsystemctl stop docker.service# service 方式# 重启 docker 服务sudo service docker restart# 关闭 dockersudo service docker stop# 刷新 daemon 配置systemctl daemon-reload# 查看 docker 日志sudo dockerd --debugsudo systemctl status docker.service 镜像操作123456789101112131415161718192021# 构建镜像docker build -t sentinel-dashboard:1.8.3 .# 查看全部镜像docker images# 删除指定镜像docker rmi &lt;镜像 id&gt;# 删除 none 镜像docker image prune# 重命名镜像docker tag [镜像id] [新镜像名称]:[新镜像标签]# 导出镜像docker save image_id &gt; /home/images.tar image_name:versiondocker save -o /home/images.tar image_name:version# 导入镜像docker load &lt; /home/images.tar 容器操作启动容器执行命令 docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7.29 -d docker 容器后台运行 -i 以交互模式运行容器，通常与 -t 同时使用； -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用； -p 指定端口映射（宿主机端口:容器端口） --name 为容器指定一个名称 容器操作12345678910111213141516171819202122232425262728# 查看运行中的容器docker ps# 查看运行中的容器，格式化：docker ps --format &quot;table {{.ID}}\\t{{.Names}}\\t{{.Ports}}\\t{{.Status}}&quot;# 查看全部容器docker ps -a# 查看某容器日志docker logs -f &lt;容器ID&gt;# 进入容器docker exec -it &lt;容器ID&gt; /bin/bash# 进入容器（支持中文输入）docker exec -it &lt;容器ID&gt; env LANG=C.UTF-8 bash# 查看容器配置信息docker inspect &lt;容器ID&gt;# 查看容器挂载目录docker inspect 891 | grep Mounts -A 20# 导出docker export &lt;容器ID&gt; &gt; /home/export.tar# 导入docker import - busybox-1-export:latest 批量操作1234567891011# 启动所有容器docker start $(docker ps -a | awk '{ print $1}' | tail -n +2)# 关闭所有容器docker stop $(docker ps -a | awk '{ print $1}' | tail -n +2)# 删除所有容器docker rm $(docker ps -a | awk '{ print $1}' | tail -n +2)# 删除所有镜像docker rmi $(docker images | awk '{print $3}' |tail -n +2) 文件拷贝123docker cp &lt;容器ID&gt;:/back.sql /home/back.sqlsudo docker cp /home/back.sql &lt;容器ID&gt;:/back.sql network123456789101112# 查看已有网络 docker network ls# 创建网络docker network create network_1docker network create --subnet=172.16.0.0/16 network_1# 删除网络docker network rm network_1# 查看网络中链接的容器docker network inspect network_1 高级磁盘清理docker小技巧-清理未使用空间_LoveSummer-CSDN博客_docker 删除无用volume 1234567891011121314151617# 查看占用：docker system df# 安全地移除停止的容器、未使用的 networks 和 dangling images：docker system prune# 删除与正在运行的容器没有关联的任何镜像（谨慎使用）docker system prune -a# 查看所有 volumedocker volume prune# 列出未使用的 volumedocker volume ls -qf dangling=true# 删除未使用的 volumedocker volume rm $(docker volume ls -qf dangling=true) 目录挂载（有风险）12345678910111213141516# 查看镜像存放目录docker info | grep &quot;Docker Root Dir&quot;# 停止 docker 服务systemctl stop docker.service# 在挂载的磁盘目录下创建存放镜像目录mkdir -p /data/var/lib# 迁移镜像文件mv /var/lib/docker /data/var/lib/docker# 链接到原目录ln -s /data/var/lib/docker /var/lib/docker 提交镜像1234# docker tag 已有镜像:版本 新镜像docker tag xxx/xxx/jre8:latest jre8# 推送docker push 192.168.6.14:59418/test/nacos-v3.0 docker-compose安装123456789101112# 下载 docker-compose# GitHub:sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose# daocloudsudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose# 添加可执行权限sudo chmod +x /usr/local/bin/docker-compose# 测试安装结果docker-compose --version 常用指令123456# 查看所有运行中的 docker-composedocker-compose ls# 停止制定服务docker-compose stop jenkins# 启动服务 -d：后台运行docker-compose up -d Swarm 集群12345678# 查看服务列表docker service ls# 查看具体服务doceker service ps 服务名# 查看具体服务详细信息docker service ps --no-trunc 服务名# 强制重启服务docker service update --force 服务名 node 12# 查看节点列表docker node ls Dockerfile打包镜像（执行同目录 Dockerfile）： docker build -t sentinel:1.8.3 . 问题处理Error response from daemonError response from daemon: Unknown runtime specified docker-runc 1grep -rl 'docker-runc' /data/var/lib/docker/containers/ | xargs sed -i 's/docker-runc/runc/g' http: server gave HTTPhttp: server gave HTTP response to HTTPS client 报错http: server gave HTTP response to HTTPS client - 火星小编 - 博客园 (cnblogs.com) 各组件镜像nginx12345678docker run \\ -p 80:80 \\ -itd \\ --restart=always \\ -v /home/www/docker/nginx/html:/usr/share/nginx/html \\ -v /home/www/docker/nginx/log:/var/log/nginx \\ -v /home/www/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\ --name nginx_1.19.6 nginx:1.19.6 相关文件位置： 日志位置：/var/log/nginx/配置文件位置：/etc/nginx/项目位置：/usr/share/nginx/html默认配置：/etc/nginx/nginx.conf 123456789101112131415161718192021222324252627user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events { worker_connections 1024;}http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' '$status $body_bytes_sent &quot;$http_referer&quot; ' '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf;} redis123456docker run \\ -p 6379:6379 \\ -itd \\ --restart=always \\ --name redis_6.2 redis:6.2-rc1 \\ --requirepass &quot;yZtDW2LNFSUhDAWy2diV&quot; fastdfsdocker安装fastdfs与java客户端测试 - dehigher - 博客园 (cnblogs.com) 拉取镜像：docker pull morunchang/fastdfs 创建并启动 tracker 容器：docker run -d --name=tracker -v /home/fastdfs_docker/fdfs/tracker:/data/fast_data --privileged=true --net=host morunchang/fastdfs sh tracker.sh 创建并启动 storage 容器：docker run -d --name=storage -v /home/fastdfs_docker/fdfs/storage_data:/data/fast_data --privileged=true --net=host -e TRACKER_IP=175.24.106.41:22122 -e GROUP_NAME=group1 morunchang/fastdfs sh storage.sh memcached12345docker run \\ -p 11211:11211 \\ -itd \\ --restart=always \\ --name memcache_1.6.9 memcached:1.6.9 nexus3123456789101112# 代码拉取docker pull sonatype/nexus3:3.29.0# 启动docker run \\ -itd \\ -p 8081:8081 \\ -v /data/nexus-data:/var/nexus-data \\ --restart=always \\ --privileged=true \\ -e INSTALL4J_ADD_VM_PARAMS=&quot;-Xms2g -Xmx2g -XX:MaxDirectMemorySize=3g -Djava.util.prefs.userRoot=/var/nexus-data&quot; \\ --name nexus_3 sonatype/nexus3:3.29.0 rabbitmq12345678docker run \\ -itd \\ -p 5672:5672 \\ -p 5673:15672 \\ -e RABBITMQ_DEFAULT_USER=admin \\ -e RABBITMQ_DEFAULT_PASS=12345 \\ --restart=always \\ --name rabbitmq_3.8 rabbitmq:3.8-rc-management Java 容器应用设置环境变量123456docker run -itd -p 8080:8080 --network host \\ --env=&quot;spring.rabbitmq.username=admin&quot; \\ --env=&quot;spring.rabbitmq.password=12345&quot; \\ --env=&quot;spring.redis.host=192.168.1.149&quot; \\ --env=&quot;spring.redis.port=56379&quot; \\ --name MicroService-a 127.0.0.1:59418/a/charge:1.0 MariaDB12345678910docker run \\ -itd \\ --restart=always \\ -p 3306:3306 \\ -v /home/www/docker/mysql/logs:/logs \\ -v /home/www/docker/mysql/data:/var/lib/mysql \\ -v /home/www/docker/mysql/conf/custom.cnf:/etc/mysql/mariadb.conf.d/custom.cnf \\ -e MYSQL_ROOT_PASSWORD=12345 \\ -e TZ=Asia/Shanghai \\ --name mariadb_10 mariadb:10 jenkins基于Docker+Jenkins实现自动化部署 - 明天,你好啊 - 博客园 (cnblogs.com) sentinel自建镜像下载最新 jar 包：Releases · alibaba/Sentinel wget https://github.com/alibaba/Sentinel/releases/download/v1.8.0/sentinel-dashboard-1.8.0.jar docker file sentinel 配置参考 12345FROM java:8MAINTAINER xiaoxuuuADD /sentinel-dashboard-1.8.3.jar /sentinel.jarEXPOSE 8080ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;-Duser.timezone=GMT+08&quot;, &quot;-Dserver.port=8080&quot;, &quot;-Dcsp.sentinel.dashboard.server=localhost:8080&quot;, &quot;-Dproject.name=sentinel&quot;, &quot;sentinel.jar&quot;] 使用已有镜像xiaoxuuu/sentinel - Docker Image | Docker Hub 123456docker run -d \\ --restart=always \\ -p 8080:8080 \\ --env=&quot;--auth.username=sentinel&quot; \\ --env=&quot;--auth.password=sentinel&quot; \\ --name sentinel_1.8.3 xiaoxuuu/sentinel:1.8.3 访问地址：ip:8858 登录账号：sentinel/sentinel Seata123456789docker run \\ -itd \\ --restart=always \\ -p 8091:8091 \\ -e SEATA_PORT=8091 \\ -e SEATA_IP=192.168.0.124 \\ -e SEATA_CONFIG_NAME=file:/root/seata/config/registry \\ -v /home/www/docker/seata/conf/:/root/seata/config \\ --name seata_1.4.1 seataio/seata-server:1.4.1 入门教程 初始目录：/seata-server/resources/registry.conf GitLab123456789docker run \\ -itd \\ --restart always \\ -p 9980:80 \\ -p 9922:22 \\ -v /home/www/docker/gitlab/config:/etc/gitlab \\ -v /home/www/docker/gitlab/logs:/var/log/gitlab \\ -v /home/www/docker/gitlab/data:/var/opt/gitlab \\ --name gitlab_13.9.0 gitlab/gitlab-ce:13.9.0-ce.0 Nacos123456docker run \\ -itd \\ -m 2048M \\ -p 8848:8848 \\ --env MODE=standalone \\ --name nacos_1.2.1 nacos/nacos-server:1.2.1 Canal镜像：canal/canal-server - Docker Image | Docker Hub 快速上手：QuickStart · alibaba/canal Wiki (github.com) 1234567docker run \\ -itd \\ -p 11119:11111 \\ -v /root/docker/canal/logs:/home/admin/canal-server/logs \\ -v /root/docker/canal/conf/canal.properties:/home/admin/canal-server/conf/canal.properties \\ -v /root/docker/canal/conf/instance.properties:/home/admin/canal-server/conf/example/instance.properties \\ --name canal_1.1.5 canal/canal-server:v1.1.5 instance.properties 配置： 123456789101112131415161718## mysql serverIdcanal.instance.mysql.slaveId = 1234#position info，需要改成自己的数据库信息canal.instance.master.address = 127.0.0.1:3306 canal.instance.master.journal.name = canal.instance.master.position = canal.instance.master.timestamp = #canal.instance.standby.address = #canal.instance.standby.journal.name =#canal.instance.standby.position = #canal.instance.standby.timestamp = #username/password，需要改成自己的数据库信息canal.instance.dbUsername = canal canal.instance.dbPassword = canalcanal.instance.defaultDatabaseName =canal.instance.connectionCharset = UTF-8#table regexcanal.instance.filter.regex = .\\*\\\\\\\\..\\* AliYunDriver123456789docker run \\ -itd \\ --restart=always \\ -e TZ=&quot;Asia/Shanghai&quot; \\ -e ALIYUNDRIVE_REFRESH_TOKEN=&quot;token&quot; \\ -e ALIYUNDRIVE_AUTH_PASSWORD=&quot;admin&quot; \\ -e JAVA_OPTS=&quot;-Xmx1g&quot; \\ -p 60001:8080 \\ --name webdav-aliyundriver dovorluthien/aliyundriver-webdav","link":"/e4212b760e63/"},{"title":"macOS 环境搭建","text":"macOS 环境搭建基础教程 JDK前期准备 JDK 这里安装的是 JDK 8 可进入Jdk 8 官方下载页面下载。 选择 macOS 分类即可。 为了下面的步骤可以对应，选择 jdk-8u321-macosx-x64.dmg。 安装 JDK安装 JDK：jdk-8u321-macosx-x64.dmg 配置环境变量参照此路径查找安装的 JDK 路径：/Library/Java/JavaVirtualMachines/jdk1.8.0_321.jdk vi ~/.bash_profile 添加环境变量 123export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_321.jdk/Contents/Home export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin 保存后 source ~/.bash_profile 检查结果此时，运行 java -version 命令结果为： 123java version &quot;1.8.0_201&quot;Java(TM) SE Runtime Environment (build 1.8.0_201-b09)Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)","link":"/9d30f1f85362/"},{"title":"工作中遇到过的问题","text":"工作遇到的疑难问题 无法关闭 Tomcat问题描述执行 ./shutdown.sh 命令关闭 Tomcat 时出现以下错误： 123456789101112131415161718192021222324252627[root@localhost bin]# ./shutdown.sh Using CATALINA_BASE: /usr/local/app/Tomcat/apache-tomcat-8.5.39Using CATALINA_HOME: /usr/local/app/Tomcat/apache-tomcat-8.5.39Using CATALINA_TMPDIR: /usr/local/app/Tomcat/apache-tomcat-8.5.39/tempUsing JRE_HOME: /usrUsing CLASSPATH: /usr/local/app/Tomcat/apache-tomcat-8.5.39/bin/bootstrap.jar:/usr/local/app/Tomcat/apache-tomcat-8.5.39/bin/tomcat-juli.jar四月 10, 2019 10:18:20 上午 org.apache.catalina.startup.Catalina stopServer严重: Could not contact [localhost:[8005]]. Tomcat may not be running.四月 10, 2019 10:18:20 上午 org.apache.catalina.startup.Catalina stopServer严重: Catalina.stop: java.net.ConnectException: 拒绝连接 (Connection refused) at java.net.PlainSocketImpl.socketConnect(Native Method) at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188) at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392) at java.net.Socket.connect(Socket.java:589) at java.net.Socket.connect(Socket.java:538) at java.net.Socket.&lt;init&gt;(Socket.java:434) at java.net.Socket.&lt;init&gt;(Socket.java:211) at org.apache.catalina.startup.Catalina.stopServer(Catalina.java:504) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.catalina.startup.Bootstrap.stopServer(Bootstrap.java:406) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:498) 问题原因推测是 8080 端口被占用导致无法关闭 使用 netstat -atpn | grep 8080 查看 12[root@localhost bin]# netstat -atpn | grep 8080tcp6 0 0 :::8080 :::* LISTEN 49606/java 发现端口被 PID 为 49660 的进程所占用。 执行命令 kill -9 49606 强行结束 PID 为 49606 的进程。 再次尝试关闭，成功。 java.sql.SQLException: The table ‘xxx’ is full1234 Cause: java.sql.BatchUpdateException: The table 'xxx' is full; uncategorized SQLException; SQL state [HY000]; error code [1114]; The table 'xxx' is full; nested exception is java.sql.BatchUpdateException: The table 'xxx' is full] with root causejava.sql.SQLException: The table 'xxx' is full Caused by: java.sql.SQLException: The table ‘XXX’ is full（mysql the table is full）_三少说-CSDN博客","link":"/cdc83edbcd8a/"},{"title":"IO","text":"IO 面试题 资料JAVA IO与NIO - 掘金 (juejin.cn) NIO - 掘金 (juejin.cn) 基础BIO NIO AIOBIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。 NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。 AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。 IO 相关♥Java IO知识体系详解♥ | Java 全栈知识体系 (pdai.tech) Unix IO 模型简介 阻塞式 I/O：应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回，阻塞的过程中，其它程序还可以执行。不消耗 CPU 时间，这种模型的执行效率会比较高。 非阻塞式 I/O：应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询(polling)。由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。 I/O 复用：它可以让单个进程具有处理多个 I/O 事件的能力。又被称为事件驱动 I/O。I/O 复用不需要进程线程创建和切换的开销，系统开销更小。 信号驱动 I/O：相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。 异步 I/O：异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。 BIO blocking IO 应用程序向操作系统请求网络 IO 操作，这时应用程序会一直等待； 另一方面，操作系统收到请求后，也会等待，直到网络上有数据传到监听端口； 操作系统在收集数据后，会把数据发送给应用程序； 最后应用程序受到数据，并解除等待状态。 多路复用 IO 的优缺点 不用再使用多线程来进行 IO 处理了(包括操作系统内核 IO 管理模块和应用程序进程而言)。当然实际业务的处理中，应用程序进程还是可以引入线程池技术的 同一个端口可以处理多种协议，例如，使用 ServerSocketChannel 测测的服务器端口监听，既可以处理 TCP 协议又可以处理 UDP 协议。 操作系统级别的优化：多路复用 IO 技术可以是操作系统级别在一个端口上能够同时接受多个客户端的 IO 事件。同时具有之前我们讲到的阻塞式同步 IO 和非阻塞式同步 IO 的所有特点。Selector 的一部分作用更相当于“轮询代理器”。 都是同步 IO: 目前我们介绍的阻塞式 IO、非阻塞式 IO 甚至包括多路复用 IO，这些都是基于操作系统级别对“同步 IO”的实现。我们一直在说“同步 IO”，一直都没有详细说，什么叫做“同步 IO”。实际上一句话就可以说清楚：只有上层(包括上层的某种代理机制)系统询问我是否有某个事件发生了，否则我不会主动告诉上层系统事件发生了。 代码递归读取文件夹1234567891011121314151617181920public static void listFile(String path) { // 因为下面的 new File 如果 path 为空，会报异常 if (path == null) { return; } File[] files = new File(path).listFiles(); if (files == null) { return; } for(File file : files) { if (file.isFile()) { System.out.println(file.getName()); } else if (file.isDirectory()) { System.out.println(&quot;Directory:&quot; + file.getName()); listFile(file.getPath()); } else { System.out.println(&quot;Error&quot;); } }}","link":"/1926f8177e9e/"},{"title":"Java 新特性","text":"Java 新特性 Java 8JDK 8 升 JDK 11 重要特性 函数编程 Lambda 表达式 Optional 类 default 方法 类型注解 重复注解 类型推断优化 JRE 精简 LocalDate/LocalDateTime JavaFx 2.0 移除 Permgen StampedLock 其它更新: 字符串，base64 Java 9正式版 模块系统：JDK 被重新组织成 94 个模块。可以创建出只包含所依赖的 JDK 模块的自定义运行时镜像。极大的减少 Java 运行时环境的大小。镜像的减少节省很多存储空间和带宽资源； 在集合上，JDK 9 增加 了 List.of(&quot;Hello&quot;, &quot;World&quot;)、Set.of(1, 2, 3)、Map.of(&quot;Hello&quot;, 1, &quot;World&quot;, 2) 等工厂方法来创建不可变集合； Stream 中增加了新的方法 ofNullable、dropWhile、takeWhile 和 iterate; Collectors 中增加了新的方法 filtering 和 flatMapping; Optional 类中新增了 ifPresentOrElse、or 和 stream 等方法 平台日志 API：Java 9 允许为 JDK 和应用配置同样的日志实现。 统一 JVM 日志：JVM 有了统一的日志记录系统，可以使用新的命令行选项 -Xlog 来控制 JVM 上 所有组件的日志记录； 允许在接口中使用私有方法； Java 10正式版 局部变量类型推断：使用保留字 var，局限于具有初始化器的局部变量、增强型 for 循环中的索引变量以及在传统 for 循环中声明的局部变量； 统一的垃圾回收接口：全新 GC 接口，允许以混合搭配方式重复使用现有代码，并且能够保持代码更加干净、整洁，便于排查收集器问题； 整合 JDK 代码仓库：root、corba、hotspot、jaxp、jaxws、jdk、langtools、nashorn 被整合至一个 Mercurial 库中； 并行全垃圾回收器 G1：同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量 Java 11JDK 11 升 JDK 17 重要特性 正式版 标准 HTTP Client 升级：Http Client 几乎被完全重写，并且现在完全支持异步非阻塞。 Epsilon 低开销垃圾回收器：目标一个控制内存分配，但是不执行任何实际的垃圾回收器。它提供一个完全消极的 GC 实现，分配有限的内存资源，最大限度的降低内存占用和内存吞吐延迟时间。 Lambda 表达式中使用局部变量类型推断：允许开发者在 Lambda 表达式中使用 var 进行参数声明。 支持 TLS 1.3 协议； 预览版 ZGC 可伸缩低延迟垃圾收集器（预览版）：GC 停顿时间不超过 10ms，即能处理几百 MB 的小堆，也能处理几个 TB 的大堆等，仅限 Linux x64 平台； Java 12正式版 G1 归还不使用的内存：改进 G1 垃圾收集器，以便在不活动时将 Java 堆内存归还给操作系统； G1 的可中断 mixed GC：将 Mixed GC 集拆分为强制部分和可选部分，使 G1 垃圾收集器更有效地中止垃圾收集过程； 预览版 Shenandoah 低暂停时间垃圾收集器（实验）：性能几乎与 ZGC 相同 ZGC 是Oracle JDK 的。而 Shenandoah 只存在于 OpenJDK 中 Switch 表达式； Java 13正式版 Socket API 重构：为 Socket API 带来了新的底层实现方法，并且在 Java 13 中是默认使用新的 Socket 实现，使其易于发现并在排除问题同时增加可维护性； 预览版 增强 ZGC：默认开启内存释放功能，支持最大堆大小为 16TB； Switch 表达式扩展； 文本块； Java 14正式版 Switch 表达式（正式版）； 删除 CMS 垃圾回收器； 改进 NullPointerExceptions 提示信息：更易于定位多层级调用 null 位置 shoopingcart.buy.book.id = 99; 预览版 instanceof 模式匹配； ZGC（预览版）支持 MacOS、Windows； 文本块（第二预览版本） Records 类型：当用 record 来声明一个类时，效果有些类似 Lombok 的 @Data 注解，该类将自动拥有下面特征： 拥有一个构造方法 获取成员属性值的方法：name()、age() hashCode() 方法和 equals() 方法 toString() 方法 类对象和属性被 final 关键字修饰，不能被继承，类的示例属性也都被 final 修饰，不能再被赋值使用。 还可以在 record 声明的类中定义静态属性、方法和示例方法。 不能在 record 声明的类中定义示例字段，类也不能声明为抽象类等。 Java 15正式版 ZGC 可伸缩低延迟垃圾收集器； 文本块； Shenandoah 低暂停时间垃圾收集器：适用于高吞吐和大内存场景，不适合高实时性场景 预览版 隐藏类：隐藏类不能直接被其他类的字节码使用，只能在运行时生成类并通过反射间接使用它们； 禁用偏向锁定：准备禁用和废除偏向锁，在 JDK 15 中，默认情况下禁用偏向锁，并弃用所有相关的命令行选项； Records 类型：JDK14 提出； 密封的类和接口：防止其他类或接口扩展或实现它们； Java 16正式版 instanceof 模式匹配； Records (正式版)：JDK14、JDK15 预览； @Deprecated 增强：会在编译期和运行期产生警告，甚至是异常； ZGC 并发线程处理：从安全点转移到一个并发阶段，甚至在大堆上也允许在毫秒内暂停 GC 安全点。消除 ZGC 垃圾收集器中最后一个延迟源可以极大地提高应用程序的性能和效率； 弹性元空间：可将未使用的 HotSpot 类元数据（即元空间，metaspace）内存更快速地返回到操作系统，从而减少元空间的占用空间； 预览版 密封的类和接口（第二预览）； Java 17正式版 密封的类和接口（正式版）； 增强的伪随机数生成器：RandomGenerator g = RandomGenerator.of(&quot;L64X128MixRandom&quot;);； 支持 macOS AArch64：将允许 Java 应用程序在新的基于 Arm 64 的 Apple Silicon 计算机上本地运行； 删除 RMI 激活； 预览版 新增 switch 模式匹配；","link":"/906fcab3c166/"},{"title":"动态代理","text":"动态代理面试题 基础如何通过反射创建对象？ 通过类对象调用 newInstance() 方法，例如：String.class.newInstance() 通过类对象的 getConstructor() 或 getDeclaredConstructor() 方法获得构造器 Constructor 对象并调用其 newInstance() 方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”); 什么是代理模式通过代理控制对象的访问，可以在这个对象调用方法之前、调用方法之后去处理/添加新的功能。(也就是 AOP 的微实现) 代理在原有代码乃至原业务流程都不修改的情况下，直接在业务流程中切入新代码，增加新功能，这也和 Spring 的面向切面编程很相似 三种代理 静态代理：由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。 缺点：每个需要代理的对象都需要自己重复编写代理，很不舒服， 优点：可以面相实际对象或者是接口的方式实现代理 动态代理：也叫 JDK 代理、接口代理。动态代理的对象，是利用 JDK 的 API，动态的在内存中构建代理对象（是根据被代理的接口来动态生成代理类的 class 文件，并加载运行的过程） 缺点：必须是面向接口，目标业务类必须实现接口 优点：不用关心代理类，只需要在运行阶段才指定代理哪一个对象 CGLIB 动态代理：和 JDK 代理一样，使用反射完成代理。不同的是他可以直接代理类（JDK 动态代理不行，他必须目标业务类必须实现接口），CGLIB 动态代理底层使用字节码技术，CGLIB 动态代理不能对 final 类进行继承。CGLIB 动态代理需要导入 asm 开源包，对代理对象类的 class 文件加载进来，通过修改其字节码生成子类来处理。 代码用代码演示三种代理我有一段这样的代码：（如何能在不修改 UserDao 接口类的情况下开事务和关闭事务呢） 静态代理接口类 点击展开代码 >folded12345public class UserDao{ public void save() { System.out.println(&quot;保存数据方法&quot;); }} 运行测试类 点击展开代码 >folded123456public class Test{ public static void main(String[] args) { UserDao userDao = new UserDao(); userDao.save(); }} 修改代码，添加代理类 点击展开代码 >folded1234567891011121314public class UserDaoProxy extends UserDao { private UserDao userDao; public UserDaoProxy(UserDao userDao) { this.userDao = userDao; } public void save() { System.out.println(&quot;开启事物...&quot;); userDao.save(); System.out.println(&quot;关闭事物...&quot;); }} 添加完静态代理的测试类 点击展开代码 >folded1234567public class Test{ public static void main(String[] args) { UserDao userDao = new UserDao(); UserDaoProxy userDaoProxy = new UserDaoProxy(userDao); userDaoProxy.save(); }} 动态代理接口 点击展开代码 >folded123public interface UserDao { void save();} 接口实现类 点击展开代码 >folded12345public class UserDaoImpl implements UserDao { public void save() { System.out.println(&quot;保存数据方法&quot;); }} 下面是代理类，可重复使用，不像静态代理那样要自己重复编写代理 点击展开代码 >folded1234567891011121314151617181920212223import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;// 每次生成动态代理类对象时,实现了 InvocationHandler 接口的调用处理器对象public class InvocationHandlerImpl implements InvocationHandler { // 这其实业务实现类对象，用来调用具体的业务方法 private Object target; // 通过构造函数传入目标对象 public InvocationHandlerImpl(Object target) { this.target = target; } // 动态代理实际运行的代理方法 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;调用开始处理&quot;); // 下面 invoke() 方法是以反射的方式来创建对象，第一个参数是要创建的对象，第二个是构成方法的参数，由第二个参数来决定创建对象使用哪个构造方法 Object result = method.invoke(target, args); System.out.println(&quot;调用结束处理&quot;); return result; }} 利用动态代理使用代理方法 点击展开代码 >folded1234567891011121314151617import java.lang.reflect.Proxy;public class Test { public static void main(String[] args) { // 被代理对象 UserDao userDaoImpl = new UserDaoImpl(); InvocationHandlerImpl invocationHandlerImpl = new InvocationHandlerImpl(userDaoImpl); // 类加载器 ClassLoader loader = userDaoImpl.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = userDaoImpl.getClass().getInterfaces(); // 主要装载器、一组接口及调用处理动态代理实例 UserDao newProxyInstance = (UserDao) Proxy.newProxyInstance(loader, interfaces, invocationHandlerImpl); newProxyInstance.save(); }} CGLIB 动态代理接口 点击展开代码 >folded123public interface UserDao { void save();} 接口实现类 点击展开代码 >folded12345public class UserDaoImpl implements UserDao { public void save() { System.out.println(&quot;保存数据方法&quot;); }} 代理主要类 点击展开代码 >folded1234567891011121314151617181920212223242526import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class CglibProxy implements MethodInterceptor { private Object targetObject; // 这里的目标类型为 Object，则可以接受任意一种参数作为被代理类，实现了动态代理 public Object getInstance(Object target) { // 设置需要创建子类的类 this.targetObject = target; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(target.getClass()); enhancer.setCallback(this); return enhancer.create(); } // 代理实际方法 public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { System.out.println(&quot;开启事物&quot;); Object result = proxy.invoke(targetObject, args); System.out.println(&quot;关闭事物&quot;); // 返回代理对象 return result; }} 测试 CGLIB 动态代理 点击展开代码 >folded1234567public class Test { public static void main(String[] args) { CglibProxy cglibProxy = new CglibProxy(); UserDao userDao = (UserDao) cglibProxy.getInstance(new UserDaoImpl()); userDao.save(); }}","link":"/d000ecc9e1c3/"},{"title":"线程池","text":"线程池 基础什么是线程池在一个应用程序中初始化一个线程集合，然后在需要执行新的任务时重用线程池中的线程，而不是创建一个新的线程。线程池中的每个线程都有被分配一个任务，一旦任务完成，线程就回到线程池中，等待下一次的任务分配，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。 为什么用线程池 降低资源消耗，提高线程利用率，降低创建和销毁线程的消耗； 提高响应速度，任务来了直接有线程可以用，而不是先创建再执行； 提高线程的可管理性，线程是有限的，使用线程池可以统一分配调优监控； 线程池的优点 降低资源消耗：重用存在的线程，减少对象创建销毁的开销，每个工作线程都可以被重复利用，可执行多个任务。。 提高响应速度：当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性（每个线程需要大约 1MB 内存），使用线程池可以进行统一的分配，调优和监控。 附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。 何为线程池的线程复用Java线程池是如何实现线程复用的？（从源码学习） 线程池将任务与线程解耦，当 Thread 的 run() 方法执行完一个任务之后，会循环地从阻塞队列中取任务来执行，这样执行完一个任务之后就不会立即销毁了； 当工作线程数小于核心线程数，那些空闲的核心线程再去队列取任务的时候，如果队列中的 Runnable 数量为 0，就会阻塞当前线程，这样线程就不会回收了； 在线程池对 Thread 进行了封装，并不是每次都会调用 Thread.start() 来创建新线程，而是让每个线程执行一个「循环任务」，在这个「循环任务」中不断检查是否有任务需要执行，如果有则直接执行（调用线程 run 方法）。 线程池的参数12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) { this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);} corePollSize 核心线程数量：正常情况下会创建的常驻线程的数量； maxinumPoolSize 最大线程数量：比如当前任务较多，核心线程使用完了还能创建的数量，线程池的最大线程数不会超过此值； keepAliveTime 线程保持时间：线程保持时间，N 个时间单位 unit 时间单位：线程保持时间时间单位（比如秒，分） workQueue 阻塞队列：存放待执行任务，当核心线程使用完时，再来的任务都存放在此处，直到整个队列被放满但还在持续加入任务，则会创建新的线程； ThreadFactory 线程工厂：生产线程，生产的线程都在同一个组内，拥有相同的优先级，且都不是守护线程，也可以自定义线程工厂； Handler 线程池拒绝策略：当线程池被 shutdown() 关闭或达到最大线程数时触发； 丢弃任务并抛出异常； 丢弃任务不抛出异常； 丢弃队列最前面的任务，然后重新提交； 由调用线程处理此任务； 线程池队列已满提交任务会发生什么 如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务 如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到 ArrayBlockingQueue 中，ArrayBlockingQueue 满了，会根据 maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，那么则会使用拒绝策略 RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy 线程池的拒绝策略如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略: ThreadPoolExecutor.AbortPolicy 抛异常拒绝策略：抛出 RejectedExecutionException 来拒绝新任务的处理。 ThreadPoolExecutor.CallerRunsPolicy 调用线程方执行任务：调用方执行此线程运行任务，会改变线程执行顺序，对执行顺序有要求时不能使用此策略； ThreadPoolExecutor.DiscardPolicy 抛弃新任务：不处理新任务，直接丢弃掉。 ThreadPoolExecutor.DiscardOldestPolicy 抛弃旧任务： 此策略将丢弃最早的未处理的任务请求。 线程池 submit() 和 execute() 的区别 execute() submit() 执行任务 可以 可以 接收参数 执行 Runnable 类型的任务 执行 Runnable 和 Callable 类型的任务 返回值 无 可以返回持有计算结果的 Future 对象 异常处理 无 方便 Exception 处理 阻塞队列的作用，为什么先加队列而不是先创建线程一般队列是一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留任务。阻塞队列可以保留住当前想要继续入队的任务； 阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，阻塞队列自带阻塞和唤醒功能，不需要额外处理，无任务执行时，线程池利用阻塞队列的 take() 方法挂起，从而维持核心线程存活，释放 CPU 资源； 创建新线程的时候，需要获取全局锁，会影响整体效率。","link":"/2360354cec1b/"},{"title":"JVM 基础","text":"JVM 基础 jvm（四）——JVM自带内存分析工具详解_节至-CSDN博客_java内存分析工具 远程调试VisualVM 远程连接服务器_zhou6343178的博客-CSDN博客_jvisualvm怎么读 使用Java VisualVM监控远程JVM - 简书 (jianshu.com) 服务器新建 jstatd-all.policy 文件： 123grant codebase &quot;file:${java.home}/../lib/tools.jar&quot; { permission java.security.AllPermission;}; 启动 jstatd：jstatd -J-Djava.security.policy=jstatd.all.policy -J-Djava.rmi.server.hostname=10.10.0.34（hostname 为你的 IP）","link":"/13e0e7594c45/"},{"title":"Stream","text":"无用面试题 Stream 入门Java8 Stream 流入门","link":"/8ebde4fc6f9e/"},{"title":"数据库的 3 大范式","text":"数据库的 3 大范式 数据库的 3 大范式 设计关系型数据库时，遵从不同的规范要求，设计合理的关系型数据库，这些不同的规范要求被称为范式。 目前关系型数据库共有六种范式，这里简单和大家分享一下我对前三种范式的理解。 并在后面举一个实例。 第一范式（1NF) 每一列都是不可分割的原子项。 简言之，每一项都不可以再进行拆分。 在这里举个例子： 系可以拆分为：系名、系主任。这就不是「原子项」。 姓名、学号等，不可再继续拆分，是「原子项」。 第二范式（2NF) 在 1NF 的基础上，非码属性必须完全依赖于码（在 1NF 基础上消除非主属性对主码的部分函数依赖） 这里需要先了解几个概念： 函数依赖： A –&gt; B，如果通过 A 属性（属性组）的值，可以确定唯一 B 属性的值，则称 B 依赖于 A。 例如： 学号 –&gt; 姓名（使用学号可以确定姓名） （学号，课程名称）–&gt; 分数（学号与课程可以确定分数） 拿我们大家熟知的英雄联盟举例，通过「黑暗封印」可以找到「梅贾的窃魂卷」 完全函数依赖： A –&gt; B，如果 A 是一个属性组，则 B 属性值得确定需要依赖于 A 属性组中所有的属性值。 例如：（学号，课程名称）–&gt; 分数（学号与课程可以确定分数） 部分函数依赖： A –&gt; B，如果 A 是一个属性组，则 B 属性值得确定只需要依赖于 A 属性组中某一些值即可。 例如：（学号，课程名称）–&gt; 姓名（通过学号就可以确定姓名，课程名称在这里并不重要） 传递函数依赖: A –&gt; B, B –&gt; C，如果通过 A 属性（属性组）的值，可以确定唯一 B 属性的值，在通过 B 属性（属性组）的值可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A。 例如：学号 –&gt; 系名，系名 –&gt; 系主任 码: 如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码。 例如，该表中码为：学号，课程名称（通过学号与课程名称就可以确定表格中其余所有的元素） 主属性：码属性组中的所有属性 非主属性：除去码属性组的属性，剩余的属性 第三范式（3NF） 在 2NF 基础上，任何非主属性不依赖于其它非主属性（在 2NF 基础上消除传递依赖） 例子为了便于理解，我们这里以这个表格举个例子。 从表中标红的列可以看出，此时这个数据表还不满足「1NF」： 我们将「系」拆分为「系名」与「系主任」，此时该数据表没有能再进行分割的项，所有的列都已经是「原子项」了。 但是，我们又发现三个问题： 数据存在相当大的冗余：姓名、系名、系主任。 想添加一个院系就必须要有学生才可以，数据不合法。 假设张无忌同学毕业，那么在删除数据时，经济系也会被同时删除。 小结 范式 特点 1NF 原子性：表中每列不可再拆分。 2NF 不产生局部依赖，一张表只描述一件事情 3NF 不产生传递依赖，表中每一列都直接依赖于主键。而不是通过其它列间接依赖于主键。","link":"/7b4b651f799b/"},{"title":"CentOS 安装 JDK8","text":"CentOS 安装 JDK8 的教程 前置条件所需文件： 一台 Linux 服务器 JDK8（官网下载地址） 安装流程检查是否已经存在 JDK在 Linux 服务器中执行 java –version，查看是否安装 JDK 123456789# 未安装：[root@localhost ~]# java -version-bash: java: 未找到命令# 已安装：[root@localhost ~]# java -versionjava version &quot;1.8.0_231&quot;Java(TM) SE Runtime Environment (build 1.8.0_231-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.231-b11, mixed mode) 如果显示安装，且版本为 1.8.x_xxx 那么就不需要再次安装 JDK。 上传 JDK 打开 XShell，执行命令 mkdir /home/root 打开 XFtp 工具，登录操作类似与 XShell。 端口 22，忘记 ip 可以在 XShell 执行 ip addr 命令获取机器 ip。 如图： 在服务器地址栏输入 /home/root 将之前准备的 jdk 安装包拖进服务器 如图： 上传完成之后回到 XShell，执行命令 ls -l /home/root/ 如图： 如果显示不正确，请重新操作本教程。 执行命令 rpm -ivh /home/root/jdk-8u231-linux-x64.rpm。 待上面命令执行完成之后，执行命令 java -version 此时已经可以看到： [root@localhost root]# java -version java version &quot;1.8.0_231&quot; Java(TM) SE Runtime Environment (build 1.8.0_231-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.231-b11, mixed mode)","link":"/09b7c2ad3f70/"},{"title":"GitHubPages","text":"GitHub 使用教程文档，本站就是从这里面一步一步搭建的 搭建准备HEXO 安装1npm install -g hexo hexo init hexofolder 此步骤会自动创建文件夹 引用Git Pages + Jekyll/Hexo搭建自己的博客(最全总结你想知道的都在这里了)_muzilanlan的专栏-CSDN博客_git page 使用hexo+github搭建免费个人博客详细教程 - 我是小茗同学 - 博客园 (cnblogs.com) 利用GitHub Actions 自动部署 Hexo博客 全自动运行 不知所措的新哥 - 简书 (jianshu.com) 页面地址xiaoxuuu/xiaoxuuu.GitHub.io 源码Dependabot secrets (github.com) 主题单主页LXT’s share space (lixuetaoleo.github.io) forsigner的博客 404Not Found (nhj571.com) HEXO 主题Home | TriDiamond’s Blog 快速上手 | Hexo Aurora (tridiamond.tech) 项目 - XAOXUU ppoffice/hexo-theme-icarus: A simple, delicate, and modern theme for the static site generator Hexo. (github.com) fluid-dev/hexo-theme-fluid: 一款 Material Design 风格的 Hexo 主题 / An elegant Material-Design theme for Hexo (github.com) jerryc127/hexo-theme-butterfly: 🦋 A Hexo Theme: Butterfly (github.com) volantis-x/hexo-theme-volantis: A Wonderful Theme for Hexo https://vlts.cc https://volantis.js.org (github.com)","link":"/4347155d5107/"},{"title":"IDEA 快捷键","text":"IDEA 快捷键 编辑器代码重构方法参数重构鼠标放置在方法名上使用快捷键 macOS：⌘ F6，Windows：Ctrl F6 方法抽取选中需要抽取的代码片段使用快捷键 macOS：⌥ ⌘ F6，Windows：Ctrl Alt M 內联方法鼠标放置在方法名上使用快捷键 macOS：⌥ ⌘ N，Windows：Ctrl Alt N 常量抽取macOS：⌥ ⌘ C，Windows：Ctrl Alt C 变量抽取macOS：⌥ ⌘ V，Windows：Ctrl Alt V 字段抽取（全局变量）macOS：⌥ ⌘ F，Windows：Ctrl Alt F 形参抽取（方法内变量抽取为外部传入）macOS：⌥ ⌘ T，Windows：Ctrl Alt P 方法父子类移动鼠标放置在待移动方法上右键选择： Refactor... - Pull Members Up... 重构... - 向上推送成员... 提取接口（方法抽取接口）鼠标放置在待移动方法上右键选择： Refactor... - Extract Interface... 重构... - 提取接口... 提取委托（方法抽取普通方法）鼠标放置在待移动方法上右键选择： Refactor... - Extract Delegate... 重构... - 提取委托... 提取超类（方法抽取父类方法）鼠标放置在待移动方法上右键选择： Refactor... - Extract Superclass... 重构... - 提取超类...","link":"/e7a6f47a5edd/"},{"title":"VMware 安装 CentOS7","text":"VMware 安装 CentOS7 前置条件所需文件： CentOS7系统 VMware（我的版本：15.5.0 build-14665864） 安装流程新建虚拟机 安装 CentOS Tips：如需要操作虚拟机请鼠标单击虚拟机屏幕或者按下键盘 Ctrl + G，如需要操作你的电脑，请按下键盘 Ctrl + Alt 登录 CentOS 使用 XShell 6 连接 CentOS 验证网络输入命令 ping www.baidu.com 如若正确，如图显示","link":"/1c6295a86934/"},{"title":"Windows 环境安装 macOS","text":"从零开始学习在 Windows 下构建 OpenCore 工具准备新手挑战黑苹果-超详细的OpenCore黑苹果安装教程_哔哩哔哩_bilibili macOS 镜像下载：黑果小兵的部落阁 (daliansky.net) 启动盘制作工具 balenaEtcher 下载：balenaEtcher - Flash OS images to SD cards &amp; USB drives OpenCore 下载：Releases · acidanthera/OpenCorePkg (github.com) OpenCore 驱动下载：Gathering files | OpenCore Install Guide (dortania.github.io) OpenCore 编辑器：Releases · ic005k/OCAuxiliaryTools (github.com) 建议使用与 OC 对应版本的编辑器 OpenCore 排错：OpenCore config.plist Sanity Checker (slowgeek.com) 磁盘精灵：数据恢复软件,硬盘分区工具,系统备份软件 - DiskGenius官方网站 流程打开 OpenCore 驱动下载页面 Drivers 补充对应 OC 驱动位置：EFI - OC - Drivers。 这里主要需要丰富 HfsPlus.efi，OpenRuntime.efi 默认包含在 OC 驱动中。 Legacy users 补充不支持 UEFI 引导的电脑需要。 Kexts 补充对应 OC 驱动位置：EFI - OC - Kexts。 VirtualSMC ：将电脑伪装成 Mac 电脑欺骗 macOS SMCProcessor.kext：监控 CPU 温度，AMD 平台无需； SMCSuperIO.kext：监控风扇转速，AMD 平台无需； SMCLightSensor.kext：光传感器驱动：笔记本需要； SMCBatteryManager.kext：电源管理，笔记本需要； SMCDellSensors.kext：DELL 传感器驱动，仅 DELL 电脑需要； Lilu：驱动运行的基础模块，没有此驱动其他驱动无法运行 WhateverGreen：显卡驱动 AppleALC ：声卡驱动 USBInjectAll：USB 驱动 XHCI-unsupported：部分芯片组需要 WiFi and Bluetooth：选择对应厂商下载 BrcmPatchRAM：需根据系统选择版本使用：说明 AirportBrcmFixup：博通驱动 SSDTs 补充对应 OC 驱动位置：EFI - OC - ACPI 可从 OC 驱动包 - Docs - AcpiSamples - Binaries 目录拷贝： SSDT-AWAC.aml SSDT-EC-USBX.aml SSDT-PLUG.aml SSDT-RHUB.aml：进入页面有三个选项：Prebuilt、SSDTTime、Manual Prebuilt：使用别人制作的成品文件 SSDTTime：使用工具自行编译 Manual：自己制作 config.plist 制作从 OC 驱动包 - Docs 目录拷贝 Sample.plist 文件至 OC 驱动的 EFI - OC 目录下并重命名为 config.plist","link":"/4b754c6ed67f/"},{"title":"如何提高代码的可读性","text":"如何提高代码的可读性 一、注释首先，我们先谈一下注释。 什么是注释？注释就是说明解释性的文字 。 而代码注释是架起程序设计者与程序阅读者之间的通信桥梁，可以最大限度的提高团队开发合作效率。也是程序代码可维护性的重要环节之一。 那么，怎么写注释比较好呢？有以下几点需要大家注意： 1、注释形式统一在整个应用程序中，使用具有一致的标点和结构的样式来构造注释。如果在其它项目中发现它们的注释规范与这份文档不同，按照这份规范写代码，不要试图在既成的规范系统中引入新的规范。 2、注释内容准确简洁内容要简单、明了、含义准确，防止注释的多义性，错误的注释不但无益反而有害。 当内容很显而易见的时候，进行重复的注释是很没有效率的。 如果你必须对该代码进行注释，那你可以简单地将其合并到一行中。 简单的代码做简单注释，注释内容不用写的太多。 注释条件： A、基本注释（必须加）a) 类（接口）的注释。b) 构造函数的注释。c) 方法的注释。d) 全局变量的注释。e) 字段/属性的注释。 B、特殊必加注释（必须加）a) 典型算法必须有注释。b) 在代码不明晰处必须有注释。c) 在代码修改处加上修改标识的注释。d) 在循环和逻辑分支组成的代码中加注释。e) 为他人提供的接口必须加详细注释。 关键性的语句需要加注释，例如特定的变量含义解释，特别的条件或者函数意思解释。 特定的变量含义解释，特别的条件或者函数意思解释没有统一的标准，自己来恒定，不同阶段所理解的关键性都有区别。 二、一致的缩进常用的 IDE 都有代码格式化。大家写完程序，删去无用空行，Ctrl + Alt + L调整一下就可以了。 那么在这里需要注意的是使用 Tab 缩进就不能使用空格缩进，风格要统一，千万不可以混用。这一点很重要，千万不可以混用！ 三、代码分组通常情况下，某些任务需要几行代码，那么使用空行将这些代码分隔开是一个不错的主意。 这会让它们之间有一些空间。 然后再在每个代码块的开头添加注释，视觉上看起来就是分离的代码块了。 比如说：new 了几个对象，然后要使用这些对象的方法，那么，在这之间，我们可以来上一个空行。 四、一致的命名方案这个上次提到过，那么这次再和大家分享一下。 首先，命名应该有单词边界。我们现在最常用的就是驼峰法。 camelCase(骆驼命名法)：除了第一个单词，每个单词的第一个字母都大写。 命名方法很多，类似于前面提到的缩进方式，命名方法也有不同的选择。一些语言倾向于使用一种命名方案。例如，在 Java 中，大多数代码都使用 camelCase 方式来命名。 五、避免嵌套太深嵌套过多会使代码更难读取和跟踪。 这个没有办法具体的讲，只能说，平时写代码的时候多注意。 尽可能减少的 if for 循环嵌套层数与尽量少使用递归。 六、限制行的长度眼睛在阅读高而窄的文本时会更舒服，这正是报纸文章总是二三十字为一行的原因。 我们在编写代码时，尽量不要将一行代码写出屏幕外。 虽然这种情况比较少，但是我们还是需要时刻注意。 七、文件和文件夹结构没有什么最佳的代码格式，只有统一得代码格式。","link":"/2c1c442896f1/"},{"title":"安装 VMware15","text":"Windows 安装 VMware 15 前置条件所需文件： VMware（15.5.0 build-14665864） 序列号【UY758-0RXEQ-M81WP-8ZM7Z-Y3HDA】 安装流程右键管理员运行","link":"/38617b0d7691/"},{"title":"RabbitMQ","text":"RabbitMQ 面试题 基础基本概念 Broker：消息队列服务器实体，是指一个或多个 erlang node 的逻辑分组，且 node 上运行着 RabbitMQ 应用程序； cluster：是在 broker 的基础之上，增加了 node 之间共享元数据的约束 Exchange：消息交换机，它指定消息按特定规则，路由到哪个队列； Queue：消息队列载体，每个消息都会被投入到一个或多个队列； Binding：绑定，它的作用就是把 exchange 和 queue 按照路由规则绑定起来； Routing Key：路由关键字，exchange 根据这个关键字进行消息投递； VHost：VHost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等，拥有独立的权限系统，可以做到 vhost 范围的用户控制； Producer：消息生产者； Consumer：消息消费者； Channel：消息通道，在客户端的每个连接里，可建立多个 channel，每个 channel 代表一个会话任务 channel exchange queue Queue 具有自己的 erlang 进程； exchange 内部实现为保存 binding 关系的查找表； channel 是实际进行路由工作的实体，即负责按照 routing_key 将 message 投递给 queue 。由 AMQP 协议描述可知，channel 是真实 TCP 连接之上的虚拟连接，所有 AMQP 命令都是通过 channel 发送的，且每一个 channel 有唯一的 ID。一个 channel 只能被单独一个操作系统线程使用，故投递到特定 channel 上的 message 是有顺序的。但一个操作系统线程上允许使用多个 channel 。 RabbitMQ 有几种广播类型 fanout：所有 bind 到此 exchange 的 queue 都可以接收消息(纯广播，绑定到 RabbitMQ 的接受者都能收到消息)； direct：通过 routingKey 和 exchange 决定的哪个唯一的 queue 可以接收消息； topic：所有符合 routingKey (此时可以是一个表达式)的 routingKey 所 bind 的 queue 可以接收消息； vhost 的作用vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段(一个典型的例子就是不同的应用可以跑在不同的 vhost 中)。 为什么使用 RabbitMQ 在分布式系统下具备异步，削峰，负载均衡等一系列高级功能； 拥有持久化的机制，进程消息，队列中的信息也可以保存下来； 实现消费者和生产者之间的解耦； 对于高并发场景下，利用消息队列可以使得同步访问变为串行访问达到一定量的限流，利于数据库的操作； 可以使用消息队列达到异步下单的效果，排队中，后台进行逻辑下单。 使用 RabbitMQ 的好处 解耦：系统 A 在代码中直接调用系统 B 和系统 C 的代码，如果将来 D 系统接入，系统 A 还需要修改代码，过于麻烦！ 异步：将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度 削峰：并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常 元数据在非 cluster 模式下，元数据主要分为 Queue 元数据（queue 名字和属性等）、Exchange元数据（exchange 名字、类型和属性等）、Binding 元数据（存放路由关系的查找表）、Vhost元数据（vhost 范围内针对前三者的名字空间约束和安全属性设置）。在 cluster 模式下，还包括 cluster 中 node 位置信息和 node 关系信息。元数据按照 erlang node 的类型确定是仅保存于 RAM 中，还是同时保存在 RAM 和 disk 上。元数据在 cluster 中是全 node 分布的。 消息消息基于什么传输由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。 消息如何分发？若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。 消息怎么路由？从概念上来说，消息路由必须有三部分：交换器、路由、绑定。生产者把消息发布到交换器上；绑定决定了消息如何从路由器路由到特定的队列；消息最终到达队列，并被消费者接收。 消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。通过队列路由键，可以把队列绑定到交换器上。消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）。如果能够匹配到队列，则消息会投递到相应队列中；如果不能匹配到任何队列，消息将进入 “黑洞”。 常用的交换器主要分为一下三种： direct：如果路由键完全匹配，消息就被投递到相应的队列 fanout：如果交换器收到消息，将会广播到所有绑定的队列上 topic：可以使来自不同源头的消息能够到达同一个队列。使用topic交换器时，可以使用通配符。比如：“*” 匹配特定位置的任意文本， “.” 把路由键分为了几部分，“#” 匹配所有规则等。特别注意：发往topic交换器的消息不能随意的设置选择键（routing_key），必须是由”.”隔开的一系列的标识符组成。 消息的可靠性投递 发送方确认模式 将信道设置成 confirm 模式(发送方确认模式)，则所有在信道上发布的消息都会被指派一个唯一的 ID； 一旦消息被投递到目的队列后，或者消息被写入磁盘后(可持久化的消息)，信道会发送一个确认给生产者(包含消息唯一 ID)； 如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack(notacknowledged，未确认)消息； 所有被发送的消息都将被 confirm（即 ack） 或者被 nack 一次。但是没有对消息被 confirm 的快慢做任何保证，并且同一条消息不会既被 confirm 又被 nack； 发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息； ConfirmCallback 接口：只确认是否正确到达 Exchange 中，成功到达则回调； ReturnCallback 接口：消息失败返回时回调； 接收方确认机制 消费者在声明队列时，可以指定 noAck 参数，当 noAck = false 时，RabbitMQ 会等待消费者显式发回 ack 信号后才从内存(或者磁盘，持久化消息)中移去消息。否则，消息被消费后会被立即删除； 消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息， RabbitMQ 才能安全地把消息从队列中删除； RabbitMQ 不会为未 ack 的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开。这么设计的原因是 RabbitMQ 允许消费者消费一条消息的时间可以很长。保 证数据的最终一致性； 如果消费者返回 ack 之前断开了链接，RabbitMQ 会重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重） 几种特殊情况 如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。(可能存在消息重复消费的隐患，需要去重) 如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不会给该消费者分发更多的消息。 怎么避免消息丢失 消息持久化，前提是队列必须持久化 ACK 确认机制； 设置集群镜像模式； 消息补偿机制。 如何避免消息重复投递或重复消费在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列；在消息消费时，要求消息体中必须要有一个bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，避免同一条消息被重复消费。 这个问题针对业务场景来答分以下几点： 1.比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。 2.再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。 3.如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt;以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。 无法被路由的消息去了哪里?无设置的情况下，无法路由（Routing key错误）的消息会被直接丢弃 解决方案：将mandatory设置为true，并配合ReturnListener，实现消息的回发 声明交换机时，指定备份的交换机：Map&lt;String,Object&gt; arguments = new HashMap&lt;String,Object&gt;(); arguments.put(&quot;alternate-exchange&quot;,&quot;备份交换机名&quot;); 事务消息通过对信道的设置实现 channel.txSelect()：通知服务器开启事务模式；服务端会返回 Tx.Select-Ok channel.basicPublish：发送消息，可以是多条，可以是消费消息提交 ack channel.txCommit()：提交事务； channel.txRollback()：回滚事务； 消费者使用事务： autoAck=false，手动提交 ack，以事务提交或回滚为准； autoAck=true，不支持事务的，也就是说你即使在收到消息之后在回滚事务也是于事无补的，队列已经把消息移除了 如果其中任意一个环节出现问题，就会抛出 IoException 异常，用户可以拦截异常进行事务回滚，或决 定要不要重复消息。 事务消息会降低 rabbitmq 的性能 消息在什么时候会变成死信? 消息拒绝并且没有设置重新入队 消息过期 消息堆积，并且队列达到最大长度，先入队的消息会变成DL 消息幂等性生产者方面：可以对每条消息生成一个 msgID，以控制消息重复投递： AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder() porperties.messageId(String.valueOF(UUID.randomUUID())) 消费者方面：消息体中必须携带一个业务ID，如银行流水号，消费者可以根据业务ID去重，避免重复消费 消息如何被优先消费123456//生产者Map&lt;String, Object&gt; argss = new HashMap&lt;String, Object&gt;();argss.put(&quot;x-max-priority&quot;,10);//消费者 优先级，默认为5，配合队列的 x-max-priority 属性使用AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder().priority(5) 如何保证消息的顺序性一个队列只有一个消费者的情况下才能保证顺序，否则只能通过全局ID实现（每条消息都一个 msgId，关联的消息拥有一个 parentMsgId。可以在消费端实现前一条消息未消费，不处理下一条消息；也可以在生产端实现前一条消息未处理完毕，不发布下一条消息） 如何自动删除长时间没有消费的消息123456// 通过队列属性设置消息过期时间Map&lt;String, Object&gt; argss = new HashMap&lt;String, Object&gt;();argss.put(&quot;x-message-ttl&quot;,6000); // 对每条消息设置 TTL 过期时间AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder().expiration(&quot;10000&quot;); 持久化要保证消息持久化成功的条件有哪些 声明队列必须设置持久化 durable 设置为 true； 消息推送投递模式必须设置持久化，deliveryMode 设置为 2(持久)； 消息已经到达持久化交换器； 消息已经到达持久化队列。 RabbitMQ 确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上的一个持久化日志文件，当发布一条持久性消息到持久交换器上时，RabbitMQ 会在消息提交到日志文件后才发送响应。一旦消费者从持久队列中消费了一条持久化消息，RabbitMQ 会在持久化日志中把这条消息标记为等待垃圾收集。如果持久化消息在被消费之前 RabbitMQ 重启，那么 RabbitMQ 会自动重建交换器和队列（以及绑定），并重新发布持久化日志文件中的消息到合适的队列。 RabbitMQ 持久化有什么缺点持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 SSD 硬盘来缓解吞吐量的问题。 队列消息队列的作用与使用场景 异步：批量数据异步处理（批量上传文件） 削峰：高负载任务负载均衡（电商秒杀抢购） 解耦：串行任务并行化（退货流程解耦） 广播：基于 Pub/Sub 实现一对多通信 多个消费者监听一个队列时，消息如何分发? 轮询: 默认的策略，消费者轮流，平均地接收消息 公平分发: 根据消费者的能力来分发消息，给空闲的消费者发送更多消息 当消费者有 x 条消息没有响应 ACK 时，不再给这个消费者发送消息：channel.basicQos(int x) 死信队列、延时队列死信消息： 消息被消费方否定确认，使用 channel.basicNack 或 channel.basicReject ，并且此时 requeue 属性被设置为 false； 消息在队列的存活时间超过设置的 TTL 时间； 消息队列的消息数量已经超过最大队列长度； 「死信」消息会被 RabbitMQ 进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃 过期消息： 在 RabbitMQ 中存在 2 种方可设置消息的过期时间，第一种通过对队列进行设置，这种设置后，该队列中所有的消息都存在相同的过期时间，第二种通过对消息本身进行设置，那么每条消息的过期时间都不一样。如果同时使用这 2 种方法，那么以过期时间小的那个数值为准。当消息达到过期时间还没有被消费，那么那个消息就成为了一个死信消息； 队列设置：在队列申明的时候使用 x-message-ttl 参数，单位为毫秒； 单个消息设置：是设置消息属性的 expiration 参数的值，单位为毫秒； 延时队列：在 RabbitMQ 中不存在延时队列，但是我们可以通过设置消息的过期时间和死信队列来模拟出延时队列。消费者监听死信交换器绑定的队列，而不要监听消息发送的队列。 RabbitMQ 镜像队列机制镜像 queue 有 master 节点和 slave 节点。master 和 slave 是针对一个 queue 而言的，而不是一个 node 作为所有 queue 的 master，其它 node 作为 slave。一个 queue 第一次创建的 node 为它的 master 节点，其它 node 为 slave 节点。 无论客户端的请求打到 master 还是 slave 最终数据都是从 master 节点获取。当请求打到 master 节点时， master 节点直接将消息返回给 client，同时 master 节点会通过 GM（Guaranteed Multicast）协议将 queue 的最新状态广播到 slave 节点。GM 保证了广播消息的原子性，即要么都更新要么都不更新。 当请求打到 slave 节点时，slave 节点需要将请求先重定向到 master 节点，master 节点将将消息返回给 client，同时 master 节点会通过 GM 协议将 queue 的最新状态广播到 slave 节点。 如果有新节点加入，RabbitMQ 不会同步之前的历史数据，新节点只会复制该节点加入到集群之后新增的消息。 使用了消息队列会有什么缺点? 系统可用性降低：你想啊，本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性降低 系统复杂性增加:要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大。 如何实现延时队列?利用 TTL（队列的消息存活时间或者消息存活时间），加上死信交换机 123456// 设置 TTL 属性，消息10秒钟过期AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder().expiration(&quot;10000&quot;)// 指定队列的死信交换机Map&lt;String,Object&gt; arguments = new HashMap&lt;String,Object&gt;();arguments.put(&quot;x-dead-letter-exchange&quot;,&quot;DLX_EXCHANGE&quot;); 集群RabbitMQ 集群 主备模式 主节点提供读写，备用节点不提供读写。如果主节点挂了，就切换到备用节点。 远程模式 实现双活的一种模式，跨地域的让两个 MQ 集群互联，远距离通信和复制。 镜像模式 rabbitMQ 数据的高可靠性解决方案，主要就是实现数据的同步，一般来讲是 2 - 3 个节点实现数据同步。对于 100% 数据可靠性解决方案，一般是采用 3 个节点。 多活模式 实现异地数据复制的主流模式，一般来说，实现异地集群是采用双活或者多活模型来实现的。 集群模式和集群节点类型普通模式：默认模式，以两个节点（rabbit01，rabbit02）为例来进行说明，对于Queue来说，消息实体只存在于其中一个节点rabbit01（或者rabbit02），rabbit01和rabbit02两个节点仅有相同的元数据，即队列结构。当消息进入rabbit01节点的Queue后，consumer从rabbit02节点消费时，RabbitMQ会临时在rabbit01，rabbit02间进行消息传输，把A中的消息实体取出并经过B发送给consumer，所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连rabbit01或rabbit02，出口总在rabbit01，会产生瓶颈。当rabbit01节点故障后，rabbit02节点无法取到rabbit01节点中还未消费的消息实体。如果做了消息持久化，那么等到rabbit01节点恢复，然后才可被消费。如果没有消息持久化，就会产生消息丢失的现象。 镜像模式：把需要的队列做成镜像队列，存在与多个节点属于RabibitMQ的HA方案，该模式解决了普通模式中的问题，其实质和普通模式不同之处在于，消息体会主动在镜像节点间同步，而不是在客户端取数据时临时拉取，该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉，所以在对可靠性要求比较高的场合中适用 节点分为内存节点（保存状态到内存，但持久化的队列和消息还是会保存到磁盘），磁盘节点（保存状态到内存和磁盘），一个集群中至少需要一个磁盘节点 RabbitMQ 节点 docker 启动时传入参数：docker run -d --hostname rabbit3 --name myrabbit3 -p 5674:5672 --link myrabbit1:rabbit1 --link myrabbit2:rabbit2 -e RABBITMQ_ERLANG_COOKIE='rabbitcookie' rabbitmq:3.6.15-management –link：连接到哪台机器； RABBITMQ_ERLANG_COOKIE：节点之间相互通讯的秘钥； 在单 node 系统和多 node 构成的 cluster 系统中声明 queue、exchange ，以及进行 binding 会有什么不同？答：当你在单 node 上声明 queue 时，只要该 node 上相关元数据进行了变更，你就会得到 Queue.Declare-ok 回应；而在 cluster 上声明 queue ，则要求 cluster 上的全部 node 都要进行元数据成功更新，才会得到 Queue.Declare-ok 回应。另外，若 node 类型为 RAM node 则变更的数据仅保存在内存中，若类型为 disk node 则还要变更保存在磁盘上的数据。 死信队列&amp;死信交换器：DLX 全称（Dead-Letter-Exchange）,称之为死信交换器，当消息变成一个死信之后，如果这个消息所在的队列存在x-dead-letter-exchange参数，那么它会被发送到x-dead-letter-exchange对应值的交换器上，这个交换器就称之为死信交换器，与这个死信交换器绑定的队列就是死信队列。 数据如何解决丢数据的问题?1. 生产者丢数据 生产者的消息没有投递到MQ中怎么办？从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。 transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。 然而缺点就是吞吐量下降了。因此，按照博主的经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了.如果rabiitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。 2. 消息队列丢数据 处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。 那么如何持久化呢，这里顺便说一下吧，其实也很容易，就下面两步 ①、将queue的持久化标识durable设置为true,则代表是一个持久的队列 ②、发送消息的时候将deliveryMode=2 这样设置以后，rabbitMQ就算挂了，重启后也能恢复数据。在消息还没有持久化到硬盘时，可能服务已经死掉，这种情况可以通过引入mirrored-queue即镜像队列，但也不能保证消息百分百不丢失（整个集群都挂掉） 3. 消费者丢数据 启用手动确认模式可以解决这个问题 ①自动确认模式，消费者挂掉，待ack的消息回归到队列中。消费者抛出异常，消息会不断的被重发，直到处理成功。不会丢失消息，即便服务挂掉，没有处理完成的消息会重回队列，但是异常会让消息不断重试。 ②手动确认模式，如果消费者来不及处理就死掉时，没有响应ack时会重复发送一条信息给其他消费者；如果监听程序处理异常了，且未对异常进行捕获，会一直重复接收消息，然后一直抛异常；如果对异常进行了捕获，但是没有在finally里ack，也会一直重复发送消息(重试机制)。 ③不确认模式，acknowledge=”none” 不使用确认机制，只要消息发送完成会立即在队列移除，无论客户端异常还是断开，只要发送完就移除，不会重发。 引用RabbitMQ 面试题集锦","link":"/96626b6a8708/"},{"title":"分布式","text":"分布式面试题 前言首页 分布式CAP 理论 Consistency (一致性)：即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致。 对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。 从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致； Availability (可用性)：即服务一直可用，而且是正常响应时间。系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况； Partition Tolerance (分区容错性)：即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响； CP 和 AP：分区容错是必须保证的，当发生网络分区的时候，如果要继续服务，那么强一致性和可用性 只能 2 选 1 BASE 理论BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性） BASE 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结， 是基于 CAP 定理逐步演化而来的。BASE 理论的核心思想是：即使无法做到强一致性，但每个应用都可以 根据自身业务特点，采用适当的方式来使系统达到最终一致性； 基本可用： 响应时间上的损失：正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。 系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。 软状态：数据同步允许一定的延迟 最终一致性：系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态，不要求实时。 负责均衡算法、类型 轮询法：将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。 随机法：通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多， 其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。 源地址哈希法：源地址哈希的思想是根据获取客户端的 IP 地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一 IP 地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。 加权轮询法：不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。 加权随机法：与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。 最小连接数法：最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。 Session 共享有什么方案 采用无状态服务，抛弃 Session 存入 cookie（有安全风险）； 服务器之间进行 Session 同步，这样可以保证每个服务器上都有全部的 Session 信息，不过当服务器数量比较多的时候，同步是会有延迟甚至同步失败； IP 绑定策略 使用 Nginx （或其他复杂均衡软硬件）中的 IP 绑定策略，同一个 IP 只能在指定的同一个机器访问，但是这样做失去了负载均衡的意义，当挂掉一台服务器的时候，会影响一批用户的使用，风险很大； 使用 Redis 存储 把 Session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来的好处也是很大的： 实现了 Session 共享； 可以水平扩展（增加 Redis 服务器）； 服务器重启 Session 不丢失（不过也要注意 Session 在 Redis 中的刷新/失效机制）； 不仅可以跨服务器 Session 共享，甚至可以跨平台（例如网页端和 APP 端）。 你对 RPC、RMI 的理解RPC：在本地调用远程的函数，远程过程调用，可以跨语言实现 httpClient； RMI：远程方法调用，Java 中用于实现 RPC 的一种机制，RPC 的 Java 版本，是 J2EE 的网络调用机制，跨 JVM 调用对象的方法，面向对象的思维方式； 直接或间接实现接口 java.rmi.Remote 成为存在于服务器端的远程对象，供客户端访问并提供一定的服务； 远程对象必须实现 java.rmi.server.UniCastRemoteObject 类，这样才能保证客户端访问获得远程对象时，该远程对象将会把自身的一个拷贝以 Socket 的形式传输给客户端，此时客户端所获得的这个拷贝称为「存根」，而服务器端本身已存在的远程对象则称之为「骨架」。其实此时的存根是客户端的一个代理，用于与服务器端的通信，而骨架也可认为是服务器端的一个代理，用于接收客户端的请求之后调用远程 方法来响应客户端的请求。 分布式 id 生成方案 UUID 优点： 代码简单，性能好（本地生成，没有网络消耗）； 保证唯一（相对而言，重复概率极低可以忽略）； 缺点： 每次生成的 ID 都是无序的，而且不是全数字，且无法保证趋势递增； UUID 生成的是字符串，字符串存储性能差，查询效率慢，写的时候由于不能产生顺序的 append 操作，需要进行 insert 操作，导致频繁的页分裂，这种操作在记录占用空间比较大的情况下，性能下降比较大，还会增加读取磁盘次数； UUID 长度过长，不适用于存储，耗费数据库性能； ID 无一定业务含义，可读性差。 有信息安全问题，有可能泄露 mac 地址 数据库自增序列 单机 优点： 实现简单，依靠数据库即可，成本小； ID 数字化，单调自增，满足数据库存储和查询性能； 具有一定的业务可读性。（结合业务 code） 缺点： 强依赖 DB，存在单点问题，如果数据库宕机，则业务不可用； DB 生成 ID 性能有限，单点数据库压力大，无法扛高并发场景； 信息安全问题，比如暴露订单量，url查询改一下id查到别人的订单 数据库高可用：多主模式做负载，基于序列的起始值和步长设置，不同的初始值，相同的步长，步长大于节点数 优点： 解决了 ID 生成的单点问题，同时平衡了负载； 缺点： 系统扩容困难：系统定义好步长之后，增加机器之后调整步长困难； 数据库压力大：每次获取一个ID都必须读写一次数据库； 主从同步的时候：电商下单 -&gt; 支付 insert master db select 数据 ，因为数据同步延迟导致查不到这个数据。加 cache(不是最好的解决方式)数据要求比较严谨的话查 master 主库。 Leaf-segment 采用每次获取一个 ID 区间段的方式来解决，区间段用完之后再去数据库获取新的号段，这样一来可以大大减轻数据库的压力核心字段：biz_tag，max_id，step biz_tag 用来区分业务，max_id 表示该 biz_tag 目前所被分配的 ID 号段的最大值，step 表示每次分配的号段长度，原来每次获取 ID 都要访问数据库，现在只需要把 Step 设置的足够合理如 1000，那么现在可以在 1000 个 ID 用完之后再去访问数据库； 基于 Redis、mongoDB、zk 等中间件生成； 雪花算法 生成一个 64bit 的整性数字 第一位符号位固定为 0，41 位时间戳，10 位 workId，12 位序列号位数可以有不同实现 优点： 每个毫秒值包含的 ID 值很多，不够可以变动位数来增加，性能佳（依赖 workId 的实现）。 时间戳值在高位，中间是固定的机器码，自增的序列在低位，整个 ID 是趋势递增的。 能够根据业务场景数据库节点布置灵活挑战 bit 位划分，灵活度高。 缺点： 强依赖于机器时钟，如果时钟回拨，会导致重复的 ID 生成，所以一般基于此的算法发现时钟回拨， 都会抛异常处理，阻止 ID生成，这可能导致服务不可用。 分布式锁解决方案需要这个锁独立于每一个服务之外，而不是在服务里面。 数据库：利用主键冲突控制一次只有一个线程能获取锁，非阻塞、不可重入、单点、失效时间 Zookeeper 分布式锁：zk 通过临时节点，解决了死锁的问题，一旦客户端获取到锁之后突然挂掉（Session 连接断开），那么这个临 时节点就会自动删除掉，其他客户端自动获取锁。临时顺序节点解决惊群效应 Redis 分布式锁：setNX，单线程处理网络请求，不需要考虑并发安全性 所有服务节点设置相同的 key，返回为 0、则锁获取失败 早期版本没有超时参数，需要单独设置，存在死锁问题（中途宕机） 后期版本提供加锁与设置时间原子操作，但是存在任务超时，锁自动释放，导致并发问题，加锁与释放锁不是同一线程问题 ？分布式事务解决方案分布式事务中常见的三种解决方案 如何实现接口幂等性 唯一 id。每次操作，都根据操作和内容生成唯一的 id，在执行之前先判断 id 是否存在，如果不存在则执行后续操作，并且保存到数据库或者 Redis 等; 服务端提供发送 token 的接口，业务调用接口前先获取 token，然后调用业务接口请求时，把 token 携带过去，服务器判断 token 是否存在 Redis 中，存在表示第一次请求，可以继续执行业务，执行业务完成后，最后需要把 Redis 中的 token 删除； 建去重表。将业务中有唯一标识的字段保存到去重表，如果表中存在，则表示已经处理过了； 版本控制。增加版本号，当版本号符合时，才能更新数据； 状态控制。例如订单有状态已支付、未支付、支付中、支付失败，当处于未支付的时候才允许修改为支付中等； zk 与 Eureka 的区别zk：CP 设计(强一致性)，目标是一个分布式的协调系统，用于进行资源的统一管理。 当节点 crash 后，需要进行 leader 的选举，在这个期间内，zk 服务是不可用的。 eureka：AP 设计（高可用），目标是一个服务注册发现系统，专门用于微服务的服务发现注册。 Eureka 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而 Eureka 的客户端在向某个 Eureka 注册时如果发现连接失败，会自动切换至其他节点，只 要有一台 Eureka 还在，就能保证注册服务可用（保证可用性），只不过查到的信息可能不是最新的（不保证强一致性） 同时当 Eureka 的服务端发现 85% 以上的服务都没有心跳的话，它就会认为自己的网络出了问题，就不会从服务列表中删除这些失去心跳的服务，同时 Eureka 的客户端也会缓存服务信息。Eureka 对于服务注册发现来说是非常好的选择。 Spring CloudSpring Cloud 与 Dubbo 的区别 底层协议：Spring Cloud 基于 http 协议，Dubbo 基于 TCP 协议，决定了 Dubbo 的性能相对会比较好； 注册中心：Spring Cloud 使用的 Eureka ，Dubbo 推荐使用 Zookeeper； 模型定义：Dubbo 将一个接口定义为一个服务，Spring Cloud 则是将一个应用定义为一个服务； Spring Cloud是一个生态，而 Dubbo 是 Spring Cloud 生态中关于服务调用一种解决方案（服务治理） Spring Cloud 核心组件及其作用 Eureka：服务注册与发现 注册：每个服务都向 Eureka 登记自己提供服务的元数据，包括服务的 ip 地址、端口号、版本号、通信协议等。Eureka 将各个服务维护在了一个服务清单中（双层 Map，第一层 key 是服务名，第二层 key 是实例名，value 是服务地址加端口）。同时对服务维持心跳，剔除不可用的服务，Eureka 集群各节点相互注册每个实例中都有一样的服务清单。 发现：Eureka 注册的服务之间调用不需要指定服务地址，而是通过服务名向注册中心咨询，并获取所有服务实例清单(缓存到本地)，然后实现服务的请求访问； Ribbon：服务间发起请求的时候，基于 Ribbon 做负载均衡，从⼀个服务的多台机器中选择⼀台（被调用方的服务地址有多个）， Ribbon 也是通过发起 http 请求，来进行的调用，只不过是通过调用服务名的地址来实现的。虽然说 Ribbon 不用去具体请求服务实例的 ip 地址或域名了，但是每调用一个接口都还要 手动去发起 Http 请求； Feign：基于 Feign 的动态代理机制，根据注解和选择的机器，拼接请求 URL 地址，发起请求 ，简化服务间的调用，在 Ribbon 的基础上进行了进一步的封装。单独抽出了一个组件，就是 Spring Cloud Feign。 在引入 Spring Cloud Feign 后，我们只需要创建一个接口并用注解的方式来配置它，即可完成对服务提供方的接口绑定。 Hystrix：发起请求是通过 Hystrix 的线程池来⾛的，不同的服务⾛不同的线程池，实现了不同服务调⽤的隔离，通过统计接口超时次数返回默认值，实现服务熔断和降级； Zuul：如果前端、移动端要调⽤后端系统，统⼀从 Zuul ⽹关进⼊，由 Zuul ⽹关转发请求给对应的服务， 通过与 Eureka 进行整合，将自身注册为 Eureka 下的应用，从 Eureka 下获取所有服务的实例，来进行服务的路由。Zuul 还提供了一套过滤器机制，开发者可以自己指定哪些规则的请求需要执行校验逻辑，只 有通过校验逻辑的请求才会被路由到具体服务实例上，否则返回错误提示。 新架构： 服务注册中心 Nacos 负载均衡 loadbalancer 服务调用 OpenFeign 服务网关 Gateway 服务降级 Sentienl 服务配置 Nacos 分布式事务 Seata Hystrix什么是 Hystrix，简述实现机制分布式容错框架 阻止故障的连锁反应，实现熔断； 快速失败，实现优雅降级； 提供实时的监控和告警 资源隔离：线程隔离，信号量隔离 线程隔离：Hystrix 会给每一个 Command 分配一个单独的线程池，这样在进行单个服务调用的时候，就可以在独立的线程池里面进行，而不会对其他线程池造成影响； 信号量隔离：客户端需向依赖服务发起请求时，首先要获取一个信号量才能真正发起调用，由于信号量的数量有限，当并发请求量超过信号量个数时，后续的请求都会直接拒绝，进入 fallback 流 程。信号量隔离主要是通过控制并发请求量，防止请求线程大面积阻塞，从而达到限流和防止雪崩的目的。 熔断和降级：调用服务失败后快速失败 熔断是为了防止异常不扩散，保证系统的稳定性； 降级：编写好调用失败的补救逻辑，然后对服务直接停止运行，这样这些接口就无法正常调用，但又不至于直接报错，只是服务水平下降； 断路器的三种状态 关 Close：流量正常进入 开 Open：拒绝所有流量，调用降级逻辑 半开 Half-Open：Open 状态过一段时间（默认 5s）转为此状态来尝试恢复。此状态时：允许有且仅一个请求进入，一旦请求成功就关闭断路器。请求失败就到 Open 状态（这样再过 5 秒才能转到半开状态） EurekaEureka 结构 Eureka 的二级缓存Eureka Server 的数据存储分了两层：数据存储层和缓存层。数据存储层记录注册到 Eureka Server 上的服务信息，缓存层是经过包装后的数据，可以直接在 Eureka Client 调用时返回。我们先来看看数据存储层的数据结构。 Eureka Server 的数据存储层是双层的 ConcurrentHashMap，我们知道 ConcurrentHashMap 是线程安全高效的 Map 集合。 第一层的 ConcurrentHashMap 的 key=spring.application.name 也就是客户端实例注册的应用名；value 为嵌套的 ConcurrentHashMap。 第二层嵌套的 ConcurrentHashMap 的 key=instanceId 也就是服务的唯一实例 ID，value 为 Lease 对象，Lease 对象存储着这个实例的所有注册信息，包括 ip 、端口、属性等。 根据这个存储结构我们可以发现，Eureka Server 第一层都是存储着所有的服务名，以及服务名对应的实例信息，也就是说第一层都是按照服务应用名这个维度来切分存储： Eureka Server 缓存机制程序员笔记|详解Eureka 缓存机制 - 宜信技术 - 博客园 (cnblogs.com) Eureka Server 为了提供响应效率，提供了两层的缓存结构，将 Eureka Client 所需要的注册信息，直接存储在缓存结构中。 第一层缓存：readOnlyCacheMap，本质上是 ConcurrentHashMap，依赖定时从 readWriteCacheMap 同步数据，默认时间为 30 秒。 readOnlyCacheMap ： 是一个 CurrentHashMap 只读缓存，这个主要是为了供客户端获取注册信息时使用，其缓存更新，依赖于定时器的更新，通过和 readWriteCacheMap 的值做对比，如果数据不一致，则以 readWriteCacheMap 的数据为准。 第二层缓存：readWriteCacheMap，本质上是 Guava 缓存。 readWriteCacheMap：readWriteCacheMap 的数据主要同步于存储层。当获取缓存时判断缓存中是否没有数据，如果不存在此数据，则通过 CacheLoader 的 load 方法去加载，加载成功之后将数据放入缓存，同时返回数据。 readWriteCacheMap 缓存过期时间，默认为 180 秒，当服务下线、过期、注册、状态变更，都会来清除此缓存中的数据。 Eureka Client 获取全量或者增量的数据时，会先从一级缓存中获取；如果一级缓存中不存在，再从二级缓存中获取；如果二级缓存也不存在，这时候先将存储层的数据同步到缓存中，再从缓存中获取。 通过 Eureka Server 的二层缓存机制，可以非常有效地提升 Eureka Server 的响应时间，通过数据存储层和缓存层的数据切割，根据使用场景来提供不同的数据支持。 Eureka 集群配置在两个 Eureka 的配置文件中均配置上另一 Eureka 地址即可： eureka.client.service-url.defaultZone: http://server2:20002/eureka FeignFeign 的实现原理 首先通过 @EnableFeignCleints 注解开启 FeignCleint 根据 Feign 的规则实现接口，并加 @FeignCleint 注解 程序启动后，会进行包扫描，扫描所有的 @FeignCleint 的注解的类，并将这些信息注入到 IoC 容器中。 当接口的方法被调用，通过 JDK 的代理，来生成具体的 RequesTemplate RequesTemplate 再生成 Request Request 交给 Client 去处理，其中 Client 可以是 HttpUrlConnection、HttpClient 也可以是 Okhttp 最后 Client 被封装到 LoadBalanceClient 类，这个类结合类 Ribbon 做到了负载均衡。","link":"/064a78053560/"},{"title":"集合","text":"集合面试题 基础分类集合按照其存储结构可以分为两大类 单列集合 java.util.Collection java.util.List：List 的特点是元素有序、元素可重复。主要实现类有 java.util.ArrayList 和 java.util.LinkedList ``java.util.Set：Set 的特点是元素无序，而且不可重复。主要实现类有 java.util.HashSet和java.util.TreeSet` 双列集合 java.util.Map 线程安全的集合 Vector：比 Arraylist 多了个 synchronized（线程安全），因为效率较低，现在已经不太建议使用。 hashTable：就比 HashMap 多了个 synchronized (线程安全)，不建议使用。 ConcurrentHashMap：是 Java5 中支持高并发、高吞吐量的线程安全 HashMap 实现。它由 Segment 数组结构和 HashEntry 数组结构组成。Segment 数组在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键-值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap 类似，是一种数组和链表结构；一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素；每个 Segment 守护着一个 HashEntry 数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的 Segment 锁。（推荐使用） 什么是 Hash 算法哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。 数组123int[] arr = new int[3];int[] arr = new int[]{1,2,3,4,5};int[] arr = {1,2,3,4,5}; Set不包含重复元素的 Collection 参考资料：Set接口及其实现类_但行好事 无问西东-CSDN博客_set接口的主要实现类 HashSetHashSet 实现 Set 接口，底层数据结构由哈希表（实际上是一个 HashMap 实例）支持，不是线程安全的，默认初始容量是 16，加载因子是0.75。它不保证 Set 的存取顺序。此类允许使用 null 元素。 唯一性与无序性 当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值； 然后根据 hashCode 值决定该元素所处的对象数组中的索引值，确定要放入集合的元素的值是否和该索引处的链表上的各个元素相等， 如果 hashCode 不相等，就将该元素链接在表尾； 如果 hashCode 相等，就不会链接，通过这样就确保了集合中的元素的唯一性； 也正是因为在存的过程中会通过哈希值来确定在数组位置的索引，所以实现的无序性。 去重原理调用被添加元素的 hashCode() 与 HashSet 中已有元素的 hashCode() 比较是否相同： 不相同：直接存储 相同：调用 equals() 方法比较是否相同 不相同：直接存储元素 相同：认为是同一元素，不存储 无序性LinkedHashSet底层数据结构有两个： 链表：保证存取顺序 哈希表：保证元素唯一 TreeSet底层数据结构是二叉树，集合中元素唯一，并且可以对元素进行排序。 排序 自然排序：构造器空参构造 比较器排序：构造器有参构造 注意：实现自然排序需要元素自身实现 Comparable 接口并重写 comPareTo 方法，根据此方法返回值来确定元素在二叉树的位置，否则无法进行自然排序，Integer 已经实现该类 123public TreeSet(Comparator&lt;? super E&gt; comparator) { this(new TreeMap&lt;&gt;(comparator));} List 有序的集合； 带有索引的集合：通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）； 可以有重复的元素，通过元素的 equals() 方法，来比较是否为重复的元素； 允许插入 null； 常见的实现：ArrayList, LinkedList ArrayList非同步，实现了可变大小的元素数组 使用数组存储元素 随机访问元素较快，时间复杂度 O(1)，插入移除元素较慢，时间复杂度 O(n) 线程不安全，若需保证线程安全使用 SynchronizedList 和 CopyOnWriteArrayList 代替 继承于 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable 实现了List：使得具有 List 集合的特性； 实现了 Deque 接口：使得 LinkedList 类也具有队列的特性； 实现了 Cloneable：表示能被克隆； 实现了 java.io.Serializable：表示支持序列化。 并发下的可能问题添加元素越界 IndexOutOfBoundsException 若当前 elementData 数组长度为 2，size=1 (即初始化了一个长度为 2 的 ArrayList，并且已经添加了一个元素)， 此时存在多个线程同时对该 ArrayList 执行 add 极端情况下则可能会出现该情形： calculateCapacity 方法判断是否需要扩容时，结果均为不需要扩容，而在 elementData[size++]=e 对 size 赋值时，size 的值会超出当前数组范围，产生越界异常 IndexOutOfBoundsException。看如下示例： 点击展开代码 >folded12345678910111213141516171819public static void main(String[] args) { ArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;(1); new Thread(() -&gt; { for (int i = 0; i &lt; 1000000; i++) { a.add(1); } }).start(); new Thread(() -&gt; { for (int i = 0; i &lt; 1000000; i++) { a.add(1); } }).start(); new Thread(() -&gt; { for (int i = 0; i &lt; 1000000; i++) { a.add(1); } }).start();} 并发修改异常 ConcurrentModificationException 若某个线程正在修改一个 ArrayList，同时另外存在一个线程则遍历该 ArrayList，则会出现该异常，如下对上边的案例做了下修改，减少了添加元素的数量，同时在后边打印该数组。 点击展开代码 >folded123456789101112131415public static void main(String[] args) { ArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;(1); new Thread(() -&gt; { for (int i = 0; i &lt; 1000; i++) { a.add(1); } }).start(); new Thread(() -&gt; { for (int i = 0; i &lt; 100; i++) { a.add(1); } }).start(); System.out.println(a);} LinkedList 使用链表存储元素 新增插入快，随机查找慢 线程不安全，可以使用 Collections.synchronizedList(new LinkedList(...)); 创建线程安全的 LinkedList 继承自 AbstractSequentialList，实现了 List, Deque, Cloneable, java.io.Serializable 接口 实现了 List：使得具有 List 集合的特性； 实现了 Deque 接口：使得 LinkedList 类也具有队列的特性； 实现了 Cloneable：表示能被克隆； 实现了 java.io.Serializable：表示支持序列化。 VectorStack 什么是 VectorVector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，访问它比访问 ArrayList 慢很多 ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。ArrayList 的缺点是每个元素之间不能有间隔。 总结ArrayList 与 LinkedList ArrayList 动态数组，需要连续内存，适合随机访问，指定初始容量并且在尾部插入性能比 LinkedList 好； LinkedList 链表，可分散存储，适合插入删除，不适合随机访问，只能用迭代器访问，且注意不要用 indexOf 等返回元素索引，如果该元素不存在，就会遍历整个集合 List 与 Set List 可以允许多个 null 元素，Set 单个 null； List Set 均有迭代器遍历，List 还有 get 方法 ArrayList 和 LinkedList 的区别 数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。 随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。 增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。 内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。 线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全； 综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。 LinkedList 的双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。 Map Map 每个元素由键与值两部分组成 Map 键不能重复，每个键对应一个值 键和值可以为 null Java Map - 掘金 (juejin.cn) Java Map整理 - 掘金 (juejin.cn) HashMapHashMap 扩容机制关于HashMap常见面试考点（底层原理+扩容机制）_撒有啦啦Q的博客-CSDN博客 链表 + 数组，在 JDK8，链表高度达到 8，数组长度超过 64，链表就会转为红黑树，是为了解决哈希碰撞后链表索引效率的问题； 计算 key 的 hash，然后二次 hash 再对数组长度取模，对应到数组下标； 如对应下标无元素，就直接创建 node 存入。 如果有元素，就先进行 equals 比较，相同就取代该元素，不同则判断链表高度插入链表，链表高度达到 8，数组长度超过 64，链表就会转为红黑树，高度低于 6 则会转换回链表； key 为 null 的键值对永远都放在以 table[0] 为头结点的链表中。 默认长度是 16，扩容后的长度必须是 2 的幂； JDK8 以前碰撞节点会在链表头部插入，对于扩容操作后的链表顺序会倒置； JDK8 开始碰撞节点会在链表尾部插入，对于扩容操作后的链表顺序会保持原来的顺序； initialCapacity（初始容量）代表了初始容量，但扩容时还是会按照 2 的幂扩容； loadFactor（加载因子）代表已用容量与总容量的比值，越大对空间利用越充分，但查找效率会降低，太小则会造成空间浪费； HashMap 的长度为什么是 2 的幂次方为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。 这个算法应该如何设计呢？ 我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。 那为什么是两次扰动呢？ 这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的； HashMap 什么情况下线程不安全 put() 时：由于 哈希碰撞的存在，所以可能导致两次 put() 方法同时操作到一条链表的头节点，那么必定有一次 put() 操作的数据会丢失； resize() 时：当多个线程检测到数组容量不够，那么就会各自生成多个新的数组并赋值给底层的 Table，但最终只能有一个成功赋值，其它的都会丢失。而且当某些线程完成赋值，而其它线程刚开始时，就会使用已赋值的 table 作为原始数组，这样也会有问题。 HashMap 的扩容操作是怎么实现的？1、 在 JDK8 中，resize() 方法是在 HashMap 中的键值对大于阀值时或者初始化时，就调用 resize() 方法进行扩容； 2、 每次扩展的时候，都是扩展 2 倍； 3、 扩展后 Node 对象的位置要么在原位置，要么移动到原偏移量两倍的位置。 在 putVal() 中，我们看到在这个函数里面使用到了 2 次 resize() 方法，resize() 方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是 JDK8 版本的一个优化的地方，在 JDK7 中，扩容之后需要重新去计算其 Hash 值，根据 Hash 值对其进行分发，但在 JDK8 版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为 0，重新进行 hash 分配后，该元素的位置要么停留在原始位置，要么移动到 原始位置+增加的数组大小 这个位置上 LinkedHashMap 保证遍历顺序是元素插入的顺序； 遍历有序 ConcurrentHashMap JDK7：ReentrantLock + Segment + HashEntry，一个 Segment 中包含一个 HashEntry 数组，每个 HashEntry 又是一个链表结构； 元素查询：二次 hash，第一次 hash 定位 Segment，第二次 hash 定位元素所在链表的头部； 锁：Segment 分段锁，Segment 继承了 ReentrantLock，锁定操作的 Segment，其余的 Segment 不受影响，并发为 Segment 的个数，可在构造函数指定，数组扩容不影响其余 Segment； get：无需枷锁，volatile 保证 JDK8：synchronized + CAS + Node + 红黑树，Node 的 val 和 next 都用 volatile 修饰，表示可见性，查找、替换、赋值都使用 CAS； 锁：锁链表的 head 节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写操作，并发扩容； 读操作无锁： Node 的 Val 和 next 使用 volatile 修饰，读写线程对该变量互相可见； 数组用 volatile 修饰，保证扩容时被读线程感知； HashTable 在所有方法上添加 synchronized 保证线程安全，全局锁； 不允许 key 与 value 为 null； TreeMap TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。 TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。 TreeMap是线程非同步的。 WeakHashMap改进的 HashMap，实现了「弱引用」，如果一个 key 不被引用，则被 GC 回收 HashEntryPriorityQueue 保证最高或者最低优先级的的元素总是在队列头部； 遍历无序 总结能否使用任何类作为 Map 的 key可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点： 如果类重写了 equals() 方法，也应该重写 hashCode() 方法。 类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。 如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。 用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。 ConcurrentHashMap 和 HashTable 的区别ConcurrentHashMap 是 Java5 中支持高并发、高吞吐量的线程安全 HashMap 实现。它由 Segment 数组结构和 HashEntry 数组结构组成。Segment 数组在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键-值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap 类似，是一种数组和链表结构；一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素；每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。 看不懂？？？很正常，我也看不懂 总结： HashTable 就是实现了 HashMap 加上了 synchronized，而 ConcurrentHashMap 底层采用分段的数组+链表实现，线程安全 ConcurrentHashMap 通过把整个 Map 分为 N 个 Segment，可以提供相同的线程安全，但是效率提升 N 倍，默认提升 16 倍。 并且读操作不加锁，由于 HashEntry 的 value 变量是 volatile 的，也能保证读取到最新的值。 Hashtable 的 synchronized 是针对整张 Hash 表的，即每次锁住整张表让线程独占，ConcurrentHashMap 允许多个修改操作并发进行，其关键在于使用了锁分离技术 扩容：段内扩容（段内元素超过该段对应 Entry 数组长度的 75% 触发扩容，不会对整个 Map 进行扩容），插入前检测需不需要扩容，有效避免无效扩容 LinkedHashMap 和 PriorityQueue 的区别PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 可保证遍历顺序是元素插入的顺序。 ConcurrentHashMap 和 Hashtable 的区别ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。 底层数据结构： JDK7 的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的； 实现线程安全的方式： 1、 在 JDK7 的时候，ConcurrentHashMap（分段锁对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配 16 个 Segment，比 Hashtable 效率提高 16 倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本； 2、 Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。 两者的对比图： 1、 HashTable 2、 JDK1.7的ConcurrentHashMap 3、 JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点） ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题使用了synchronized 关键字，所以 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。 迭代Iterator 是什么Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。 因为所有 Collection 接继承了 Iterator 迭代器 1public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {} Iterator 怎么用123456List&lt;String&gt; list = new ArrayList&lt;&gt;();Iterator&lt;String&gt; it = list.iterator();while(it.hasNext()) { String obj = it.next(); System.out.println(obj);} Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。 迭代器的实现原理当遍历集合时，首先通过调用集合的 iterator() 方法获得迭代器对象，然后使用 hashNext() 方法判断集合中是否存在下一个元素，如果存在，则调用 next() 方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 Iterator 迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，在调用 Iterator 的 next() 方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的 next() 方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用 next() 方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到 hasNext() 方法返回 false，表示到达了集合的末尾，终止对元素的遍历。 我们能自己写一个容器类，然后使用 for-each 循环码？可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。 有几种遍历方式遍历方式有以下几种： for 循环遍历：基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。 迭代器遍历 Iterator：Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。 foreach 循环遍历：foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。 优点是代码简洁，不易出错； 缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。 stream 流也可以实现遍历的功能； 最佳实践： Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。 如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。 如果没有实现该接口，表示不支持 Random Access，如LinkedList。 推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。 集合的快速失败机制 fail-fast是 Java 集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。 例如：假设存在两个线程（线程1、线程2），线程 1 通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制。 原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。 解决办法： 在遍历过程中，所有涉及到改变 modCount 值得地方全部加上 synchronized； 使用 CopyOnWriteArrayList 来替换 ArrayList； 整理数据结构中元素的存取特点 栈：stack，又称堆栈，特点是：先进后出。即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素。 队列：queue，特点是：先进先出。即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素。 数组：Array，是有序的元素序列，对元素的存取特点是： 查找元素快：通过索引，可以快速访问指定位置的元素 增删元素慢 指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。 指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。 链表：linked list，对元素的存取有如下的特点： 多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。 查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素。 增删元素快：增加删除元素均只需要修改连接下个元素的地址即可。 Comparable 和 Comparator 的区别。 Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo() 方法被称为它的自然比较方法。只能在类中实现 compareTo() 一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过 Collections.sort()（和 Arrays.sort()）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Comparator：强行对某个对象进行整体排序。可以将 Comparator 传递给 sort() 方法（如 Collections.sort() 或 Arrays.sort()），从而允许在排序顺序上实现精确控制。还可以使用 Comparator 来控制某些数据结构（如有序 set 或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。 如何实现 Array 和 List 之间的转换 Array 转 List：Arrays.asList(array) List 转 Array：List.toArray() Java 中能创建 volatile 数组么能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。 poll() 和 remove() 的区别poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。","link":"/0588b982f188/"},{"title":"Java 基础","text":"Java 基础 基础理论理论对象是一类事物的具体体现。对象是类的一个实例，具备属性和行为。 类是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。 抽象是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。 抽象方法：加上 abstract 关键字，去掉大括号，直接分号结束。 使用抽象类对象和抽象方法：必须用一个子类来继承抽象，父类不能直接 new 抽象类对象。子类必须实现抽象父类中的所有抽象方法 封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。 构造方法是一种特殊的方法，它是一个与类同名且返回值类型为同名类类型的方法，没有返回类型，甚至连 void 也没有。接口不允许被实例化，所以接口中没有构造方法。不能被 static、final、synchronized、abstract 和 native 修饰。对象的创建就是通过构造方法来完成。类中必定有构造方法，若不写，系统自动添加无参构造方法。Java 自动提供了一个无参数构造方法，一旦自己定义了构造方法，Java 自动提供的默认无参数构造方法就会失效。 继承是多态的前提。没有继承就没有多态。继承主要解决的是：共性抽取。一个类的直接父类只能有唯一一个，但是一个父类可以有很多子类。可以多级继承。 类与对象的关系 类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。 JVM、JRE、JDK、JIT JVM：Java 虚拟机（Java virtual machine），解释 class 文件为机器码，Java 可以多平台运行依赖 JVM； JRE：Java 运行环境（Java Runtime Environment），包含 JVM 与运行所需要的 核心类库，文件结构：bin(JVM)，lib(类库)； JDK：开发工具（Java development kit），开发人员使用，包含 JRE 和开发人员工具； JIT：即时编译（Just In Time compilation），主要的热点代码会被转换为本地代码，这样有利大幅度提高 Java 应用的性能； 开发 Java 程序：需要 JDK 运行 Java 程序：需要 JRE 形参：全称为「形式参数」，是在定义方法名和方法体的时候使用的参数，用于接收调用该方法时传入的实际值。 实参：全称为「实际参数」，是在调用方法时传递给该方法的实际值。 面向对象 面向过程直接高效，面向对象易于复用，扩展、维护。 可以举例洗衣机洗衣服。 封装：标识外部允许使用的成员函数及数据 继承：基于基类的方法，做出自己的改变与拓展 多态：基于对象所属类不同，外部对同一方法调用，可能实际执行逻辑不同 继承 什么叫做类与类的继承，作用是什么？ 就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。 作用是子类复用父类内容。 继承后，父类与子类之间，各成员有什么样的影响？ 成员变量： 不重名，没有影响。 重名，就近使用，使用 super 区分父类变量。 构造方法： 无影响，但是子类构造方法默认调用父类构造方法 成员方法： 不重名，没有影响。 重名，子类重写父类方法。 子类中，如何调用父类的成员？如何使用本类的成员？ 父类成员方法：super.方法名 父类非私有成员变量：super.变量名 子类成员方法：this.方法名 子类成员变量：this.变量名 抽象方法与普通成员方法有什么区别？ 抽象方法使用 abstract 关键字修饰，没有方法体。 成员方法有方法体。 抽象类与普通类有什么区别？ 方法： 抽象类可以包含抽象方法和成员方法。 普通类不可以包含抽象方法，只有成员方法。 对象： 抽象类不可以创建对象。 普通类可以创建对象。 多态 什么叫做多态，条件是什么？ 一类事物的行为，具有多种表现形式。 条件： 继承或者实现【二选一】 方法的重写。 父类引用指向子类对象。 使用多态特性，带来了什么样的好处？ 增强方法的扩展性和复用性。 使用多态特性，注意什么样的弊端？ 由于类型的提升，导致调用子类对象特有的方法，必须向下转型。 OOP 中的 组合、聚合和关联有什么区别？如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。 面向对象的特征有哪些方面？ 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1)、方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2)、对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 接口与抽象类关注本质，使用抽象类，关注操作或功能使用接口。使用抽象类的代价比接口高，因为类只能单继承 抽象类 有普通方法； 成员变量修饰符无限制； 只能单继承； 目的：代码复用； 接口 接口，是 Java 语言中一种引用类型，是方法的集合。 使用 interface 关键定义接口，其中可以定义抽象方法，默认方法，私有方法，静态方法等方法。 只能有 public abstract 方法；只能被 public static final 修饰； 可多实现； 目的：对类的行为进行约束，要求不同的类具有相同的行为（只约束了行为的有无，不对如何实现进行限制） JDK7：常量、抽象方法； JDK8：常量、抽象方法、默认方法、静态方法； JDK9：常量、抽象方法、默认方法、静态方法、私有方法； 区别 抽象类有构造方法，接口没有构造方法； 抽象类可以有普通方法，接口中 JDK 版本不同拥有方法不同； 接口的属性都是 public static final 修饰的，而抽象的不是； 实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。 实现数量：抽象类只能单继承，接口可以多实现； 构造函数：抽象类可以有构造函数；接口不能有。 main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。 访问修饰符：抽象类中的方法可以是任意访问修饰符；接口中的方法默认使用 public 修饰。 Java 程序开发步骤编写、编译、运行 标识符定义在程序中，我们自己定义的内容。比如类的名字、方法的名称、变量的名字、等等。 命名规则 可以包含： 26 个英文字母（区分大小写） 0 - 9 $（美元符号） _（下划线） 不能数字开头 不能是关键字 数据类型四类八种 数据类型 关键字 内存占用 取值范围 对应包装类 包装类默认值 字节型 byte 1 个字节 -128 ~ 127 Byte 0 短整型 short 2 个字节 -32768 ~ 32767 Short 0 整型 int（默认） 4 个字节 -2^31 ~ 2^31-1 Int 0 长整型 long 8 个字节 -2^63 ~ 2^63-1 Long 0 单精度浮点数 float 4 个字节 1.4013E-45 ~ 3.4028E+38 Float 0.0 双精度浮点数 double（默认） 8 个字节 4.9E-324 ~ 1.7977E+308 Double 0.0 字符型 char 2 个字节 0 - 65535 Character ‘’ 布尔类型 boolean 1 个字节 true、false Boolean False 自动转换将取值范围小的类型自动提升为取值范围大的类型 byte、short、char –&gt; int –&gt; long –&gt; float –&gt; double 强制转换数据类型 变量名 = (数据类型) 被转换数值 注意 浮点转成整数，直接取消小数点，会损失数据精度 int 强制转成 short 砍掉 2 个字节，会造成数据丢失 运算符算数运算符 i++：先用后加 ++i：先加再用 独立语句 i++; 与 ++i; 效果相同 逻辑运算符是用来连接两个布尔类型结果的运算符，运算结果都是布尔值 true 或者 false 与：全 true 为 true，一 false 则 false &amp;：运算与，会执行所有判断，即使已经得出结论 &amp;&amp;：短路与，符号左边是 false，右边不再运算 或：全 false 为 false，一 true 则 true |：运算或，会执行所有判断，即使已经得出结论 ||：短路或，符号左边是 true，右边不再运算 == equals hashCode== 指引用是否相同，equals() 指的是值是否相同； ==对比的是栈中的值，即基本数据类型是变量值，引用类型是堆中内存对象的地址； 是判断两个变量或实例是不是指向同一个内存空间，是对内存地址进行比较 equals 是判断两个变量或实例所指向的内存空间的值是不是相同，是对内容进行比较； 对象相等，那么 hashCode 值也相等，equals() 返回值为 true； 有相同 hashCode 不一定相等，所以重写 equals() 时也要重写 hashCode()； hashCode() 的默认行为是对堆上的对象产生独特值，如果没重写，那么该 class 即使指向相同数据，也不会相等； hashcode两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 HashMap 中会有冲突。 相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的 hashcode 值，但是没有关于不相等对象的任何规定。 Object 的 equals 方法String 类中的 equals 方法与 Object 类中的 equals 方法的不同点。 答：String 类中的 equals 方法是用来判断两个对象的内容是否相同，而 Object 类中的 equals 方法是用来判断两个对象是否是同一个对象，所谓同一个对象指的是内存中的同一块存储空间。 正则表达式简述正则表达式及其用途在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。 说明：计算机诞生初期处理的信息几乎都是数值，但是时过境迁，今天我们使用计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。 正则表达式有那些符号 $：匹配字符串结束的位置 ^：匹配字符串开始的位置 *：匹配零次或者多次 +：匹配至少一次 ?：匹配零次或者一次 .：匹配除换行符 \\n 之外的任何单字符 {n}：n 是一个非负整数，匹配确定的 n 次 {n,m}：m 和 n 均为非负整数，表示最多和最少匹配次数，其中 n &lt;= m \\w：匹配单个字符 (a-z, 0-9, _) \\W：与 \\w 相反 \\d：匹配数字 \\D：与 \\d 相反 模块化编程与热插拔OSGi：动态模型系统(Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系统的一系列规范。 OSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGi 的程序很可能可以实现模块级的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企业级程序开发来说是非常具有诱惑力的特性。 OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。 关键字Java 已经定义好的单词，具有特殊含义：public class static void 等 final 类：不可被继承； 方法：不可被子类重写，但是可重载； 变量：被赋值后不可被更改； 类变量：静态初始块、声明指定初始值； 成员变量：非静态初始块、声明、构造器指定初始值； 局部变量：定义时指定或者在后面赋值一次； 基本类型：数值初始化之后不能更改； 引用类型：引用的对象地址不能改变，但是对象内容可以变化； 局部内部类或匿名内部类只能访问局部 final 变量，因为这两种类在编译时会生成 class 文件，故内部类与外部类为同一级别。当外部类方法结束，局部变量会被销毁，但内部类可能还会存在，故内部类访问的是变量的 copy。 gotogoto 是 Java 中的保留字，在目前版本的 Java 中没有使用。 abstract抽象方法 可否被 static 修饰 抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者矛盾； 能否是本地方法 native 本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的； 可否被 synchronized 修饰 synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的； throwthrow 关键字通常用在方法体中，并且抛出一个异常对象。程序在执行到 throw 语句时立即停止，它后面的语句都不执行。 throwsthrows 关键字通常被应用在声明方法时，用来指定可能抛出的异常。多个异常可以使用逗号隔开。当在主函数中调用该方法时，如果发生异常，就会将异常对象抛给方法调用处。 字符相关字节8 bit = 1 byte (1B) 1024 B = 1 KB 什么是字节码Java 源代码 –&gt; 编译器 –&gt; JVM 可执行的 Java 字节码（即虚拟指令） –&gt; JVM –&gt; JVM 中的解释器 –&gt; 机器可执行的二进制机器码 –&gt; 程序运行 提供给虚拟机理解的代码叫做字节码（.class）。字节码一定程度解决了传统解释型语言执行效率低的问题，同时保留了可移植的特点，所以 Java 运行比较高效，而且由于字节码只针对虚拟机，所以 Java 一次编译就可以在多钟计算机上运行。 Java 语言采用何种编码方案？有何特点？Java 语言采用 Unicode 编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。 String 为什么要用 final 修饰 效率 只有字符串是不可变时，我们才能实现字符串常量池，字符串常量池可以为我们缓存字符串，提高程序的运行效率； 安全性 当你在调用其他方法时，比如调用一些系统级操作指令之前，可能会有一系列校验，如果是可变类的话，可能在你校验过后，它的内部的值又被改变了，这样有可能会引起严重的系统崩溃问题 StringBuilder 类与 String 类的区别 String 类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象，所以经常改变内容的字符串最好不要用 String，因为每次生成对象都会对系统性能产生影响。 StringBuilder 又称为可变字符序列，是 JDK5 中新增加的一个类，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。即它是一个容器，容器中可以装很多字符串，并且能够对其中的字符串进行各种操作。它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容，StringBuilder 会自动维护数组的扩容。 String、StringBuffer、StringBuilder String 是 final 修饰的，不可变； StringBuffer 线程安全，方法都是 synchronized 修饰的； 经常改变字符串内容时使用 StringBuffer 或 StringBuilder，优先使用 StringBuilder，多线程使用共享变量时使用 StringBuffer； StringBuffer，StringBuilder有什么区别？StringBuffer与StringBuilder都继承了AbstractStringBulder类，而AbtractStringBuilder又实现了CharSequence接口，两个类都是用来进行字符串操作的。 在做字符串拼接修改删除替换时，效率比string更高。 StringBuffer是线程安全的，Stringbuilder是非线程安全的。所以Stringbuilder比stringbuffer效率更高，StringBuffer的方法大多都加了synchronized关键字 String str = &quot;aaa&quot;; 与 String str = new String(&quot;aaa&quot;); 一样吗？不一样的。因为内存分配的方式不一样； 第一种是常量，JVM 都将其分配在常量池中。 第二种创建的是一个对象，JVM 将其值分配在堆内存中。 字节流与字符流的区别1、 以字节为单位输入输出数据，字节流按照8位传输 2、 以字符为单位输入输出数据，字符流按照16位传输 String、StringBuffer、StringBuilder String 是 final 修饰的，不可变 StringBuffer 线程安全，方法都是 synchronized 修饰的。 经常改变字符串内容时使用 StringBuffer 或 StringBuilder，优先使用 StringBuilder，多线程使用共享变量时使用 StringBuffer。 XMLXML 的 Java 解析有几种方式？ DOM（文档对象模型，Document Object Model）：一次性加载整个文档，生成树形结构。DOM 处理大型文件时其性能下降的非常厉害，这个问题是由 DOM 树结构占用的内存较多造成的，而且 DOM 解析方式必须在解析文件之前把整个文档装入内存，适合对 XML 的随机访问（典型的用空间换取时间的策略）当 XML 文本当较小的时候，可以使用 DOM 解析。 SAX（Simple API for XML）：基于事件的解析方式，解析速度比较快，解析的文档大小理论上是没有限制的。SAX 是事件驱动型的 XML 解析方式，它顺序读取 XML 文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理 XML 文件，适合对 XML 的顺序访问； StAX（JDK6 中引入的新的解析 XML 的方式，Streaming API for XML）：顾名思义，StAX 把重点放在流上，实际上 StAX 与其他解析方式的本质区别就在于应用程序能够把 XML 作为一个事件流来处理。StAX 允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。 还有一些开源的技术可以解析 XML：dom4j 或者 jdom。 XML 的形式与区别？XML 文档定义分为 DTD 和 Schema 两种形式，二者都是对 XML 语法的约束.其本质区别在于 Schema 本身也是一个 XML 文件，可以被 XML 解析器解析，而且可以为 XML 承载的数据定义类型，约束能力较之 DTD 更强大。 虚拟DOM的优劣如何?优点: 保证性能下限: 虚拟 DOM 可以经过 diff 找出最小差异，然后批量进行 patch，这种操作虽然比不上手动优化，但是比起粗暴的 DOM 操作性能要好很多 无需手动操作 DOM: 虚拟 DOM 的 diff 和 patch 都是在一次更新中自动进行的,我们无需手动操作 DOM，极大提高开发效率 跨平台: 虚拟 DOM 本质上是 JavaScript 对象，而 DOM 与平台强相关,相比之下虚拟 DOM 可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等 缺点: 无法进行极致优化: 在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化，比如 VScode 采用直接手动操作 DOM 的方式进行极端的性能优化 JSON如何创建一个对象？使用 {} 实例化一个 JSON 对象，JSON 对象多个元素使用逗号隔开，每个元素都是一个键值对。 类W 内部类 Inner Class什么是Java程序的主类？应用程序和小程序的主类有何不同？一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main（）方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。 一个类文件中能否有多个类？有什么要求？可以。但是只能有一个public类，而且public修饰的类名与文件名必须一致 普通类和抽象类有哪些区别？普通类不能包含抽象方法，抽象类可以包含抽象方法。 抽象类不能直接实例化，普通类可以直接实例化。 内部类与静态内部类的区别？静态内部类相对与外部类是独立存在的，在静态内部类中无法直接访问外部类中变量、方法。如果要访问的话，必须要new一个外部类的对象，使用new出来的对象来访问。但是可以直接访问静态的变量、调用静态的方法； 普通内部类作为外部类一个成员而存在，在普通内部类中可以直接访问外部类属性，调用外部类的方法。 如果外部类要访问内部类的属性或者调用内部类的方法，必须要创建一个内部类的对象，使用该对象访问属性或者调用方法。 如果其他的类要访问普通内部类的属性或者调用普通内部类的方法，必须要在外部类中创建一个普通内部类的对象作为一个属性，外同类可以通过该属性调用普通内部类的方法或者访问普通内部类的属性 如果其他的类要访问静态内部类的属性或者调用静态内部类的方法，直接创建一个静态内部类对象即可。 静态嵌套类静态嵌套类 Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。 点击展开代码 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/ * 扑克类（一副扑克） * @author 骆昊 * */public class Poker { private static String[] suites = {&quot;黑桃&quot;, &quot;红桃&quot;, &quot;草花&quot;, &quot;方块&quot;}; private static int[] faces = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}; private Card[] cards; / * 构造器 * */ public Poker() { cards = new Card[52]; for(int i = 0; i &lt; suites.length; i++) { for(int j = 0; j &lt; faces.length; j++) { cards[i * 13 + j] = new Card(suites[i], faces[j]); } } } / * 洗牌 （随机乱序） * */ public void shuffle() { for(int i = 0, len = cards.length; i &lt; len; i++) { int index = (int) (Math.random() * len); Card temp = cards[index]; cards[index] = cards[i]; cards[i] = temp; } } / * 发牌 * @param index 发牌的位置 * */ public Card deal(int index) { return cards[index]; } / * 卡片类（一张扑克） * [内部类] * @author 骆昊 * */ public class Card { private String suite; // 花色 private int face; // 点数 public Card(String suite, int face) { this.suite = suite; this.face = face; } @Override public String toString() { String faceStr = &quot;&quot;; switch(face) { case 1: faceStr = &quot;A&quot;; break; case 11: faceStr = &quot;J&quot;; break; case 12: faceStr = &quot;Q&quot;; break; case 13: faceStr = &quot;K&quot;; break; default: faceStr = String.valueOf(face); } return suite + faceStr; } }} 测试代码： 点击展开代码 >folded1234567891011121314class PokerTest { public static void main(String[] args) { Poker poker = new Poker(); poker.shuffle(); // 洗牌 Poker.Card c1 = poker.deal(0); // 发第一张牌 // 对于非静态内部类Card // 只有通过其外部类Poker对象才能创建Card对象 Poker.Card c2 = poker.new Card(&quot;红心&quot;, 1); // 自己创建一张牌 System.out.println(c1); // 洗牌后的第一张 System.out.println(c2); // 打印: 红心A }} 面试题 - 下面的代码哪些地方会产生编译错误？ 123456789101112class Outer { class Inner {} public static void foo() { new Inner(); } public void bar() { new Inner(); } public static void main(String[] args) { new Inner(); }} 注意：Java中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做： 1new Outer().new Inner(); 构造器 constructor 是否可被重写 override构造器不能被继承，因此不能被重写，但可以被重载。 成员变量与局部变量的区别 从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；成员变量和局部变量都能被final所修饰； 从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。 类与对象 一个类与它的对象之间的关系： 类是对象的模板，对象是类的实体 类的三部分及其作用： 成员变量:描述事物的状态信息 构造方法:创建事物对象 成员方法:描述事物能做什么 创建并使用对象： 12345// 创建对象格式: 数据类型 变量名 = new 数据类型();// 对象使用方式: 变量名.成员变量 变量名.成员方法 局部变量和成员变量的区别？ 在类中的位置不同 成员变量：类中，方法外 局部变量：方法中或者方法声明上(形式参数) 作用范围不一样 成员变量：类中 局部变量：方法中 初始化值的不同 成员变量：有默认值 局部变量：没有默认值。 在内存中的位置不同 成员变量：堆内存 局部变量：栈内存 生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 构造方法和成员方法的区别？ 作用不同: 构造方法:创建对象 成员方法:执行某具体功能 命名不同: 构造方法:类名一致 成员方法:自定义 返回值类型不同: 构造方法:无返回值类型 成员方法:void或者确定的数据类型 调用不同: 构造方法:new 关键字调用 成员方法:对象.成员方法名调用 重载重构重写重构 通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理。提高软件的扩展性和维护性。通俗点说，重构就是当你发现代码的不足之处时，去改动它的结构，去优化它。 重写 Override 方法的名称一样，参数列表也一样。 子类（派生类）通过 @Override 来实现方法重写父类（基类）。 在父类里声明了一个模糊的方法，并不给出详细的行为，在子类里，通过重写父类（同方法名，參数，返回值等）中的这种方法，让这种方法实例化，去适合子类。 必须是在父子类继承里； 方法名、返回值类型、参数个数和参数类型都必须相同； 子类重写的方法的访问修饰符大于等与父类； 子类抛出的异常范围小于等与父类； 子类不能重写 private 修饰的父类方法 重载 Overload 方法名相同，参数类型、个数、顺序、方法返回值、访问修饰符可以不同 在一个静态方法内调用一个非静态成员为什么是非法的？由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。 构造方法构造方法主要作用是完成对类对象的初始化工作。一个类没有声明构造方法也可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。 阐述静态变量和实例变量的区别静态变量是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝； 实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。 补充：在 Java 开发中，上下文类和工具类中通常会有大量的静态成员。 异常Error 错误：表示不可修复的恶性的错误，只能通过修改代码规避错误的产生，通常是系统级别的。 Expection 异常：表示可修复的良性（相对于错误）的异常，异常产生后程序员可以并且应该通过代码的方式纠正，使程序继续运行，是必须要处理的。 异常的继承体系异常的根类是 java.lang.Throwable，其下有两个子类： java.lang.Error java.util.Exception 而 Exception 又分为 编译时期异常：checked 异常，编译代码时会报错中断； 运行时期异常：runtime 异常，仅在运行时中断； 异常的处理方式问题： 异常处理方式有几种,分别是什么? 详细阐述每种方式对异常是如何处理的 答： 异常的处理方式有两种，分别是使用 throws 和try…catch…finally throws 用在方法的声明上后接异常类名，是把异常抛给调用者进行处理 try…catch…finally 是捕获异常，自己处理，处理完毕后面的程序可以继续运行 try 代码块中是可能出现异常的代码 catch 代码块，是遇到异常，对异常进行处理的代码 finally 代码块是无论是否发生异常，都必须执行的代码，用于释放资源 受检查异常和不受检查异常区别受检查异常：编译器在编译期间检查。对于这种异常，方法强制处理或者通过 throws 子句声明。或异常是 Exception 的子类但不是 RuntimeException 的子类。 非受检查异常（运行时异常）：RuntimeException 的子类，在编译阶段不受编译器的检查。 常见异常及产生原因 NullPointerException 空指针异常：调用 null 对象的实例方法、访问 null 对象的属性、计算 null 对象的长度等等。 ArrayIndexOutOfBoundsException 数组索引越界异常：当对数组的索引值为负数或大于等于数组大小时抛出此异常。 ArithmeticException 算术运算异常：除以零； NumberFormatException 数字格式异常：当试图将一个 String 转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。 ClassCastException 类转换异常 SecurityException 安全异常 IllegalArgumentException 非法参数异常 WebServlet 生命周期内调用的方法过程 Init() Service() doGet() 或者 doPost() destroy() Servlet 的生命周期 加载：判断 servlet 实例是否存在，如果不存在，就加载 serlvet 实例化： 初始化 服务 销毁 什么是 Web Service从表面上看，Web Service 就是一个应用程序，它向外界暴露出一个能够通过 Web 进行调用的 API。这就是说，你能够用编程的方法透明的调用这个应用程序，不需要了解它的任何细节，跟你使用的编程语言也没有关系。例如可以创建一个提供天气预报的 Web Service，那么无论你用哪种编程语言开发的应用都可以通过调用它的 API 并传入城市信息来获得该城市的天气预报。之所以称之为 Web Service，是因为它基于 HTTP 协议传输数据，这使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。 其他float f = 3.4; 是否正确？不正确。3.4 是双精度数，将双精度型 double 赋值给浮点型 float 属于下转型 down-casting，也称为窄化，会造成精度损失。 因此需要强制类型转换 float f = (float) 3.4; 或者写成 float f = 3.4F;。 Java 中，Maven 和 ANT 有什么区别？虽然两者都是构建工具，都用于创建 Java 应用，但是 Maven 做的事情更多，在基于“约定优于配置”的概念下，提供标准的Java 项目结构，同时能为应用自动管理依赖（应用中所依赖的 JAR 文件），Maven 与 ANT 工具更多的不同之处请参见。 Java中如何实现序列化，有什么意义？序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。 要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆（可以参考第29题）。","link":"/de4a65c796a3/"},{"title":"线程","text":"线程面试题 基础♥Java并发知识体系详解♥ | Java 全栈知识体系 (pdai.tech) 并发的三大特性 原子性：最小的操作单元，原子性指的是一个或多个操作要么全部执行成功要么全部执行失败 synchronized 可见性：多个线程访问同一个变量时，一个线程修改了这个值，其他线程能立马看到修改的值； volatile、synchronized、final 有序性：程序执行的顺序按照代码的先后顺序执行（处理器可能会对指令进行重排序：对那些改变顺序后不会对最终结果造成影响的代码，有可能将他们重排，实际上，有些代码重排后对变量值没影响，但可能会出现线程安全问题） volatile、synchronized 并发 并行 串行 串行在时间上不能重叠，前一个任务没执行完，第二个任务不会执行； 并行在时间上重叠的，两个任务在同一时刻互不干扰的运行； 并发允许两个任务彼此干扰，同一时间点只有一个任务运行，交替执行； 通俗易懂版： 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。 Threrad Runable 的区别 Thread 是类，复杂的多线程选择继承 Thread Runable 是接口，简单的执行任务实现 Runable； 两个线程间共享数据在两个线程间共享变量即可实现共享。 一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。 什么是自旋很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。 忙循环：就是程序员用循环让一个线程等待，不像传统方法 wait(), sleep() 或 yield() 它们都放弃了 CPU 控制，而忙循环不会放弃 CPU，它就是在运行一个空循环。这么做的目的是为了保留 CPU 缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。 什么是上下文切换 多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。 概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。 上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。 Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。 常用的并发工具类有哪些 CountDownLatch CyclicBarrier Semaphore Exchanger 线程和进程区别进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。 一个程序至少有一个进程,一个进程至少有一个线程。 什么是线程和进程? 进程 一个在内存中运行的应用程序。 每个正在系统上运行的程序都是一个进程 线程 进程中的一个执行任务（控制单元）， 它负责在程序里独立执行。 一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据 进程与线程的区别 1、 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位 2、 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。 3、 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。 4、 内存分配：同一进程的线程共享本进程的地址空间和资源，而进程与进程之间的地址空间和资源是相互独立的 5、 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃有可能导致整个进程都死掉。所以多进程要比多线程健壮。 6、 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行 进程概念、线程概念、线程与进程联系进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。 线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 一个程序运行后至少有一个进程，一个进程中可以包含多个线程,但一个进程中至少包含一个线程。比如使用迅雷软件下载网络文件时，同时下载多个文件，就使用到了多线程下载。 多线程的出现是要解决什么问题的?众所周知，CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为： CPU 增加了缓存，以均衡与内存的速度差异；（导致 可见性 问题） 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；（导致 原子性 问题） 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。（导致 有序性 问题） 线程W 线程状态 NEW 新建：线程刚被创建，但是并未启动。 Runnable 就绪：线程对象创建后，当调用线程对象的 start() 方法，该线程处于就绪状态，等待被线程调度选中，获取 CPU 的使用权（线程要想进入运行状态执行，首先必须处于就绪状态中） Running 运行：可运行状态 runnable 的线程获得了 CPU 时间片 timeslice，执行程序代码； Blocked 锁阻塞：处于运行状态中的线程由于某种原因，暂时放弃对 CPU 的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被 CPU 调用以进入到运行状态； 等待阻塞：运行状态中的线程执行 wait() 方法，JVM 会把该线程放入等待队列 waitting queue 中，使本线程进入到等待阻塞状态； 同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，，则 JVM 会把该线程放入锁池 lock pool 中，线程会进入同步阻塞状态； 其他阻塞：通过调用线程的 sleep() 或 join() 或发出了 I/O 请求时，线程会进入到阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。 等待 Waiting 无限等待：一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用 notify() 或者 notifyAll() 方法才能够唤醒。 Timed Waiting 计时等待：同 waiting 状态，有几个方法有超时参数，调用他们将进入 Timed Waiting 状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep()、Object.wait()。 Dead 死亡：因为 run() 方法正常退出而死亡，或者因为没有捕获的异常终止了 run() 方法而死亡，死亡的线程不可再次复生。 守护线程 为所有非守护线程提供服务的线程，任何守护线程都是整个 JVM 的非守护线程的保姆； 例子：GC 垃圾回收线程； 为其他线程提供服务支持； thread.setDaemon(true) 必须在线程执行前设置，否则会抛出 IllegalThreadException 异常，不能将正在运行的常规线程设置为守护线程； 守护线程不能去访问固有资源，比如写操作或者计算逻辑，因为随时有可能退出； Java 自带的多线程框架，比如 ExecutorService，会将守护线程转换为用户线程，所以使用守护线程就不能使用 Java 的线程池； 线程安全 指的是内存安全，堆是共享内存，可以被所有线程访问 当多个线程访问一个对象时，如果不进行额外的同步控制或者其他的协调操作，调用这个对象的行为都可以得到预期的结果或单线程执行的结果，那么就说这个对象是线程安全的； 堆是进程和线程的共有空间，全局堆（未分配空间）和局部堆（用户分配空间）；堆在操作系统对进程初始化时分配，运行过程中也可以向系统要额外的堆，但用完了还，否则会内存泄漏； 堆是 Java 虚拟机管理的最大的一块内存，堆存在的目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存； 栈是每个线程独有的，保存运行状态以及局部自动变量，栈在线程开始时初始化，每个线程的栈互相独立，因此栈是线程安全的，操作系统在切换线程时会自动切换栈，栈空间不需要在高级语言中显式的分配与释放； 线程的生命周期 创建：新建了一个线程对象； 就绪：线程创建完成后，其他线程调用该对象的 start 方法，该线程位于可运行线程池中，变得可运行，等待 CPU 的使用权； 运行：就绪状态的线程获取了 CPU，执行程序代码； 阻塞：线程因为某种原因放弃 CPU 使用权，暂时终止运行，直到线程进入就绪状态，才有机会转为运行状态； 等待阻塞：运行线程的 Object.wait() 方法，释放占用资源，JVM 会把该线程放入等待池中，不能被自动唤醒，依赖其他线程的 notify() 或 notifyAll() 才能唤醒； 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，JVM 会把该线程放入锁池中； 其它阻塞：运行线程执行 Thread.sleep() 或 join() 方法或发出 I/O 请求时，JVM 会把该线程设置为阻塞状态，当 sleep 超时、join 等待线程终止或超时、I/O 处理完成时线程进入就绪状态。 死亡：线程执行完成或因异常退出，结束线程生命周期； 线程的调度策略线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行： 线程体中调用了 yield() 方法让出了对 CPU 的占用权利 线程体中调用了 sleep() 方法使线程进入睡眠状态 线程由于 IO 操作受到阻塞 另外一个更高优先级线程出现 在支持时间片的系统中，该线程的时间片用完 线程的几种实现方法 继承 Thread 类，重写 run() 函数； 实现 Runnable 接口，重写 run() 函数； 实现 Callable 接口，重写 call() 函数（可通过调用 FutureTast.get() 获取线程结果）； 都是调用 start() 方法启动线程。 线程优先级的理解 每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int 变量(从1-10)，1 代表最低优先级，10 代表最高优先级。 Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。 如何停止一个正在运行的线程？在java中有以下3种方法可以终止正在运行的线程： 1、 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。 2、 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。 3、 使用interrupt方法中断线程。 唤醒阻塞线程如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。 代码示例： 1234567891011121314151617181920212223242526package com.lijie;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class Test001 { public static void main(String[] args) { //创建线程池 ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue &lt; &gt; (3)); for (int i = 1; i &lt;= 6; i++) { TaskThred t1 = new TaskThred(&quot;任务&quot; + i); //executor.execute(t1);是执行线程方法 executor.execute(t1); } //executor.shutdown()不再接受新的任务，并且等待之前提交的任务都执行完再关闭，阻塞队列中的任务不会再执行。 executor.shutdown(); }}class TaskThred implements Runnable { private String taskName; public TaskThred(String taskName) { this.taskName = taskName; } public void run() { System.out.println(Thread.currentThread().getName() + taskName); }} 线程运行时发生异常如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM 会使用 Thread.getUncaughtExceptionHandler()来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException()方法进行处理。 线程调度算法计算机通常只有一个 CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU 的使用权才能执行指令。所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待 CPU，JAVA 虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配 CPU 的使用权。（Java是由JVM中的线程计数器来实现线程调度） 有两种调度模型： 分时调度模型和抢占式调度模型。 分时调度模型是指让所有的线程轮流获得 cpu 的使用权，并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。 Java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU 线程异步 线程同步 线程同步：同时只有一条线程执行一个任务 线程异步：同时有多条线程可以执行执行任务 锁设计分布式锁需要注意哪些问题 加锁解锁的原子性； 加锁过期时间防止死锁； 守护线程自动给锁续期； 注意避免锁被别的客户端释放； 执行顺序 放进队列； 使用 redis watch 事务加时间戳； 死锁死锁不仅仅是 Java 的问题，实际上是一个操作系统上的问题。指两个或以上的线程在执行过中，因为抢夺资源而造成的一种互相等待现象，若无外力作用，它们都无法继续执行下去。死锁形成需要满足以下条件： 互斥：一个资源每次只能被一个进程使用； 请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放； 不剥夺：进程已获得的资源，在未使用完之前，不能强行剥夺； 循环等待：若干进程之间形成一种头尾相接的循环等待资源的关系； 什么是线程死锁 死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。 多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。 Java死锁以及如何避免？Java 中的死锁是一种编程情况，其中两个或多个线程被永久阻塞，Java 死锁情况出现至少两个线程和两个或更多资源。 Java 发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？悲观锁： 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。 乐观锁： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。 volatilevolatile 能使得一个非原子操作变成原子操作吗？1、 关键字volatile的主要作用是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同一个实例变量需要加锁进行同步。 2、 虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double可以保证其操作原子性。 所以从Oracle Java Spec里面可以看到： 1、 对于64位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时候，可以分成两步，每次对32位操作。 2、 如果使用volatile修饰long和double，那么其读写都是原子操作 3、 对于64位的引用地址的读写，都是原子操作 4、 在实现JVM时，可以自由选择是否把读写long和double作为原子操作 5、 推荐JVM实现为原子操作 volatile 修饰符的有过什么实践？一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。 volatile 关键字的作用 对于可见性，Java 提供了 volatile 关键字来保证可见性和禁止指令重排。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile修饰时，它会保证修改的值会立即被更新到主内存中，当有其他线程需要读取时，它会去内存中读取新值。 从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。 volatile 常用于多线程环境下的单次操作(单次读或者单次写)。 synchronized线程安全(上)–彻底搞懂synchronized(从偏向锁到重量级锁) (qq.com) synchronized 修饰方法和同步代码块有什么区别Synchronized修饰方法和同步代码块的区别_askcto的博客-CSDN博客 Synchronized 修饰实例方法或静态方法都是通过标识 ACC_SYNCHRONIZED 实现同步。 同步代码块是是采用 monitorenter、monitorexit 两个指令来实现同步。 简述 synchronized 和 Lock 的异同java.util.concurrent.locks.Lock 是 JDK5 以后引入的新的 API。 和关键字 synchronized 相比 主要相同点：Lock 能完成 synchronized 所实现的所有功能； 主要不同点：Lock 有比 synchronized 更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且最好在 finally 块中释放（这是释放外部资源的最好的地方）。 当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？如果其他方法没有synchronized的话，其他线程是可以进入的。 所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。 ReentrantLock什么是可重入锁 ReentrantLock举例来说明锁的可重入性 12345678910111213public class UnReentrant{ Lock lock = new Lock(); public void outer(){ lock.lock(); inner(); lock.unlock(); } public void inner(){ lock.lock(); // do something lock.unlock(); }} outer 中调用了 inner，outer 先锁住了 lock，这样 inner 就不能再获取 lock。其实调用 outer 的线程已经获取了 lock 锁，但是不能在 inner 中重复利用已经获取的锁资源，这种锁即称之为不可重入可重入就意味着：线程可以进入任何一个它已经拥有的锁所同步着的代码块。 Synchronized、ReentrantLock 都是可重入的锁，可重入锁相对来说简化了并发编程的开发 ThreadLocalThreadLocal 内存泄漏的原因，怎么避免与四种引用Java多线程编程-（9）-ThreadLocal造成OOM内存溢出案例演示与原理分析_徐刘根的博客-CSDN博客_threadlocal内存溢出 内存泄漏就是不再使用的对象或变量占用的内存不能被回收。 由于 ThreadLocalMap 的生命周期与 Thread 一样长，如果没有手动删除 key 就会导致内存泄漏。因此每次使用完 ThreadLocal 都要调用它的 remove() 方法清除数据或将 ThreadLocal 变量定义为 private static，这样就一直存在 ThreadLocal 的强引用，也就能保证任何时候都能通过 ThreadLocal 的弱引用访问到 Entry 的 value，进而清除掉； 强引用：使用最普遍的引用 new，一个对象具有强引用，不会被回收，当内存不足，Java 虚拟机宁愿抛出 OutOfMemoryError 使程序终止也不会回收这种对象； 软引用 SoftReference：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它； 弱引用 WeakReference：JVM 垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象，可以在缓存中使用弱引用； 虚引用 PhantomReference：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。 ThreadLocal 的原理和使用场景 每个 Thread 对象中均含有一个由 Entry 对象构成的 ThreadLocalMap 类型的成员变量，它时 Thread 的内部类，存储本线程中所有 ThreadLocal 对象机器对应对的值； Entry 继承自 WeakRederence&lt;ThreadLocal&lt;?&gt;&gt; 一个 Entry 的 key 是 ThreadLocal 对象，值为 Object，且是弱引用，当没指向 key 的强引用后，该 key 就会被垃圾回收器回收； 执行 set/get 方法时，ThreadLocal 会先获取当前线程对象，然后获取当前线程的 ThreadLocalMap 对象，再以当前 ThreadLocal 对象为 key，将值存储进 ThreadLocalMap 中或取出； 由于每个线程都有私有的 ThreadLocalMap，因此不存在线程安全性问题，从而无需使用同步机制来保证多条线程访问容器的互斥性； 使用场景： 进行对象跨层传递的时候，使用 ThreadLocal 可以避免多次传输，打破层次间的约束； 线程间数据隔离； 事务操作，存储线程事务信息； 数据库连接，Session 会话信息； Spring 会在事务开始时给当前线程绑定 Jdbc Connection，在整个事务过程中都是使用该线程绑定的 connection 来执行数据库操作，实现了事务的隔离性； 方法Java 中你怎样唤醒一个阻塞的线程？首先 ，wait()、notify() 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行； 其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。 sleep() wait() join() yield() 锁池：所有需要竞争同步锁的线程都会放在锁池当中，当某个线程获得资源后就会进入就绪队列等待 CPU 资源分配； 等待池：当我们调用 wait() 方法后，线程会放到等待池中，线程不会竞争同步锁，只有调用 notify() 或 notifyAll() 后等待池的线程才会开始竞争锁。 notify()：随机从等待池选一个线程到锁池； notifyAll()：将等待池所有线程放到锁池； sleep() 是 Thread 的静态方法，wait() 是 Object 的方法； sleep() 不会释放锁，wait() 会释放锁，并进入等待队列； sleep() 释放执行资格却不会释放锁，而是将锁带着休眠； sleep() 不依赖 synchronized，wait() 依赖； sleep() 不需要被唤醒（休眠之后自动退出），但是 wait() 需要； sleep() 一般用于当前线程休眠，wait() 一般用于多线程之间通信； sleep() 会让出 CPU 执行时间强制上下文切换，而 wait() 不一定，wait() 后还是有可能重新竞争到锁继续执行； yield() 执行后线程直接进入就绪状态，马上释放 CPU 的执行权，但依然保留 CPU 的执行资格，所以有可能 CPU 下次进行线程调度还会让这个线程获取到执行权继续执行； join() 执行后线程进入阻塞状态，例如在线程 B 中调用 线程 A 的 join()，那么线程 B 阻塞，直到线程 A 结束或中断； 为什么wait和notify方法要在同步块中调用？Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。 Thread 类中的 yield 方法有什么作用？使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。 当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。 为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？因为Java所有类的都继承了Object，Java想让任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。 有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。 线程的 sleep() 方法和 yield() 方法有什么区别？ sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； 线程执行 sleep() 方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态； sleep() 方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常； sleep() 方法比 yield() 方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。 为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。 你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。 wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码： 12345678synchronized (monitor) { // 判断条件谓词是否得到满足 while(!locked) { // 等待唤醒 monitor.wait(); } // 处理其他的业务逻辑} 为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object 类里？Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。 Java 中 sleep 方法和 wait 方法的区别？虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。 请描述 Thread 类中的 start() 与 run() 的区别。线程对象调用 run() 方法不开启线程，仅是对象调用方法。线程对象调用 start() 方法开启线程，并让 JVM 调用 run() 方法在开启的线程中执行。 总结同步方法和同步块，哪个是更好的选择？同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。 同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。 请知道一条原则：同步的范围越小越好。 synchronized、volatile、CAS 比较1、 synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。 2、 volatile 提供多线程共享变量可见性和禁止指令重排序优化。 3、 CAS 是基于冲突检测的乐观锁（非阻塞） synchronized 和 Lock 有什么区别？ 首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类； synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。 synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 什么是线程组，为什么在Java中不推荐使用？ThreadGroup类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。 为什么不推荐使用？因为使用有很多的安全隐患吧，没有具体追究，如果需要使用，推荐使用线程池。 同步方法和同步块，哪个是更好的选择？同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。 同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。 多线程的最佳实践这是我在写 Java 并发程序的时候遵循的一些最佳实践： 给线程命名，这样可以帮助调试。 最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。 如果可以，更偏向于使用 volatile 而不是 synchronized。 使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semeaphore。 优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。 在 Java 程序中怎么保证多线程的运行安全？出现线程安全问题的原因一般都是三个原因： 线程切换带来的原子性问题 解决办法：使用多线程之间同步synchronized或使用锁(lock)。 缓存导致的可见性问题 解决办法：synchronized、volatile、LOCK，可以解决可见性问题 编译优化带来的有序性问题 解决办法：Happens-Before 规则可以解决有序性问题 其他W Java 中怎么获取一份线程 dump 文件在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java 应用的 dump 文件。在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。如果你使用Tomcat。 W 线程的基本状态以及状态之间的关系？ Java 中 Semaphore 是什么？Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。 代码怎么唤醒一个阻塞的线程如果线程是因为调用了 wait()、sleep() 或者 join() 方法而导致的阻塞，可以中断线程，并且通过抛出 InterruptedException 来唤醒它；如果线程遇到了 IO 阻塞，无能为力，因为 IO 是操作系统实现的，Java 代码并没有办法直接接触到操作系统。 点击展开代码 >folded12345678910111213141516171819202122232425import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class Test001 { public static void main(String[] args) { // 创建线程池 ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue &lt; &gt; (3)); for (int i = 1; i &lt;= 6; i++) { TaskThred t1 = new TaskThred(&quot;任务&quot; + i); // 是执行线程方法 executor.execute(t1); } // 不再接受新的任务，并且等待之前提交的任务都执行完再关闭，阻塞队列中的任务不会再执行。 executor.shutdown(); }}class TaskThred implements Runnable { private String taskName; public TaskThred(String taskName) { this.taskName = taskName; } public void run() { System.out.println(Thread.currentThread().getName() + taskName); }} 写一段简单的死锁代码这个笔试的话频率也挺高（遇见笔试的公司要三思啊），所以这里直接给出一个答案（有很多版本的）。 点击展开代码 >folded1234567891011121314151617181920212223242526public class DeadLockDemo { public static void main(String[] args) { Object object1 = new Object(); Object object2 = new Object(); Thread t1 = new Thread(() -&gt; { synchronized (object1) { try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (object2) { } } }, &quot;deadlock-demo-1&quot;); t1.start(); Thread t2 = new Thread(() -&gt; { synchronized (object2) { synchronized (object1) { } } }, &quot;deadlock-demo-2&quot;); t2.start(); }} 简单的同步方法示例下面的例子演示了 100 个线程同时向一个银行账户中存入 1 元钱，在没有使用同步机制和使用同步机制情况下的执行情况： 无同步控制银行账户类： 点击展开代码 >folded12345678910111213141516171819202122232425262728293031/* * 银行账户 */public class Account { // 账户余额 private double balance; /* * 存款 * @param money 存入金额 */ public void deposit(double money) { double newBalance = balance + money; try { // 模拟此业务需要一段处理时间 Thread.sleep(10); } catch(InterruptedException ex) { ex.printStackTrace(); } balance = newBalance; } /* * 获得账户余额 */ public double getBalance() { return balance; }} 存钱线程类： 点击展开代码 >folded1234567891011121314151617181920/* * 存钱线程 */public class AddMoneyThread implements Runnable { // 存入账户 private Account account; // 存入金额 private double money; public AddMoneyThread(Account account, double money) { this.account = account; this.money = money; } @Override public void run() { account.deposit(money); }} 测试类： 点击展开代码 >folded123456789101112131415161718192021import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Test01 { public static void main(String[] args) { Account account = new Account(); ExecutorService service = Executors.newFixedThreadPool(100); for(int i = 1; i &lt;= 100; i++) { service.execute(new AddMoneyThread(account, 1)); } service.shutdown(); while(!service.isTerminated()) {} System.out.println(&quot;账户余额: &quot; + account.getBalance()); }} 在没有同步的情况下，执行结果通常是显示账户余额在 10 元以下，出现这种状况的原因是，当一个线程 A 试图存入 1 元的时候，另外一个线程 B 也能够进入存款的方法中，线程 B 读取到的账户余额仍然是线程 A 存入 1 元钱之前的账户余额，因此也是在原来的余额 0 上面做了加 1 元的操作，同理线程 C 也会做类似的事情，所以最后 100 个线程执行结束时，本来期望账户余额为 100 元，但实际得到的通常在 10 元以下（很可能是 1 元哦）。解决这个问题的办法就是同步，当一个线程对银行账户存钱时，需要将此账户锁定，待其操作完成后才允许其他的线程进行操作，代码有如下几种调整方案： synchronized 方法级在银行账户的存款（deposit）方法上同步（synchronized）关键字 点击展开代码 >folded12345678910111213141516171819202122232425262728293031/* * 银行账户 */public class Account { // 账户余额 private double balance; /* * 存款 * @param money 存入金额 */ public synchronized void deposit(double money) { double newBalance = balance + money; try { // 模拟此业务需要一段处理时间 Thread.sleep(10); } catch (InterruptedException ex) { ex.printStackTrace(); } balance = newBalance; } /* * 获得账户余额 */ public double getBalance() { return balance; }} synchronized 字段级在线程调用存款方法时对银行账户进行同步 点击展开代码 >folded12345678910111213141516171819202122/ * 存钱线程 */public class AddMoneyThread implements Runnable { // 存入账户 private Account account; // 存入金额 private double money; public AddMoneyThread(Account account, double money) { this.account = account; this.money = money; } @Override public void run() { synchronized (account) { account.deposit(money); } }} ReentrantLock 锁对象通过 JDK5 显示的锁机制，为每个银行账户创建一个锁对象，在存款操作进行加锁和解锁的操作 点击展开代码 >folded12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/* * 银行账户 */public class Account { private Lock accountLock = new ReentrantLock(); // 账户余额 private double balance; /* * 存款 * * @param money 存入金额 */ public void deposit(double money) { accountLock.lock(); try { double newBalance = balance + money; try { // 模拟此业务需要一段处理时间 Thread.sleep(10); } catch (InterruptedException ex) { ex.printStackTrace(); } balance = newBalance; } finally { accountLock.unlock(); } } /* * 获得账户余额 */ public double getBalance() { return balance; }} 按照上述三种方式对代码进行修改后，重写执行测试代码 Test01，将看到最终的账户余额为 100 元。当然也可以使用 Semaphore 或 CountdownLatch 来实现同步。 拓展你如何理解 fiberReact Fiber 是一种基于浏览器的单线程调度算法. React 16 之前 ，reconcilation 算法实际上是递归，想要中断递归是很困难的，React 16 开始使用了循环来代替之前的递归. Fiber：一种将 recocilation （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。","link":"/67a1548e8c24/"},{"title":"MySQL","text":"MySQL 面试题 待解答方向：MySQL 事务得清楚，事务隔离级别得清楚，索引问题，SQL 优化多少知道一点不过分啊。 ♥MySQL知识体系详解♥ | Java 全栈知识体系 (pdai.tech) 『浅入浅出』MySQL 和 InnoDB MySQL 索引设计概要 - 面向信仰编程 (draveness.me) 『浅入深出』MySQL 中事务的实现 为什么 MySQL 的自增主键不单调也不连续 - 面向信仰编程 (draveness.me) 如何从 MongoDB 迁移到 MySQL - 面向信仰编程 (draveness.me) MySQL 索引设计概要 - 面向信仰编程 (draveness.me) 为什么 MySQL 使用 B+ 树 MySQL-InnoDB为什么采用B+树结构实现索引 - 知乎 (zhihu.com) mysql的Innodb为什么使用B+树_渣渣-CSDN博客 为什么 InnoDB 使用 B+ 树 - SegmentFault 思否 InnoDB 采用 B+树 结构，是因为 B+树 能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数，降低 IO、提升性能。 MySQL数据库主从同步的3种一致性方案实现，及优劣比较 – mikechen的互联网架构师之路 MySQL 中间件汇总比较_jerome-CSDN博客_mysql中间件有哪些 有没有遇到过实际的 MySQL 性能问题，如何解决 聚簇索引、非聚簇索引，什么是回表，怎么避免回表查询 基础超键、候选键、主键、外键 超键：在关系模式中，能唯一标识元 候选键：是最小超键，即没有冗余元素的超键； 主键：数据库表中对存储数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失（不能为 NULL） 外键：在一个表中存在的另一个表的主键称为此表的外键； ACID 靠什么保证 A 原子性：由 undolog 日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 SQL； C 一致性：由其他三大特性保证、程序代码要保证业务上的一致性； I 隔离性：通过锁以及 MVCC 来保证事务相互隔离开； D 持久性：由 内存 + redolog 来保证，MySQL 修改数据同时在内存和 redolog 记录这次操作，宕机的时候可以从 redolog 恢复。 表字段主键 ID 选取单机：自增 ID； 分布式系统：UUID 或选取一套分布式唯一 ID 生产方案，如雪花算法等。 自增 ID：数据存储空间小，查询效率高，但数据量过大，会超出自增范围，多库合并可能会有问题。 当设置了主键，且到达自增范围线 2^32-1：4294967295 时，会报主键冲突； 如果未设置主键，使用默认的 _rowid 时，会从 0 重新开始循环。 UUID：无序，插入效率随数据量增加变低，占用空间大。 char 与 varchar 区别区别： char： 定长，长度固定，插入长度小于定义长度时，用空格填充； 最多存放 255 个字符，与编码无关； varchar： 变长，长度可变，插入长度小于定义长度时，按实际存储； 最多存放 65532 个字符，最大有效长度由字符集确定； 比较： char 存取速度比 varchar 快； char 相较于 varchar 会更占空间； 场景： 存放固定长度数据如：密码散列、盐、身份证、手机号等数据应使用 char，可节省空间并提高检索效率。 为什么要求字段定义 NOT NULL为什么表设计时必须把字段定义为NOT NULL并设默认值_xiaolyuh的专栏-CSDN博客 空不占用空间，而 NULL 会占用空间； 查询表的 NULL 需要使用 IS NULL 或 IS NOT NULL，如果直接使用 = != IN NOT IN 将查询不到值 使用 COUNT() 等统计函数，将不会统计 NULL； MySQL 的索引会为 NULL 值做特殊处理，导致整个索引的查询效率下降。如果是语句中有 IS NULL 会使用索引，如果语句中有 IS NOT NULL 则会导致索引失效， DATETIME 与 TIMESTAMP存储精度都为秒 DATETIME 范围为 1001-9999，而 TIMESTAMP 范围为 1970-2038； DATETIME 与时区无关，而 TIMESTAMP 与时区有关，显示值也依赖时区； DATETIME 存储空间 8 字节，TIMESTAMP 存储空间 4 字节； DATETIME 默认值为 NULL，TIMESTAMP 默认为当前时间； TEXT TINYTEXT：256 bytes； TEXT：65535 bytes = 64KB； MEDIUMTEXT：16777215 bytes = 16MB； LONGTEXT：4294967295 bytes = 4GB； 支持 emoji更换字符集 utf8 -&gt; utf8mb4。 W MySQL 字符集与排序规则字符集 UTF8 与 UTF8MB4MySQL 在 5.5.3 之后增加了这个 UTF8MB4 的编码，MB4 就是 most bytes 4 的意思，专门用来兼容四字节的 unicode。好在 UTF8MB4 是 UTF8 的超集，除了将编码改为 UTF8MB4 外不需要做其他转换。当然，为了节省空间，一般情况下使用 UTF8 也就够了。可以简单的理解 UTF8MB4 是目前最大的一个字符编码，支持任意文字。 三、为什么 MySQL 有 UTF8 和 UTF8MB4 两种几乎差不多的字符集？UTF8 是 MySQL 中的一种字符集，只支持最长三个字节的 UTF-8 字符，也就是 Unicode 中的基本多文本平面。MySQL 中的 UTF8 为什么只支持持最长三个字节的 UTF-8 字符呢？我想了一下，可能是因为 MySQL 刚开始开发那会，Unicode 还没有辅助平面这一说呢。那时候，Unicode 委员会还做着 “65535 个字符足够全世界用了“ 的美梦。MySQL 中的字符串长度算的是字符数而非字节数，对于 CHAR 数据类型来说，需要为字符串保留足够的长。当使用 UTF8 字符集时，需要保留的长度就是 UTF8 最长字符长度乘以字符串长度，所以这里理所当然的限制了 UTF8 最大长度为 3，比如 CHAR(100) MySQL 会保留 300 字节长度。至于后续的版本为什么不对 4 字节长度的 UTF-8 字符提供支持，我想一个是为了向后兼容性的考虑，还有就是基本多文种平面之外的字符确实很少用到。 要在 MySQL 中保存 4 字节长度的 UTF-8 字符，需要使用 UTF8MB4 字符集，但只有 5.5.3 版本以后的才支持。我觉得，为了获取更好的兼容性，应该总是使用 UTF8MB4 而非 UTF8。对于 CHAR 类型数据，UTF8MB4 会多消耗一些空间，根据 MySQL 官方建议，使用 VARCHAR 替代 CHAR。 四、为什么要使用 UTF8MB4 字符集既然 UTF8应付日常使用完全没有问题，那为什么还要使用 UTF8MB4 呢? 低版本的 MySQL 支持的 UTF8 编码，最大字符长度为 3 字节，如果遇到 4 字节的字符就会出现错误了。三个字节的 UTF-8 最大能编码的 Unicode 字符是 0xFFFF，也就是 Unicode 中的基本多文平面（BMP）。也就是说，任何不在基本多文平面的 Unicode 字符，都无法使用 MySQL 原有的 UTF8 字符集存储。这些不在 BMP 中的字符包括哪些呢？最常见的就是 Emoji 表情（Emoji 是一种特殊的 Unicode 编码，常见于 iOS 和 android 手机上），和一些不常用的汉字，以及任何新增的 Unicode 字符等等。那么 UTF8MB4 比 UTF8 多了什么的呢?多了 Emoji 编码支持。如果实际用途上来看,可以给要用到 Emoji 的库或者说表，设置 UTF8MB4。比如评论要支持 Emoji 可以用到。 排序规则utf8_unicode_ci 比较准确，utf8_general_ci 速度比较快。 通常情况下 utf8_general_ci 的准确性已经足够使用，在我看过很多程序源码后，发现它们大多数也用的是 utf8_general_ci，所以新建数据 库时一般选用 utf8_general_ci 就可以了。如果是 UTF8MB4 那么对应的就是 utf8mb4_general_ci，utf8mb4_unicode_ci SQL 相关生命周期 服务器与数据库建立连接； 数据库进程拿到请求 SQL； 解析并生成执行计划，执行； 读取数据到内存，并进行逻辑处理； 通过步骤一的连接，将结果发送到数据库； 关闭连接，释放资源； 慢查询如何处理 首先使用 EXPLAIN 分析语句，看看是否 load 了额外的字段或数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。 对于复杂 SQL 可进行拆分多次查询： 一个大查询氛围多个小查询； 减少冗余数据查询； 复杂查询拆分为多个简单查询； 分解关联查询； UNION 与 UNION ALL都是对两个结果集进行并集处理，UNION 效率更高 UNION：会去重，并按默认规则排序； UNION ALL：不去重，不排序； SQL 的约束 NOT NULL：约束字段的内容不能为 NULL； UNIQUE：约束字段唯一性，一个表允许有多个 UNIQUE 约束； PRIMARY KEY：约束字段唯一，不可重复，一个表只允许一个； FOREIGN KEY：用于防止破坏表之间连接的动作，也能防止非法数据插入外键； CHECK：用于控制字段值的范围； 五种关联查询SQL的五种连接-交叉连接、内连接、外连接、联合连接、自然连接_呵呵喝何何-CSDN博客_sql交叉连接 交叉连接； 内连接； 外连接； 联合查询； 全连接； SQL 优化器的执行过程 根据搜索条件，找出可能使用的索引； 计算全表扫描的代价； 计算使用不同索引执行查询的代价； 对比各种方案的代价，选用成本最低的那一个； 关键字的执行顺序 FROM：对 FROM 子句中前两个表执行笛卡尔积生成虚拟表 vt1； ON：对 vt1 表应用 ON 筛选器只有满足 join_condition 为真的行才被插入 vt2； OUTER(JOIN)：如果指定了 OUTER JOIN 保留表（preserved table）中未找到的行将行作为外部行添加到 vt2，生成 vt3，如果 FROM 包含两个以上表，则对上一个联结生成的结果表和下一个表重复执行步骤和步骤直接结束； WHERE：对 vt3 应用 WHERE 筛选器只有使 where_condition 为 true 的行才被插入 vt4； GROUP BY：按 GROUP BY 子句中的列列表对 vt4 中的行分组生成 vt5； CUBE|ROLLUP：把超组（supergroups）插入 vt6，生成 vt6； HAVING：对 vt6 应用 HAVING 筛选器只有使 having_condition 为 true 的组才插入 vt7； SELECT：处理 SELECT 列表产生 vt8； DISTINCT：将重复的行从 vt8 中去除产生 vt9； ORDER BY：将 vt9 的行按 ORDER BY 子句中的列列表排序生成一个游标 vc10； TOP：从 vc10 的开始处选择指定数量或比例的行生成 vt11 并返回调用者； 四种语言分类 名称 特征 DDL 操作库、表 create / alter / drop DML 增删改表数据 insert / update / delete DQL 查询表数据 select / show DCL 用户管理 grant / revoke MyBatis#{} 与 ${} 的区别 #{} 是预编译处理，占位符；${} 是字符串替换，是拼接符； 处理 #{} 时会将 SQL 中的 #{} 替换为 ?，调用 PreparedStatement 来赋值； 处理 ${} 时会将 ${} 替换成变量值，调用 Satement 赋值； #{} 可以有效防止 SQL 注入； Statement 与 PreparedStatement 区别PreparedStatement 会预编译 SQL 语句，能够提高批量的数据操作的执行效率，Statement 执行 SQL 的时候才进行编译 PreparedStatement 在第一次执行 SQL 的时候，比较耗费资源。如果只对数据库进行一次操作，使用 Statement 比较好。 Statement 会出现 SQL 注入的问题，使用 PreparedStatement 可以解决 SQL 注入。 选用 MyBatis 的理由 使用人数多，解决问题简单； 可以定制化开发，封装轻量级； MyBatis 与 Hibernate 对比 MyBatis 需要手动编写 SQL 语句以及 ResultMap，而 Hibernate 有良好的映射机制，开发者无需关心 SQL 的生成与结果映射； Hibernate 的查询会将所有字段查询出来，MyBatis 可以按需查询； Hibernate 有自己的日志统计，MyBaits 自身不带，需要使用 Log4j 记录； Hibernate 不支持自定义插件与组件； MyBatis 优缺点优点 基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库现有设计造成任何影响； SQL 写在 XML 里，解除 SQL 与程序代码的耦合，便于统一管理； 支持编写动态 SQL 语句，并可重用； 与 JDBC 相比，减少 50% 以上的代码量，消除了 JDBC 大量冗余代码，不需要手动开关链接； 由于 MyBatis 使用 JDBC 连接数据库，所以可以很好的与各种数据库兼容； 能与 Spring 很好的集成； 提供映射标签，支持对象与数据库的 ORM 字段关系映射，提供对象关系映射标签，支持对象关系组件维护； 缺点 当字段多、关系表多时，SQL 语句编写量大，复杂； SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库； 插件运行原理与插件开发MyBatis 只支持四种接口的插件，实现 MyBatis 的 Interceptor 接口并重写 intercept() 方法，然后给插件写注解指定拦截的方法即可。 ParameterHandler：参数转换，转换 bean 中的数据类型； ResultSetHandler：结果集； StatementHandler：负责设置参数、结果集转换； Executor：生成 SQL 语句，SQL 语句查询缓存的维护； HibernateSession 的 load() 和 get() 方法的区别 如果没有找到符合条件的记录，get() 方法返回 NULL，load() 方法抛出异常。 get() 方法直接返回实体类对象，load() 方法返回实体类对象的代理。 在 Hibernate 3之前，get() 方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，直接发出 SQL 语句完成数据读取；load() 方法则可以从二级缓存中获取数据； 从 Hibernate 3 开始，get() 方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。 常见优化策略 制定合理的缓存策略（二级缓存、查询缓存）； 采用合理的 Session 管理机制； 尽量使用延迟加载特性； 设定合理地批处理参数； 如果可以，选用 UUID 作为主键生成器； 如果可以，选用乐观锁替代悲观锁； 在开发过程中，开启 hibernate.show_sql 选项查看生成的 SQL，从而了解底层的状况；开发完成后关闭此选项； 考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观的提升。 SessionFactory 与 Session SessionFactory 对应 Hibernate 的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。SessionFactory 一般只会在启动的时候构建。对于应用程序，最好将 SessionFactory 通过单例模式进行封装以便于访问。 Session 是一个轻量级非线程安全的对象（线程间不能共享 Session），它表示与数据库进行交互的一个工作单元。 Session 是由 SessionFactory 创建的，在任务完成之后它会被关闭。Session 是持久层服务对外提供的主要接口。Session 会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的 Session，可以使用 ThreadLocal 将 Session 和当前线程绑定在一起，这样可以让同一个线程获得的总是同一个 Session。Hibernate 3 中 SessionFactory 的 getCurrentSession() 方法就可以做到。 缓存机制hibernate缓存机制详细分析 - xiaoluo501395377 - 博客园 (cnblogs.com) 索引索引是帮助 MySQL 高效获取数据的排好序的数据结构。 基本原理索引用来快速地寻找那些具有特定值对的记录，如果没有索引，一般执行查询遍历整张表； 原理：把无序的数据变为有序的查询 把创建了索引的列的内容进行排序； 对排序结果生成倒排表； 在倒排表内容上拼上数据地址链； 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据； 索引分类 单列索引 普通索引：MySQL 中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。 ALTER TABLE table_name ADD INDEX index_name(column); 唯一索引：索引列中的值必须是唯一的，但允许为空值； ALTER TABLE table_name ADD UNIQUE(column); 主键索引：是一种特殊的唯一索引，不允许有空值； ALTER TABLE table_name ADD PRIMARY KEY(column); 组合索引 多个字段组合上创建的索引，使用组合索引需遵循最左前缀原则； ALTER TABLE table_name ADD INDEX index_name(column_1, column_2, column_3); 全文索引 只有 MyISAM 引擎且在 CHAR、VARCHAR、TEXT 类型字段上才能使用。 可以在一堆文字中通过其中某个关键字查找所属记录行。 ALTER TABLE table_name ADD FULLTEXT(column); 空间索引 只有 MyISAM 引擎且在 GEOMETRY、POINT、LINESTRING、POLYGON 类型字段上才能使用。 在创建空间索引时，使用 SPATIAL 关键字，且需声明为 NOT NULL； 聚簇、非聚簇索引都是 B+Tree 的数据结构，聚簇索引叶子结点存放数据。 聚簇索引查询更快，主键索引树的叶子节点存储的是整行数据，可直接得到所需数据。而非主键索引的叶子节点存放的是主键的值，还需要通过主键再次去表中查询数据（回表查询） 聚簇索引：将数据存储与索引放到一起，并且是按照一定顺序组织的，找到索引也就找到了数据，数据的物理存放顺序与索引顺序一直，即：只要索引相邻，那么对应的数据一定也是相邻存放在磁盘上； 优点： 查询聚簇索引可以直接获取数据，对于范围查询效率高，适合用于排序； 缺点： 维护索引成本昂贵，尤其是插入新行或者主键更新导致数据分页，可以在负载较低通过 OPTIMIZE TABLE 优化表，因为数据被移动可能会造成碎片，使用独享表空间可以弱化碎片； 如果使用随机 id 作为主键，会使数据存储稀疏，可能会导致聚簇索引比全表扫描更慢，所以建议使用 int 的 auto_increment 作为主键； 如果主键比较大，那么辅助索引将会变得更大，因为辅助索引的叶子存储的是主键值，过长的主键值会导致非叶子节点占用更多物理空间； 非聚簇索引：叶子节点不存储数据，存储的是数据行地址。 索引结构，各自的优劣【mysql】mysql索引存储结构和特点_远方不远-CSDN博客_mysql索引结构 MySQL索引那些事 (qq.com) InnoDB 默认索引为 B+Tree 索引，对于哈希索引来说，底层数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景建议选择 B+Tree 索引。 二叉树 优点：二叉树是一种比顺序结构更加高效地查找目标元素的结构，它可以从第一个父节点开始跟目标元素值比较，如果相等则返回当前节点，如果目标元素值小于当前节点，则移动到左侧子节点进行比较，大于的情况则移动到右侧子节点进行比较，反复进行操作最终移动到目标元素节点位置。 缺点：在大部分情况下，我们设计索引时都会在表中提供一个自增整形字段作为建立索引的列，在这种场景下使用二叉树的结构会导致我们的索引总是添加到右侧，在查找记录时跟没加索引的情况是一样的，如下图所示： 红黑树 优点：红黑树也叫平衡二叉树，它不仅继承了二叉树的优点，而且解决了上面二叉树遇到的自增整形索引的问题，从下面的动态图中可以看出红黑树会左旋、右旋对结构进行调整，始终保证左子节点数 &lt; 父节点数 &lt; 右子节点数的规则。 缺点：在数据量大的时候，深度也很大。从图中可以看出每个父节点只能存在两个子节点，如果我们有很多数据，那么树的深度依然会很大，可能就会超过十几二十层，对我们的磁盘寻址不利，依然会花费很多时间查找。 哈希 哈希索引就是采用一定的哈希算法，把键值对换算成新的哈希值，检索时不需要类似 B+Tree 那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应位置，速度非常快。 如果是等值查询，哈希有绝对优势，因为只需要一次算法即可找到对应的键值（前提键值唯一）如果键值不唯一，就需要先找到该键所在位置，然后再根据链表往后扫描，知道找到响应数据，范围查询检索无法使用哈希索引，因为哈希算法后键值可能不连续。 哈希索引不支持多列联合索引的最左匹配原则； 在有大量重复键值的情况下，哈希索引效率极低； 优点：对数据进行Hash（散列）运算，主流的Hash算法有MD5、SHA256等等，然后将哈希结果作为文件指针可以从索引文件中获得数据的文件指针，再到数据文件中获取到数据，按照这样的设计，我们在查找where Col2 = 22的记录时只需要对22做哈希运算得到该索引所对应那行数据的文件指针，从而在MySQL的数据文件中定位到目标记录，查询效率非常高。 缺点：无法解决范围查询（Range）的场景，比如 select count(id) from sus_user where id &gt;10；因此Hash这种索引结构只能针对字段名=目标值的场景使用。不适合模糊查询（like）的场景。 BTree既然红黑树存在缺点，那么我们可以在红黑树的基础上构思一种新的储存结构。解决的思路也很简单，既然觉得树的深度太长，就只需要适当地增加每个树节点能存储的数据个数即可，但是数据个数也必须要设定一个合理的阈值，不然一个节点数据个数过多会产生多余的消耗。 按照这样的思路，我们先来了解下关于B-Tree的一些知识点： 度(Degree)-节点的数据存储个数，每个树节点中数据个数大于 15/16*Degree（未验证） 时会自动分裂，调整结构 叶节点具有相同的深度，左子树跟右子树的深度一致 叶节点的指针为空 节点中的数据key从左到右递增排列 树节点结构： 在这里需要说明下的是，BTree 的结构里每个节点包含了索引值和表记录的信息，我们可以按照Map集合这样理解：key=索引，value=表记录，如下图所示： 优点：BTree 的结构可以弥补红黑树的缺点，解决数据量过大时整棵树的深度过长的问题。相同数量的数据只需要更少的层，相同深度的树可以存储更多的数据，查找的效率自然会更高。 缺点：从上面得知，在查询单条数据是非常快的。但如果范围查的话，BTree 结构每次都要从根节点查询一遍，效率会有所降低，因此在实际应用中采用的是另一种 BTree 的变种 B+Tree（B+树）。 B+Tree 一颗平衡多叉树，从根节点到每个叶子节点的高度差值不超过 1，而且同层级的节点间有指针相互链接。在 B+Tree 上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。因此，B+Tree 索引被广泛应用于数据库、文件系统等场景。 B+Tree 索引的关键字检索效率比较平均，不像 B 树那样波动大。 叶子节点存放的可能是整行数据，也可能是主键的值； 整行数据：InnoDB 的 B+Tree 存储了整行数据的是主键索引（聚簇索引） 存储主键的值：成为非主键索引（非聚簇索引） 为什么要对 BTree 继续做优化？ 索引和表数据在不使用时是存储在文件中的，也就是磁盘。当我们查询时 DBMS 数据库管理系统会先去内存中查询，找不到则会去磁盘中查询。因为操作系统存取数据最小单位是 页（page） 一页是 4k 大小，由操作系统决定，对内存与磁盘读取数据都是按一页的整倍数读取的，我们假设一次 IO 操作读取 1 页 4K 的数据，一个大节点数据为 10M，那么读取这个大节点就需要 10M / 4K = 2500 次 IO 操作。因此节点越大，执行所需 IO 操作就越多，为了提高性能，数据库会建议我们一个大节点只存储一页 4K 的数据，这里的数据包含索引和表记录。树的度 Degree = 内存页大小（4K） / 单个索引值字节大小。 相对于 BTree，B+Tree 做了哪些优化 B+Tree 只有叶子节点才存放数据，上层非叶子节点均存放索引信息，这样可以使单个节点存放更多索引值，增加 Degree 的值，提高记录命中率。但这种结构会在上层索引信息中存储冗余信息，但并非不能接受，因为冗余的索引数据，不会对内存造成巨大负担。 联合索引(最左匹配原则)联合索引在B+树上的存储结构及数据查找方式 - 掘金 (juejin.cn) 联合索引的最左前缀匹配原则介绍 单个索引可以看做索引列只有一个的联合索引。 联合索引每个树节点包含多个索引值。通过索引查找记录时，会先将联合索引中第一个索引列与节点中第一个索引值进行匹配，匹配成功接着匹配第二个索引列和索引值，直到所有联合索引都匹配完成。如果过程中出现某一个索引列与节点相应位置的索引值不匹配的情况，则中止匹配前往下一节点。 索引设计原则MySQL 索引设计原则_徐通的博客-CSDN博客_索引设计原则 mysql索引设计原则 - 太虚真人 - 博客园 (cnblogs.com) 选择唯一性索引： 唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。 例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。 为经常需要排序、分组和联合操作的字段建立索引： 经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。 为常作为查询条件的字段建立索引： 如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。 注意：常查询条件的字段不一定是所要选择的列，换句话说，最适合索引的列是出现在 WHERE 子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。 限制索引的数目： 索引的数目不是「越多越好」。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。在修改表的内容时，索引必须进行更新，有时还可能需要重构。因此，索引越多，更新表的时间就越长。 如果有一个索引很少利用或从不使用，那么会不必要地减缓表的修改速度。此外，MySQL 在生成一个执行计划时，要考虑各个索引，这也要花费时间。创建多余的索引给查询优化带来了更多的工作。索引太多，也可能会使 MySQL 选择不到所要使用的最佳索引。 尽量使用数据量少的索引，如果索引的值很长，那么查询的速度会受到影响： 例如，对一个 CHAR(100) 类型的字段进行全文检索需要的时间肯定要比对 CHAR(10) 类型的字段需要的时间要多。 如果索引字段的值很长，最好使用值的前缀来索引 例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。 删除不再使用或者很少使用的索引 表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。应该定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。 最左前缀匹配原则 尽量选择区分度高的列作为索引 索引列不要参与计算，保持列「干净」 带函数的查询不参与索引。 尽量扩建索引，不要新建索引 数据量小的表最好不要使用索引 由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。 索引失效的情况 LIKE 以 % 开头索引无效，当 LIKE 以 &amp; 结尾，索引有效； OR 语句前后没有同时使用索引，当且仅当 OR 语句查询条件的前后均为索引时，索引生效； 组合索引：使用不是第一列索引时，索引失效（需满足最左匹配原则） 数据类型出现隐式转换，如 VARCHAR 不加单引号可能会自动转为 INT 类型，此时索引失效； 在索引列上使用 IS NULL 或 IS NOT NULL 时，索引失效； 在索引字段上使用 NOT、&lt;&gt;、!=、不会使用索引，只会进行全表扫描； 对索引字段进行计算操作，函数操作不会使用索引； 当全表扫描速度比索引速度快是不会使用索引； 覆盖索引覆盖索引指一个查询语句的执行只用从索引中就能获取到，不必从数据表中读取。也可被称之为索引覆盖。当一条查询语句符合覆盖索引条件时，MySQL 只需通过索引就可以返回查询所需数据，这样就可以避免回表操作，减少 I/O，提高效率。 例如：表 covering_index_sample 中有一个普通索引 idx_key1_key2(key1, key2) 当我们通过 SQL 语句：SELECT key2 FROM covering_index_sample WHERE key1 = 'keytest'; 时，可以通过覆盖索引查询，无需回表。 B+Tree 和 Hash 的区别 Hash 索引适合等值查询，但是无法进行范围查询。 Hash 索引没法利用索引排序； Hash 索引不支持多列联合索引的最左匹配原则； 由于哈希碰撞问题，大量重复键的情况 Hash 索引效率很低 W MySQL 5.6 的索引下推MySQL 5.6 引入索引下推优化，默认开启。主要是减少了不必要的回表操作。对于查找出来的数据，先过滤掉不符合条件的，其余的再去主键索引树上查找。。 例如：user 表中 (a, b) 构成一个联合索引，执行语句：SELECT * FROM user WHERE a LIKE '%eqw%' AND b = '23'; 如果没有使用索引下推，MySQL 会通过 a LIKE '%eqw%' 先查询出一个对应的数据，再基于 b = '23' 来校验查询出的数据是否符合条件，这个过程涉及到回表操作。 如果使用了索引下推，则 MySQL 会先通过 b = '23' 先查询出一个对应的数据，然后根据模糊查询的条件来校验索引行数据是否符合条件，如果符合条件，则直接根据索引来定位对应的数据，如果不符合直接 reject 掉。因此，有了下推优化，可以在有 LIKE 条件的情况下，减少回表次数。 如果没有索引下推优化（或称ICP优化），当进行索引查询时，首先根据索引来查找记录，然后再根据where条件来过滤记录；在支持ICP优化后，MySQL会在取出索引的同时，判断是否可以进行where条件过滤再进行索引查询，也就是说提前执行where的部分过滤操作，在某些场景下，可以大大减少回表次数，从而提升整体性能。 回表与覆盖索引，索引下推 - 简书 (jianshu.com) W 列为 NULL 时能走索引吗可以走索引的，但应尽量避免设置为可空，因为会让 MySQL 难以优化引用了可控列的查询，增加引擎复杂度。 如果 WHERE 子句中查询的列执行了 IS NULL 或者 IS NOT NULL 或者 &lt;=&gt; NULL，如果判断的列设置了索引，那就可以使用到索引。 官方依据 索引类型及对数据库的影响 普通索引：允许被索引的数据列包含重复的值。 唯一索引：可以保证数据记录的唯一性。 主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。 联合索引：索引可以覆盖多个数据列，如像 INDEX(columnA, columnB)索引。 全文索引：通过建立倒排索引，可以极大的提升检索效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术。可以通过 ALTER TABLE table_name ADD FULLTEXT (column); 创建全文索引索引可以极大的提高数据的查询速度。通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都会跟着变。 事务四大特性 ACID 原子性（Atomicity）：每个事务都是一个整体，不可再拆分，事务中所有的 SQL 语句要么都执行成功，要么都失败。 一致性（Consistency）：事务在执行前数据库的状态与执行后数据库的状态保持一致。如：转账前 2 个人的总金额是 2000，转账后 2 个人总金额也是 2000 隔离性（Isolation）：事务与事务之间不应该相互影响，执行时保持隔离的状态。 持久性（Durability）：一旦事务执行成功，对数据库的修改是持久的。就算关机，也是保存下来的。 隔离级别隔离级别越高，性能越差，安全性越高。 脏读：一个事务读取到了另一个事务中尚未提交的数据； 不可重复读：一个事务中两次读取的数据内容不一致，要求的是一个事务中多次读取时数据是一致的，这是事务 update 时引发的问题； 幻读：一个事务中两次读取的数据的数量不一致，要求在一个事务多次读取的数据的数量是一致的，这是 insert 或 delete 时引发的问题； MySQL 四种隔离级别 级别 名字 隔离级别 脏读 不可重复读 幻读 默认隔离级别 1 读未提交 Read uncommitted √ √ √ 2 读已提交 Read committed × √ √ Oracle、SQL Server 3 可重复读 Repeatable read × × √ MySQL 4 串行化 Serializable × × × 并发事务的问题 丢失更新：A 事务提交或撤销时，把 B 事务更新数据覆盖； 脏读：读到未提交更新数据； 不可重复读：读到已提交更新数据，但一个事务范围内两个相同查询却返回了不同数据； 幻读：读到已提交插入数据； W MVCCMySQL 并发控制机制 W 版本链三个隐藏列 row_id trx_id roll_pointer W ReadViewW 核心问题 判断版本链中哪些版本对当前事务可见 版本链访问记录判断逻辑 W 实现 Read Committed：每一次进行 select 操作前都会生成一个 ReadView Repeated Read：只有在第一次执行普通 select 操作前生成 ReadView，之后的查询重复使用这个 ReadView W 关于 undo insert undo：事务提交即释放 update undo：需要支持 MVCC，不能立即被删除 delete mark：记录打删除标记（逻辑删除） W 日志redo 记录事务对数据库做了哪些修改 刷盘时机 应用场景 崩溃恢复 确定恢复的起点 确定恢复的终点 如何恢复 当磁盘中两个文件（ib_logfile0，ib_logfile1）均写满时，会从头开始依次将数据持久化进入磁盘中。 redo log 过大的弊端：MySQL 挂掉后，重启会变慢（需要逐步恢复 redo log 数据进入 Buffer Pool） LogBuffer在内存中存放还未写入磁盘（事务未提交时）的 redo log 配置undo 应用场景 事务回滚 事务id（唯一、递增） 生成时机 在事务中对表作修改时 生成策略 服务器在内存中维护一个全局变量，且事务id分配之后变量自动加一 每当变量超过 256 的倍数时，会将变量值刷新到系统表空间页号为 5 的页面中去 日志格式 INSERT 操作对应的 undo 日志 DELETE 操作对应的 undo 日志 UPDATE 操作对应的 undo 日志 写 undo 日志 W 主从复制Buffer Pool导引 LRU 淘汰算法 脏页：被修改但是还未写入磁盘的数据 5.7.5 后可以在服务器运行过程中调整大小 基础存放磁盘数据，以页为单位，默认大小 128M Free 链表存放 Buffer Pool 中的空闲块的位置，用于快速写入磁盘中的页数据 LRU 链表存放非空闲块的使用频率，最近使用的会靠近头节点，当 Buffer Pool 写满时，会从尾部节点开始淘汰数据。 其中，LRU 链表会分为两段，前段（整条链表的 5/8）存放热点数据（读取次数超过 1 次，「1s 内多次读取算一次」），后段存放冷数据。 前段的 1/4 区域的数据不会随着访问调整在链表中的位置 Flush 链表记录被修改过的控制块，用于定时（10s）写入磁盘时快速读取数据位置 UPDATE 执行流程 修改 Buffer Pool 里面的页数据 生成一个 redo log 对象（顺序存放，避免随机磁盘 IO）） 持久化 redo log 后台定时任务持久化脏页 锁导引 锁粒度 行级锁 表级锁 页级锁 是否独占 读锁（共享锁）：阻塞写 写锁（排他锁）：阻塞读、写 锁的类型基于锁的属性： 共享锁（Share Lock） 共享锁又称读锁，简称 S 锁；当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。 排他锁（eXclusive Lock） 排他锁又称写锁，简称 X 锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取。避免了出现脏数据和脏读的问题。 基于锁的粒度 行级锁（InnoDB） 行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问； 特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高； 表级锁（InnoDB、MYISAM） 表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问； 特点：粒度大，加锁简单，容易冲突； 页级锁（BDB 引擎 ） 页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录； 特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般； 记录锁 记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录。 精准条件命中，并且命中的条件字段是唯一索引加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。 间隙锁 属于行锁中的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻 ID 之间出现空隙则会形成一个区间，遵循左开右闭原则。 范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在 REPEATABLE_READ（重复读）的事务级别中。 触发条件：防止幻读问题，事务并发的时候，如果没有间隙锁，在同一个事务 里，A 事务的两次查询出的结果会不一样。 比如表里面的数据 ID 为 1,4,5,7,10 那么会形成以下几个间隙区间，-n-1 区间，1-4 区间，7-10 区间，10-n 区间 （-n 代表负无穷大，n 代表正无穷大） 临键锁 属于行锁的一种，并且它是 InnoDB 的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住； 触发条件：范围查询并命中，查询命中了索引。 结合记录锁和间隙锁的特性，临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之 后，在范围区间内数据不允许被修改和插入。 基于锁的状态 如果当事务 A 加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁了，你们不能对整个表加共享锁或排他锁了，那么后面需要对整个表加锁的人只需要获取这个状态就知道自己是不是可以对表加锁，避免了对整个索引树的每个节点扫描是否加锁，而这个状态就是意向锁。 意向共享锁 当一个事务试图对整个表进行加共享锁之前，首先需要获得这个表的意向共享锁； 意向排他锁 当一个事务试图对整个表进行加排他锁之前，首先需要获得这个表的意向排他锁； W 一条 SQL 加锁分析MySQL中一条SQL的加锁分析 - DB-Engineer - 博客园 (cnblogs.com) 记录锁、间隙锁MySQL的锁机制 - 记录锁、间隙锁、临键锁 - 知乎 (zhihu.com) 唯一索引： 对于指定查询某一条记录的加锁语句，如果该记录不存在，会产生记录锁和间隙锁，如果记录存在，则只会产生记录锁，如：WHERE id = 5 FOR UPDATE; 对于查找某一范围内的查询语句，会产生间隙锁，如：WHERE id BETWEEN 5 AND 7 FOR UPDATE; 普通索引： 在普通索引列上，不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样； 在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序。 临键锁(Next-key Locks)，是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。 注：临键锁的主要目的，也是为了避免幻读(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。 存储引擎导引 InnDB 页作为磁盘和内存之间的交互单位 MySQL 默认存储引擎（5.5 版本后） 应用场景：事务性、安全性操作较多的情况 MyISAM 不提供事务支持 不支持行级锁 不支持外键 应用场景：执行大量的 SELECT Memory 数据存储内存，结构存储磁盘，访问效率高 服务关闭表中数据丢失 应用场景：MySQL 内存表做数据缓存 InnoDB以页作为磁盘和内存之间的交互单位，一页 16kb，调整此参数建议以 4kb （操作系统页大小）的倍数为佳 有哪些存储引擎 MyIsam InnoDB Memory Archive Federated 默认为 InnoDB，底层为 B+Tree，BTree 每个节点对应 InooDB 的一个 page，page 大小固定，默认为 16k，适用于以下场景： 经常更新的表，适合处理多重并发的更新请求； 支持事物； 通过 bin-log 日志，出问题可以从灾难中恢复； 外键约束，只有这个引擎支持外键。 支持自动增加列属性 auto_increment MyISAM 与 InnoDB 区别 InnoDB 支持事务，MyISAM 不支持； InnoDB 支持外键，而 MyISAM 不支持，对一个包含外键的 InnoDB 表转为 MyISAM 会失败； InnoDB 是聚簇索引，MyISAM 是非聚簇索引； InnoDB 不保存表的具体行数，执行 SELECT COUNT(*) FROM table 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何 WHERE 条件）； 为什么 InnoDB 没有了这个变量呢？ 因为 InnoDB 的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此 count 统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。InnoDB 会尝试遍历一个尽可能小的索引，除非优化器提示使用别的索引。如果二级索引不存在，InnoDB 还会尝试去遍历其他聚簇索引。 如果索引并没有完全处于 InnoDB 维护的缓冲区（Buffer Pool）中，count 操作会比较费时。可以建立一个记录总行数的表并让你的程序在 INSERT/DELETE 时更新对应的数据。和上面提到的问题一样，如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试 SHOW TABLE STATUS InnoDB 支持表、行(默认)级锁，而 MyISAM 支持表级锁 InnoDB 的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。 InnoDB 表必须有唯一索引（如主键，用户没有指定的话会自己找/生产一个隐藏列 _rowid 来充当默认主键），而 MyISAM 没有； 存储文件 InnoDB：.frm 是表结构文件，.ibd 是数据文件 MyISAM：.frm 是表结构文件，.myd 是数据文件，.myi 是索引文件 InnoDB 中一定有主键，主键一定是聚簇索引。不手动设置则使用 unique 索引，没有 unique 索引，则会使用数据库内部的一个隐藏行的 id 作为主键索引。在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引、辅助索引叶子节点存储的不再是行的物理位置，而是主键值； MyISAM 使用的是非聚簇索引，没有聚簇索引，两颗 B+Tree 看上去没什么不同，节点的结构完全一致只是存储的内容不同。主键索引 B+Tree 节点存储主键，辅助索引 B+Tree 存储了辅助键。表数据存储在独立的地方，这两颗 B+Tree 的叶子节点都是用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。 如果涉及到大量的数据排序、全表扫描、count 之类的操作的话，MyISAM 占优势些，因为索引所占空间小，这些操作是在内存中完成的。 W InnoDB 事务与日志实现InnoDB 有两种日志：redo、undo redo：页修改时，先写到 redo log buffer 里面，然后写到 redo log 的文件缓存系统 fwrite，然后再同步到磁盘文件 fsync。 undo：MySQL 5.5 之前，undo 只能存放在 ibdata 里，5.6 之后可以设置 innodb_undo_tablespaces 把 undo log 放在 ibdata 外。 SQL 优化Explain table id 查询语句中每出现一个 SELECT，都会分配一个唯一的 id 根据 id 可以判断优化器是否重写了 SQL（比如自查询重写为连接查询） selectType 查询级别 type 查询访问方法 rows 全表扫描 预计需要扫描的行数 索引查询 预计扫描的索引记录行数 优化器基于成本的优化 成本 IO 成本 CPU 成本 单表查询的优化 基于索引统计数据的成本计算 多表连接的成本 基于规则的优化 条件简化 移除不必要的括号 常量传递 等值传递 移除没用的条件 表达式计算 优化器不会尝试对这些表达式进行简化 最好让索引列以单独的的形式出现在表达式中 HAVING 子句与 WHERE 子句的合并 常量表检测 外链接消除 指定的 WHERE 子句中包含被驱动表中的列不为 NULL 值的条件称为空值拒绝 在被驱动表的 WHERE 子句符合空值拒绝的条件后，外连接和内连接可以相互转换 好处：查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的连接顺序来执行 子查询优化 IN 子查询优化 物理表转连接 将子查询转换为 semi-join 查询 写物化表（临时表） 写入临时表的记录会被去重 建立基于内存的使用 Memory 存储引擎… 基于内存的物化表有哈希索引、基于磁盘的… ANY/ALL 子查询优化 转换为 max() min() 查询 NOT EXISTS/EXISTS 优化 分库分表导引 触发条件 分库原则 分表原则 分表规范（阿里规约） 分表主键全局唯一，且不宜过长 禁止进行跨库事务操作 分表操作必须带有分片字段 不允许对分片字段进行模糊查询 优先使用垂直拆分 时间范围查询不宜过长，尽量控制在 1-2 个分片表内 单库数量控制在 300 内 尽量避免跨库 join 触发器什么是触发器，使用场景？指一段代码，当触发某个事件时，自动执行这些代码。 可以通过数据库中相关表实现级联更改； 实时监控某张表某个字段的更改而需要做出相应的处理； 例如可以生成某些业务编号； 不能滥用，容易造成数据库以及应用程序维护困难； MySQL 中的触发器 Before insert； After insert； Before update； After update； Before delete； After delete； 分布式MySQL 主从同步原理MySQL 的主从复制中主要有三个线程：master（binlog dump thread）、slave（I/O thread 、SQL thread），Master 一条线程和 Slave 中的两条线程。 主节点 binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog 是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件； 主节点 log dump 线程，当 binlog 有变动时，log dump 线程读取其内容并发送给从节点； 从节点 I/O 线程接收 binlog 内容，并将其写入到 relay log 文件中； 从节点的 SQL 线程读取 relaylog 文件内容对数据更新进行重放，最终保证主从数据库的一致性； 注：主从节点使用 binlog 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从 position 的位置发起同步。 由于 MySQL 默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生 一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。 全同步复制：主库写入 binlog 后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。 半同步复制：和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回 ACK 确认给主库，主库收到至少一个从库的确认就认为写操作完成。 读写分离常见方案应用程序根据业务将增删改操作直接发给主库，查询命令发给备库， 利用中间件来做代理，负责对数据库的请求识别读还是写，分发到不同数据库中，如：amoeba、MySQL-proxy W MySQL 的复制原理及过程 主库更新增删改事件被写入 binlog； 从库发起连接，连接至主库； 主库创建 binlog dump thread 把 binlog 内容发送至从库； 从库创建 IO 线程，读取主库发送的 binlog 并写入 relay log； 从库创建 SQL 线程，从 relay log 中读取内容，从 Exec_Master_Log_Pos 位置开始执行读取到的更新事件并写入库。 主从一致校验checksum、MySQLdiff、pt-table-checksum 等 经验之谈SQL 优化 优化你的 SQL 和索引 加缓存：redis 主从复制或者主主复制，读写分离 MySQL 自带分区表 垂直拆分 水平拆分 索引（阿里规约） 单表索引控制在 5 个以内 不允许存在重复索引和冗余索引 防止字段隐式转换导致索引失效 SQL 优化目标：至少达到 range 级别 利用覆盖索引避免回表操作 禁止超过三个表的 join 在 varchar 上建立索引，并指定索引长度 索引字段不允许设置为 NULL，必须设置默认值 单表数据量控制在 1000W 以内 字段列数量建议在 30 以内 不建议使用 MySQL 自带分区表 单表行数超过 500W 或者单表容量超过 2G 建议分库分表 大表快速查询一张 6 亿数据的表 a，3 亿数据的表 b，通过外键 tid 关联，快速查询出满足条件的第 50000 至 50200 条数据。 若表 a 的 tid 自增且连续，b 的 id 为索引：SELECT column FROM a, b WHERE a.tid = b.id AND a.tid &gt; 50000 LIMIT 200; 若 a 表的 tid 不连续，那么需要使用覆盖索引，tid 要么是主键，要么是辅助索引，b 表 id 也需要有索引：SELECT column FROM b, (SELECT tid FROM a LIMIT 50000, 200) a WHERE b.id = a.tid; 执行计划(EXPLAIN)执行计划就是 SQL 的执行查询的顺序，以及如何使用索引查询，返回的结果集的行数。 EXPLAIN SELECT * FROM A WHERE X = ? AND Y = ? id：是一个有顺序的编号，是查询的顺序号，有几个 SELECT 就显示几行。id 的顺序是按 SELECT 出现的顺序增长的。id 列的值越大执行优先级越高越先执行，id 列的值相同则从上往下执行，id 列的值为 NULL 最后执行。 selectType：表示查询中每个 select 子句的类型： SIMPLE：表示此查询不包含 UNION 查询或子查询； PRIMARY：表示此查询是最外层的查询（包含子查询）； SUBQUERY：子查询中的第一个； SELECT UNION：表示此查询是 UNION 的第二或随后的查询； DEPENDENT UNION：UNION 中的第二个或后面的查询语句, 取决于外面的查询； UNION RESULT, UNION 的结果； DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果； DERIVED：衍生，表示导出表的 SELECT（FROM子句的子查询）； table：表示该语句查询的表； type：优化 SQL 的重要字段，也是我们判断 SQL 性能和优化程度重要指标。他的取值类型范围： const：通过索引一次命中，匹配一行数据； system：表中只有一行记录，相当于系统表； eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配； ref：非唯一性索引扫描，返回匹配某个值的所有； range：只检索给定范围的行，使用一个索引来选择行，一般用于 between、&lt;、&gt;； index：只遍历索引树； ALL：表示全表扫描，这个类型的查询是性能最差的查询之一。 那么基本就是随着表的数量增多，执行效率越慢。 执行效率：ALL &lt; index &lt; range&lt; ref &lt; eq_ref &lt; const &lt; system。最好是避免 ALL 和 index possible_keys：它表示 MySQL 在执行该 SQL 语句的时候，可能用到的索引信息，仅仅是可能，实际不一 定会用到。 key：此字段是 MySQL 在当前查询时所真正使用到的索引。 他是 possible_keys 的子集 key_len：表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用，这也是 我们优化 SQL 时，评估索引的重要指标 rows：MySQL 查询优化器根据统计信息，估算该 SQL 返回结果集需要扫描读取的行数，这个值相关重要，索引优化之后，扫描读取的行数越多，说明索引设置不对，或者字段传入的类型之类的问题，说明要优化空间越大； filtered：返回结果的行占需要读到的行（rows 列的值）的百分比，就是百分比越高，说明需要查询到数据越准确，百分比越小，说明查询到的数据量大，而结果集很少； extra: using filesort ：表示 MySQL 对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有 using filesort 都建议优化去掉，因为这样的查询 CPU 资源消耗大，延时大； using index：覆盖索引扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往 往说明性能不错； using temporary：查询有使用临时表, 一般出现于排序，分组和多表 JOIN 的情况，查询效率不高，建议优化； using where ：SQL 使用了 WHERE 过滤，效率较高。 W MySQL CPU 飙升拓展阅读 - 暂未处理为什么 MySQL 的自增主键不单调也不连续 为什么 MySQL 使用 B+Tree MySQL 索引性能分析概要 MySQL 索引设计概要 『浅入深出』MySQL 中事务的实现 『浅入浅出』MySQL 和 InnoDB 未分类什么是DAO模式？DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。 是否了解连接池，使用连接池有什么好处？数据库连接是非常消耗资源的，影响到程序的性能指标。连接池是用来分配、管理、释放数据库连接的，可以使应用程序重复使用同一个数据库连接，而不是每次都创建一个新的数据库连接。通过释放空闲时间较长的数据库连接避免数据库因为创建太多的连接而造成的连接遗漏问题，提高了程序性能。 游标的创建步骤？ 定义游标 打开游标 操作游标数据 关闭游标 你们如何监控数据库工具：zabbix、lepus","link":"/e4a63deccf5b/"},{"title":"未解答","text":"暂未解答的面试题 待整理线程线程 ？synchroized ReetrantLock 线程不安全是指什么? 举例说明 并发出现线程不安全的本质什么? 可见性，原子性和有序性。 Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before 线程安全是不是非真即假? 不是 线程安全有哪些实现思路? 如何理解并发和并行的区别? 线程基础 JUC 相关 JUC框架包含几个部分? 每个部分有哪些核心的类? 最最核心的类有哪些? volatile final 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071Session 原理HashSet 的底层实现说下？为什么内置 HashMap？说下它的数据结构，为什么 loadFactor 是 0.75？你说泊松分布，什么是泊松分布？为什么要高位参与与运算？为什么它的 size 是 2 的 n 次方？为什么默认是 16？讲下它的扩容机制。什么时候转红黑树，为什么要转红黑树？为什么它是线程不安全的，它的哪些方法是线程不安全的？为什么会造成死循环？1.8 是如何解决这个问题的？它的线程安全的实现有什么？ConcurrentHashMap 和 HashTable 有什么区别？说下它 1.7 和 1.8 的实现是什么？有什么区别？为什么要这么做？为什么说 ConcurrentHashMap 是线程安全的？它的 get 操作是有锁的吗？它是强一致性的吗？它为什么是弱一致性的？ConcurrentHashMap 1.7 和 1.8 是如何扩容的？sizeCtl 参数是干什么的，讲讲变换过程？为什么要用 volatile 修饰？说说它的功能？什么是 MESI 协议？CPU 原语是什么？什么是可见性？JMM 说说是什么？为什么要有 JMM？Happened-before 是什么？它和 synchronized 的区别是什么？锁的升级与降级说下是什么？偏向锁是什么？Mark-Wrod 说下？锁的粒度是什么？锁消除了解吗？锁会被合并吗？什么时候会发生？你刚才说了 CAS，你能说下它是什么东西吗？为什么要引入 CAS？ABA 问题是如何解决的？AQS 了解吗？它是如何实现的？CLH 又是什么？ReentrantLock 和 synchronized 区别是什么？为什么 ReetrantLock 能实现公平锁？默认构造器是公平锁吗？为什么不是？Copy-on-Write 了解吗？Fork/Join 又是什么？什么是线程，什么是协程？你刚才说了管程？你能说下这几个到底是做什么的吗？线程池说下参数，四种内置的拒绝策略，以及它的执行流程。你用过吗？为什么要这么设置参数？I/O 密集型应用和计算密集型应用如何设置其参数？你具体的业务线程池的参数是怎么设计的？为什么？测过吗？你定制化开发过吗？线程池预留了 3 个供子类扩展的方法你知道是哪三个吗？能做什么你知道吗？ThreadLocal 是什么？它为什么会造成内存泄漏？你实际开发中用到过吗？Spring 事务用这个干什么的？什么是事务的 SavePoint？你知道死锁吗？如何解决死锁？sleep 和 wait 的区别是什么？ I/O1234567891011121314151617BIO、NIO、AIO 是什么？说下区别，以及如何使用？了解 Netty 吗？如何解决粘包问题？ChannelPipeline 又是什么？ByteBuf 知道吗？读写指针又是什么？它和 mina 的区别是什么？它的 Zero-Copy？了解过 FastThreadLocal 吗？它为什么比 ThreadLocal 快？有看过其中源码吗？Netty 解决了 NIO 类库的什么问题？空轮询又是什么？RPC 又是什么？序列化和反序列化又是什么？几个核心类说下。是干什么的？ JVM123456789101112131415161718192021222324252627282930313233343536373839404142你说你了解虚拟机，你知道虚拟机的运行时数据区吗？内存模型，类加载机制哪些是线程共享的，哪些是线程独有的？你了解 JVM 调优吗？调优过吗？为什么要这么设置？垃圾回收算法有几种？为什么要分代收集？Young 区说说它的分布结构，为什么 Eden 区 80%？为什么大对象直接进入老年代？控制的参数是什么？一个对象如果不是大对象，怎样才能进入老年代？控制的参数是什么？什么时候会发生 OOM？你遇到过吗？怎么解决的？为什么低版本的 JDK 要把永久代内存调大点？默认大小是多少你知道吗？什么是 Major GC，什么是 Minor GC？什么情况下会频繁 GC？你查看过 GC 日志吗？什么时候回收对象？引用计数和可达性分析是什么？为什么 Java 使用后者？Python 使用前者？什么是 GCRoot？什么时候对象不可达？Java 的四种引用说下，分别用在什么场景？你知道 JDK 源码哪里有用到 WeakReference 吗？什么是 STW？什么是 Safepoint？类加载的过程说下，什么时候优化，以及不同的阶段的主要优化是什么？解语法糖是什么时候？为什么在编译的时候解语法糖？什么是双亲委派模型？可以破坏吗？各个 ClassLoader 加载哪部分类的？你自定义过 ClassLoader 吗？你说你用过 Jstack 诊断 CPU 使用率飙升的情况，说下具体步骤？Arthas 用过吗？Class 文件格式说下，什么是魔数，Class 文件的魔数是什么？JMX 了解吗？ 数据库 存储过程、函数、底层原理，语句执行顺序 数据库的索引，及其数据结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859ACID 说下是什么。你说你优化过 SQL，怎么优化的说下。like '%xx%'，like '%xx'，like 'xx%' 哪种情况会用到索引，为什么？说下 MySQL 执行流程。WAL(Write-Ahead Logging) 知道吗？redo log 和 undo log 是什么，它们作用说下。你说你改过 buffer_pool_size 等参数，为什么要改它？它里面的数据结构说下是什么？为什么冷热 3:7？join_buffer 你说你也改了，为什么？什么是驱动表和被驱动表？如何优化？你说你建了索引，什么是蔟集索引，什么是非蔟集索引？什么是回表？什么时候会索引失效？你的二级索引什么用得多？为什么优先使用普通索引，而不是唯一索引？MySQL 会死锁吗？什么是间隙锁？它会导致什么问题？MVCC 说下是什么？4 种事务说下是什么？哪种或者哪几种事务隔离级别能避免幻读？能避免脏读？你说你还开启了 binlog，能说说是什么吗？canal 用过吗？说说它的原理。MySQL 主从模式如何开启？你是如何优化 SQL 的？上亿级别的数据你是如何优化分页的？为什么不建议在 MySQL 中使用分区机制？为什么删了数据还是磁盘空间不变？自增主键用完了会怎么样？如何解决这个问题？自增主键什么时候是不连续的？这样做的好处是什么？为什么推荐用自增主键？B+ Tree 又是什么？如何迁移数据库？为什么不建议使用外键？在高版本的 MySQL 中count(1) 和 count(*) 区别是什么？order by 是如何工作的？分页机制又是什么？ACL 和 RBAC 是什么？grant 之后一定要刷新吗？视图用过吗？它的作用说下。视图和表的区别说下。存储过程写过吗？存储函数和存储过程的区别说下。为什么要分库分表？分库分表如何做到动态缩容/扩容？NoSQL 用过吗？OceanBase 了解吗？HBase 了解吗？HBase 有哪些坑，你碰到过吗？什么是 RegionServer？什么时候用 NoSQL，它能取代 RDBMS 吗？你说你用过 Elasticsearch，能说下它的请求执行过程吗？它的总体架构说下，画一下。它的插件你用过吗？你们的分词策略是什么？倒排索引说下是什么。动态内存分配和回收策略是什么？什么是空闲列表和指针碰撞？什么时候用它们？空闲列表四种策略说下。Page Cache 知道吗，说说它的作用。Redis 和 Kafka 中间件如何通过 Page Cache 来优化？哪些类型会导致内存泄漏？ 网络1234567891011121314151617181920212223242526272829TCP 和 HTTP 是什么？TCP 粘包它们之间的关系说下。OSI 七层是哪七层？分别是干什么的？TCP 和 UDP 区别是什么？什么时候会导致 TCP 抖动？TCP 是如何保证稳定的？CPU 是如何执行任务的？你知道 numa 架构吗？哪些中间件可以通过这个来怎么优化？为什么绑核能优化？什么是 Zero-Copy？你用的中间件中有哪些用到了这个特性？内核态和用户态是什么？硬件你了解过吗？什么是 x86？什么是 ARM？你说精简指令集？它精简了什么？ARM 架构的 CPU 是什么样的？画一下。M1 芯片为什么这么快，有了解吗？5G 有了解吗？有点题外话了，最后问你个问题，你说你是软件通信工程，通信学的什么？选修了什么？通信是学硬件吗？光纤为什么这么快？8 根线和 4 根线区别？傅立叶变换说下是什么？数字信号模拟信号？ Redis redis 一般有哪些使用场景 redis 为什么快 redis 有哪些数据类型 redis 数据类型有哪些命令 谈谈 redis 的对象机制（redisObject) redis数据类型有哪些底层数据结构 为什么要设计sds？ 一个字符串类型的值能存储最大容量是多少？512M 为什么会设计Stream Stream用在什么样场景 消息ID的设计是否考虑了时间回拨的问题 ？持久化和内存 Redis 的持久化机制是什么？各自的优缺点？一般怎么用？ Redis 过期键的删除策略有哪些 Redis 内存淘汰算法有哪些 Redis的内存用完了会发生什么？ 如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。 Redis如何做内存优化？ Redis key 的过期时间和永久有效分别怎么设置？ Redis 中的管道有什么用？ 事务 什么是redis事务 Redis事务相关命令 Redis事务的三个阶段 watch是如何监视实现的呢 为什么 Redis 不支持回滚 redis 对 ACID的支持性理解 Redis事务其他实现 ？主从复制 Redis 集群的主从复制模型是怎样的？ 全量复制的三个阶段？ 为什么会设计增量复制？ 增量复制的流程？ 如果在网络断开期间，repl_backlog_size 环形缓冲区写满之后，从库是会丢失掉那部分被覆盖掉的数据，还是直接进行全量复制呢？ 为什么不持久化的主服务器自动重启非常危险呢? 为什么主从全量复制使用 RDB 而不使用 AOF？ 为什么还有无磁盘复制模式？ 为什么还会有从库的从库的设计？ ？哨兵机制 Redis 哨兵机制？哨兵实现了什么功能呢 哨兵集群是通过什么方式组建的？ 哨兵是如何监控Redis集群的？ 哨兵如何判断主库已经下线了呢？ 哨兵的选举机制是什么样的？ Redis 1 主 4 从，5 个哨兵，哨兵配置 quorum 为 2，如果 3 个哨兵故障，当主库宕机时，哨兵能否判断主库「客观下线」？能否自动切换？ 主库判定客观下线了，那么如何从剩余的从库中选择一个新的主库呢？ 新的主库选择出来后，如何进行故障的转移？ ？Redis 集群 说说 Redis 哈希槽的概念？为什么是 16384 个？ Redis 集群会有写操作丢失吗？为什么？ Redis 如何做大量数据插入？ Redis2.6 开始 redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。 Redis 实现分布式锁实现? 什么是 RedLock? Redis 缓存有哪些问题，如何解决 Redis 和其它数据库一致性问题如何解决 Redis 性能问题有哪些，如何分析定位解决 新版本 Redis单线程模型？ 在6.0之前如何提高多核CPU的利用率？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Redis 它的 5 种基础类型和 6 个数据结构说下。HyperLogLog、BitMap、GEO、Stream 有接触过吗？什么时候用这些特殊数据结构？跳表又是什么，画一下？为什么使用跳表？全局 Hash 表又是什么？如何扩容的？什么是渐进式 rehash？Redis 怎么做到的？IO 多路复用是什么？多路是什么？复用了什么？AOF 和 RDB 又是什么？为什么 Redis 没有实现 WAL 机制？AOF 持久化策略有哪三种？你们是怎么选的？AOF 什么时候重写？为什么重写？主从复制用到了哪种日志？主从复制过程说下。主从复制什么时候增量，什么时候全量？第一次连接时，网络中断了怎么办？Redis 十万并发能支撑住吗？如何支撑十万以上并发？为什么操作大对象支持不了十万并发？Redis Cluster 是什么？ 你说到了 CRC 16，你知道一致性哈希算法吗，能说下是什么吗？Codis 了解吗？你们的 Redis 集群方案是什么？Redis 主从是什么？主从从又是什么？为什么主从从可以减少主库压力？从库可以设置可写吗？从库可写会带来什么问题？什么时候主从数据不一致导致数据丢失？Redis 是如何保证高可用的？哨兵机制了解吗？什么是主观下线什么是客观下线？选主的四个筛选条件优先级的条件依次递减分别是什么？打分又是什么？如何打分？缓存击穿、缓存雪崩、缓存穿透说下？如何解决？布隆过滤器又是什么？能手写个布隆过滤器吗？分布式锁了解过吗？讲讲分布式锁实现原理？Lua 脚本保证原子性吗？分布式锁需要注意哪四个问题？Redis 事务说下。缓存污染知道是什么吗？如何淘汰数据的？分别是哪八种策略？Redis 对 lru 做了什么改变吗？lfu 又是什么？Redis 做了什么优化？Redis 多线程是什么多线程？默认开启吗？你们生产中用了吗？Redis 6 还有什么新特性？自定义过 Redis 数据类型吗？自定义过 Redis 命令吗？如何解决数据库和缓存数据不一致问题？Pika 知道吗？Tendis 和它的区别？如何实现一个 Key 千万并发？（这个有个群的群友的 Zoom 面试题） 消息中间件 RabbitMQ 多节点； RabbitMQ 支持多大的量； 123456789101112131415161718消息中间件解决了哪几个问题？简单介绍下你用的 Kafka。从 Topic -&gt; Record&lt;Key,Value&gt; -&gt; Producer -&gt; acks -&gt; Interceptor -&gt; Broker -&gt; Page Cache -&gt; Controller -&gt; Coordinator -&gt; Partition -&gt; Replica -&gt; Leader Replica -&gt; Follower Replica -&gt; ISR -&gt; Unclean Leader Election -&gt; Consumer -&gt; Consumer Group -&gt; Consumer Offset -&gt; Consumer Group Offset -&gt; Idempotence -&gt; Transaction -&gt; Rebalance -&gt; High Watermark -&gt; Log Deletion -&gt; Leader Epoch -&gt; LEO -&gt; Zero Copy -&gt; Consumer Heartbeat -&gt; Zookeeper 到这结束。它和 RocketMQ、RabbitMQ 有什么区别？什么时候消息会丢失？Producer 网络抖动后，它的消息在哪存着，内存还是磁盘还是哪里？Producer 和 Consumer 什么时候建立的 TCP 连接？为什么这么做？Consumer 为什么要采取 pull 的方式？Producer 为什么采用 push 的方式？为什么用 TCP 不用 HTTP？高水位、LEO 是什么？Lead Epoch 知道吗？幂等性是如何实现的？说下 Kafka 事务，Kafka 事务实现的事务隔离级别？什么时候触发 Rebalance？如何避免？如何指定发送消息到指定 Partition？消息交付可靠性保障承诺三个说下，以及 Kafka 是如何实现它们的？根据消息数以及消息大小，计算需要多少磁盘容量。Kafka 的 JVM 参数调优说下。 JMS 说下是什么？ Spring Spring 容器生命周期 Spring 生命周期 12345678910111213141516Spring Bean Scope 说下。Spring 的注入方式有几种，为什么推荐用构造器注入？@Resource 和 @Autowired 区别说下。什么是 IoC 和 AOP？Spring 解决了什么？@Bean 和 @Component区别说下。Spring Bean 的生命周期说下。Spring AOP 原理，各种 Advice 和 Advisor 说下。AOP 的两种代理方式是什么？AOP 一般作用说下。三级缓存解决循环依赖的过程说下。Spring 的事务传播行为说下。Spring 事务隔离级别说下。Spring 事务实现原理。Spring 用到了哪些设计模式，能分别讲讲它是如何实现的吗，具体是哪些类？BeanFactory 和 ApplicationContext 说下区别。说下BeanFactory 和 FactoryBean 区别？BeanPostProcessor 和 BeanFactoryPostProcessor 区别是什么？Spring 事件知道吗？Spring 如何自定义 xml 解析？各种 Smart 开头的 Bean 的前置处理器，什么时候被调用，你知道吗？Spring Cache 是如何实现的？Spring Data JPA 呢？ 注解扫描如何实现的，你能手写个吗？写过 Spring 的插件吗？如何实现的？代码开源了吗？ Spring MVC1234567891011121314151617181920Spring MVC 执行流程说下。@RestController 和 @Controller 区别说下。怎么取得 URL 中的 { } 里面的变量？Spring MVC 和 Struts2 比有什么优点？Spring MVC怎么样设定重定向和转发的？说下 Spring MVC 的常用注解。如何解决POST请求中文乱码问题，GET的又如何处理呢？Interceptor 和 Filter 区别？Spring MVC 的异常处理 ？怎样在方法里面得 到Request，或者 Session？SpringMvc中函数的返回值是什么？怎么样把ModelMap里面的数据放入Session里面？Spring MVC 的控制器是不是单例模式,如果是,有什么问题,怎么解决？Spring MVC 的 RequestMapping 的方法是线程安全的吗？为什么？介绍下 WebApplicationContext。跨域问题如何解决？如何解决全局异常？validation 有了解吗？用过吗？Json处理如何实现的？哦，你刚才说了父子容器，能讲讲什么是父子容器吗？Spring MVC 国际化有了解过吗？怎么实现的 Spring Boot1234567891011Spring Boot 是如何实现自动装配的？运行 Spring Boot 有几种方式？Spring Boot Starter 工作原理。Spring Boot 核心注解说下。@Enable 类型注解是如何实现的？@Conditional 类型注解呢？自定义过吗？说下异步调用@Async。什么是 YAML？Spring Boot Profiles 如何实现的？ bootstrap.properties 和 application.properties 说下区别。Spring Boot 事件和 Spring 事件有什么关系？Spring Boot Actuator 了解过吗？说一下。Spring Batcher 用过吗，说下。Spring Boot 是如何实现内嵌 Servlet 容器的，在哪行代码启动的？Spring Boot 完美实现了模块化编程，你认同吗？ 分布式123456789101112131415161718192021222324252627282930313233Spring Cloud Netflix 听说你了解。画一下 Spring Cloud Netflix 架构图。说说 Eureka 默认多少秒发送心跳？增量还是全量？CP 还是 AP？如何防止脑裂的？二级缓存知道吗？Eureaka 的自我保护模式说下。ServiceInstance 和 DiscoryClient 知道吗？是干嘛的？分布式事务除了两段提交，还有什么实现方式？哦，你说 Saga，Saga 你说下是什么？Ribbon 是什么说一下，它解决了什么问题？Feign 又是什么？它和 Ribbon 什么关系？Dubbo 和 Feign 区别？Dubbo 的 SPI 知道吗？Zuul 是什么？它和 Nginx 有什么区别？除了 Zuul 还有什么网关可选？Hystrix 是什么？它是如何实现的？熔断、降级和限流他们的区别说一下。Hystrix 信号量机制，隔离策略细粒度控制如何做的？看过源码吗？你优化过吗？微服务十一点说一下分别是什么？分布式配置中心有哪些？你们用的 Apollo 还是 Spring Config 还是其他的？为什么？服务监控有了解吗？什么是幂等？如何实现接口幂等？如何实现分布式 Session？有更好的方法吗？哦，你说了 JWT，能详细说下吗？不同系统的间授权的 OAuth2 了解吗？ MyBatis12345678910111213141516171819MyBatis 了解吗？一级缓存，二级缓存？、# 和 $ 说下。如何实现的动态 SQL？ORM 是什么？和 Hibernate 区别？MyBatis 工作原理？MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？MyBatis 中如何指定使用哪一种 Executor 执行器？模糊查询 like 语句该怎么写？MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？MyBatis 如何执行批量操作？SqlSessionFactoryBean 是什么？如何实现和 Spring 的整合的？Mapper 方法可以重载吗？为什么不可以？MyBatis 是如何将 SQL 执行结果封装为目标对象并返回的？都有哪些映射形式？ Nginx123456789101112131415161718192021Nginx 了解吗，说下其优缺点？怎么实现 Nginx 集群？什么是反向代理？和正向代理区别是什么？Tomcat 和 Nginx 区别？限流怎么做的，有哪三种？令牌桶和漏斗算法是什么，区别是什么？如何在其之上使用 Lua 脚本？有几种负载均衡策略？你们生产上用的哪个？为什么？为什么 Nginx 性能这么高？有没有更高的？F5 又是什么？Nginx 是怎么处理请求的？Nginx 目录有哪些？nginx.conf 配置过吗？有哪些属性模块？静态资源放哪？虚拟主机配置？location 说下。location 语法说下。 Tomcat123456789101112131415161718192021Tomcat 你也了解？什么是 Tomcat 的 Connector？Service、Connector、Container 介绍下它们。详细说下它们是如何处理请求的，能画下它们的架构图吗？如何部署的？一定要放到 webapps 目录下吗？在哪配置？为什么不用 Jetty？区别是什么？Servlet 是线程安全的吗？为什么？怎样让它线程安全？Servlet 初始化过程？init 方法什么时候调用？Servlet 什么时候第一次初始化？JSP 知道吗？有几个内置对象？你说 JSP 是特殊的 Servlet，你看过源码吗？JSP 如何热部署的？EL 表达式知道吗？如何实现的？（大四某打车集团校招的时候被问到的） 分布式 简述 ZAB 协议 简述 zk 的命名服务，配置管理，集群管理 watch 机制 Dubbo 的整体架构设计及分层 分布式数据库保持数据一致 123456789101112131415161718192021云原生了解吗？云原生十二要素说下。Cloud Foundry 平台你知道吗？HeroKu？Kong？你说是六边形架构？你说下什么是六边形架构？整洁架构呢？分层架构了解吗？MVP、MVC 架构说下。负载均衡算法七种说下。如何实现一个秒杀系统。一定不会超卖吗？如何解决？什么是 SOA？什么是微服务？以及两者的区别。什么是事件驱动架构？CAP 和 BASE 说下是什么？最终一致性和人弱一致性什么关系？画一下你们系统的整体架构图。QPS 和 TPS？你们的 QPS 是多少知道吗？压测过吗？说下点击网页的请求过程。哦，你说你是蓝绿部署，什么是蓝绿部署？什么是金丝雀发布？如何实现？ docker1234567891011docker 你也用？docker 生命周期怎么构建 docker 镜像？docker 和虚拟机的区别？docker 好处说下？Kubernetes 你也知道，说下它的组成结构？etcd 是什么？为什么不用 Zookeeper？pod 又是什么？你们生产上怎么用的？如何控制滚动更新过程？ 领域驱动设计1234567891011你说你知道 DDD？能简单说下吗？你们代码落地了吗？是如何拆分服务的？事件风暴又是什么？你们有 Code Review 吗？具体规矩？领域事件是什么？子域、通用域、核心域、支撑域、限界上下文、聚合、聚合根、实体、值对象又是什么？你们有 EventBus 吗？如何使用的？ 编程题12345给二叉树后序和中序遍历，写前序遍历。手写个快排。翻转一下链表。O(1) 找出链表有环。DFS 找出二叉树搜索树第 k 大节点（这些都真的碰过了）。实现一个多线程类，并用该线程类实例化3个线程A,B,C；A线程打印字符A,B线程打印字符B，C线程打印字符C；启动这3个线程，要求启动线程的顺序为C线程-&gt;B线程-&gt;A线程，并且最后输出内容为：A B C。禁止使用 sleep 函数。阿里应该还有各种多线程打印的问题，这个得准备。就是想拿个 6，太难了。这些只是最最最基础的内容。接下来应该是更高级的算法题目，至少是 LeetCode Menium 难度的，翻转链表确实有点初级，练个半个小时就搞定了。暂时还没碰到，碰到我也挂了。应该是动态规划，滑动窗口，字符串的问题，手写 O(1) 的 LRU，回溯，贪心 其它非技术问题12345678910111213141516171819202122232425262728还有一种就是，你们目前技术的缺点是什么？如何优化？有没有更好的优化方案？换作是你，你会怎么做（滴滴面试，不按八股文套路来）？业务量突然增长几十倍，你怎么做？如何架构演进？你有架构设计过吗？你带过新人吗？怎么做的？UML 类图？时序图？流程图？泳道图？甘特图？你用的什么工具？你平时是怎么学习一门新技术的？最近有看书吗？看的什么书？能和我讲讲吗？你为什么离职？（回答工资问题，领导不好的都会挂）下一家公司的期望是什么？期望薪资？你的职业发展规划？你为什么要这个数字的工资？ 未分类问题 I/O 多路复用机制？ GC是什么？为什么要有GC？ 线程池四种创建方式？ 形成死锁的四个必要条件是什么 java 面向对象编程三大特性——封装、继承、多态 什么是IoC和DI？DI是如何实现的？ 假设数组内有5个元素，如果对数组进行反序，该如何做？ Java的内存模型是什么？（JMM是什么？） 什么时候用断言（assert）？ 对象在哪块内存分配？ 一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？ 怎么将 byte 转换为 String？ Swing 是线程安全的？ 线程B怎么知道线程A修改了变量 notify() 和 notifyAll() 有什么区别？ Java 中的 LinkedList 是单向链表还是双向链表？ Java中垃圾回收有什么目的？什么时候进行垃圾回收？ 你对线程优先级的理解是什么？ JVM内存模型 解释servlet如何完成生命周期? Java中是如何支持正则表达式操作的？ 接口有什么特点？ 什么是过滤器？怎么创建一个过滤器 在 Java 程序中怎么保证多线程的运行安全？ 直接内存是什么？ Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型 解释何时在Tomcat使用SSL ? 堆（Heap-线程共享） -运行时数据区 SWAP会影响性能么？ 什么是方法内联？ 谈一谈Hibernate的一级缓存、二级缓存和查询缓存。 Servlet中如何获取用户提交的查询参数或表单数据？ 堆溢出的原因？ Java 中，怎么获取一个文件中单词出现的最高频率？ 你知道哪些JVM性能调优 抽象类必须要有抽象方法吗？ 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？ React的请求应该放在哪个生命周期中? volatile关键字的作用 我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？ 什么是Java虚拟机 CMS 收集器（多线程标记清除算法） 接口和抽象类的区别是什么？ 如何合理分配线程池大小? 什么是线程组，为什么在Java中不推荐使用？ 类加载器 JVM 如何确定垃圾对象？ 字符型常量和字符串常量的区别 G1 收集器 Java 中，直接缓冲区与非直接缓冲器有什么区别？ 如何决定使用 HashMap 还是 TreeMap？ 说一下 ArrayList 的优缺点 构造方法能不能重写？能不能重载？ 什么是红黑树 什么是逃逸分析？ 栈帧里面包含哪些东西？ Tomcat是怎么打破双亲委派机制的呢？ WeakHashMap 是怎么工作的？ java 中操作字符串都有哪些类？它们之间有什么区别？ 什么是JVM？java虚拟机包括什么？ Java 的引用有哪些类型？ 老年代 如何停止一个正在运行的线程？ 常用JVM基本配置参数 线程池都有哪些状态？ 怎么确保一个集合不能被修改？ 怎么检测一个线程是否拥有锁？ 启动一个线程是调用run()还是start()方法？ React组件通信如何实现? Java 中 WeakReference 与 SoftReference的区别？ 常用并发列队的介绍： 什么是数据结构？ 遇到过堆外内存溢出吗？ 会话跟踪技术有那些？ 抽象类和接口的区别? Java中用到的线程调度算法是什么？ 如何使session失效 存储过程与函数的区别 Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？ 用Java写一个折半查找。 对象都是优先分配在年轻代上的吗？ 本地方法区(线程私有) 单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！” JVM 有哪些运行时内存区域？ 为什么Thread类的sleep()和yield ()方法是静态的？ 如何用Java代码列出一个目录下所有的文件？ Java中notify 和 notifyAll有什么区别？ 为什么使用Executor框架？ 如何判断两个类是否相等？ 虚拟DOM实现原理? a = a + b 与 a += b 的区别 JRE、JDK、JVM 及 JIT 之间有什么不同？ HTTP的状态码 线程同步的方法 类ExampleA继承Exception，类ExampleB继承ExampleA。 HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？ volatile关键字的原理是什么？干什么用的？ 写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。 线程的状态流转图 TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？ Java的io流分为哪两种？ 如何解析json对象？ 什么是模板方法模式？ Java 中应该使用什么数据类型来代表价格？ 本地方法栈 静态方法和实例方法有何不同？ JAVA虚引用 原型模式的使用方式 简述一下你了解的设计模式。 Java中有几种类型的流？ 事务的ACID是指什么？ 对象分配规则 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？ 创建对象的过程是什么？ &amp;和&amp;&amp;的区别 为什么wait(), notify()和notifyAll ()必须在同步方法或者同步块中被调用？ Java中的继承是单继承还是多继承 Java 中，如何将字符串 YYYYMMDD 转换为日期？ 请你谈谈对OOM的认识 CopyOnWriteArrayList可以用于什么应用场景？ 什么时候使用享元模式？ 线上常用的 JVM 参数有哪些？ 什么是并发容器的实现？ 在java中wait和sleep方法的不同？ Error和Exception有什么区别？ 你所了解的数据源技术有那些？使用数据源有什么好处？ 存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么？如 C = (C) B； 有哪些打破了双亲委托机制的案例？ Java 中，Comparator 与 Comparable 有什么不同？ 四种构建线程池的区别及特点？ synchronized的作用？ 什么情况发生栈溢出？ 对象的相等与指向他们的引用相等，两者有什么不同？ String类的常用方法有那些？ 在做文件上传的时候，form表单的enctype的指是什么？ 死锁的原因 Spring MVC的工作原理是怎样的？ Java 中的final关键字有哪些用法？ 阐述Spring框架中Bean的生命周期？ GC 是什么? 为什么要有 GC Java中ConcurrentHashMap的并发度是什么？ 38、数据类型之间的转换： volatile 类型变量提供什么保证？ 不可变对象对多线程有什么帮助 分区收集算法 safepoint是什么？ 什么是阻塞式方法？ 解释什么是Jasper? 说一下 runnable 和 callable 有什么区别 抽象类可以使用final修饰吗？ 双亲委派机制可以被违背吗？请举例说明。 如何让正在运行的线程暂停一段时间？ Tcp协议的特点 如何在两个线程间共享数据？ java中有没有指针？ 什么是多线程 a.hashCode() 有什么用？与 a.equals(b) 有什么关系？ 堆和栈的区别 JDBC能否处理Blob和Clob？ 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？ 简述一下面向对象的”六原则一法则”。 MinorGC，MajorGC、FullGC都什么时候发生？ JVM 运行时内存 如何自定义一个异常 synchronized、volatile、CAS比较 JVM有哪些内存区域？(JVM的内存布局是什么？) 强引用、软引用、弱引用、虚引用是什么？ Java 中垃圾收集的方法有哪些 CMS都有哪些问题？ redux中如何进行异步操作? 什么是多线程的上下文切换 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？ 谈谈你知道的垃圾回收算法 重载与重写 Java 线程数过多会造成什么异常？ Java 中 ++ 操作符是线程安全的吗？ 三种代理的区别 在不使用 StringBuffer 的前提下，怎么反转一个字符串？ 什么叫线程安全？servlet 是线程安全吗? short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？ 如果你提交任务时，线程池队列已满，这时会发生什么 什么情况下会发生栈溢出？ 死锁与活锁的区别，死锁与饥饿的区别？ 代理的分类 多线程的价值？ GC 是什么？为什么要有 GC？ 什么是JDK？什么是JRE? Final在java中的作用 请说明NAT协议的目的是什么? 抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？ 那针对浮点型数据运算出现的误差的问题，你怎么解决？ Java中集合框架的有几个？ Java 中，DOM 和 SAX 解析器有什么不同？ java中是值传递引用传递？ 如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？ final、finalize()、finally，作用 为什么HashMap中String、Integer这样的包装类适合作为K？ 除了使用new创建对象之外，还可以用什么方法创建对象？ 继承和组合之间有什么不同？ 数组有没有length()方法？String有没有length()方法？ 事务的使用场景在什么地方？ 说一下堆和栈的区别 除了单例模式，你在生产环境中还用过什么设计模式？ 什么是工厂模式 synchronized可重入的原理 双亲委派 说出 5 条 IO 的最佳实践(答案) 写一段代码在遍历 ArrayList 时移除一个元素？ 分代收集算法 CopyOnWriteArrayList 的使用场景? ArrayList 和 HashMap 的默认大小是多数？ 如果使用Object作为HashMap的Key，应该怎么办呢？ 同步方法和同步块，哪个是更好的选择? 线程的 run()和 start()有什么区别？ 实际开发中应用场景哪里用到了模板方法 为什么要学习工厂设计模式 描述 Java 中的重载和重写？ 什么是设计模式 Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？ List接口有什么特点？ 线程与进程的区别 java如何实现多线程之间的通讯和协作？ ConcurrentHashMap的并发度是什么 常用的集合类有哪些？ 为什么 Java 中的 String 是不可变的（Immutable）？ 在老年代-标记整理算法 阐述ArrayList、Vector、LinkedList的存储性能和特性。 Java中异常分为哪两种？ SynchronizedMap和ConcurrentHashMap有什么区别？ 你做过 JVM 调优，说说如何查看 JVM 参数默认值？ 你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？ 什么是重写？什么是重载？ Java 中 WeakReference 与 SoftReference 的区别？ String str=”aa”,String s=”bb”,String aa=aa+s;一种创建了几个对象？ 如何设置请求的编码以及响应内容的类型？ JVM怎么判断一个对象是不是要回收？ 有哪些 GC 算法？ Serial 与 Parallel GC之间的不同之处？ ArrayList和Vector有什么不同之处？ 如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？ 在Java中，如何跳出当前的多重嵌套循环？ 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？ 集合和数组的区别 线程池的执行原理？ 你知道有哪些开源框架？ 如何确保线程安全？ 个线程和 2 个线程的同步代码，哪个更容易写？ 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗 接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？ ArrayList 与 LinkedList 的不区别？ Java语言有哪些特点？ Java 中的 HashSet，内部是如何工作的？ 创建一个子类对象的时候，那么父类的构造方法会执行吗？ 适配器模式和代理模式之前有什么不同？ 环境变量Path和ClassPath的作用是什么？如何设置这两个环境变量？ Spring中Bean的作用域有哪些？ 什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？ 策略模式的优点和缺点 Spring中如何使用注解来配置Bean？有哪些相关的注解？ 什么是乐观锁和悲观锁 多线程的劣势： Java的数据结构有那些？ 你都用过G1垃圾回收器的哪几个重要参数？ 类与对象的关系? 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？ ==与equlas有什么区别？ JDBC中如何进行事务处理？ 程序的结构有那些？ 怎么打出线程栈信息？ 抽象类（abstract class）和接口（interface）有什么异同？ 怎么打破双亲委派模型？ 你知道哪些垃圾收集器？ 什么是多线程中的上下文切换？ sleep() 和 wait() 有什么区别？ 构造方法能不能重载？能不能重写？ 什么是游标？ 在异常捕捉时，如果发生异常，那么try.catch.finally块外的return语句会执行吗？ CAS 的会产生什么问题？ List，Set，Map三者的区别？ 什么是面向对象？ 在没有使用临时变量的情况如何交换两个整数变量的值？ JVM 数据运行区，哪些会造成 OOM 的情况？ 描述一下JVM加载class文件的原理机制？ 什么是线程池？ 为什么要使用它？ 什么情况下会违反迪米特法则？为什么会有这个问题？ Java中的包装类都是那些？ String 类的常用方法都有那些？ String s = new String(“xyz”);创建了几个字符串对象？ CopyOnWriteArrayList 的缺点? 什么是线程池？有哪几种创建方式？ 什么是观察者模式 使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？ Java 中会存在内存泄漏?简述一下 什么是多线程中的上下文切换？ 谈谈永久代 HashMap 与 HashTable 有什么区别？ 集合框架底层数据结构 当打开其他程序的网页时，使用的target属性是哪个？ java中有几种方法可以实现一个线程？ 多线程的常用方法 可以直接调用Thread类的run ()方法么？ 如果父类只有有参构造方法，那么子类必须要重写父类的构造方法吗？ 守护线程和用户线程有什么区别呢？ 你在项目中哪些地方用到了XML？ 什么时候使用组合模式？ 是否可以继承String类？ 栈 阐述JDBC操作数据库的步骤。 谈谈对 OOM 的认识 说一下垃圾分代收集的过程 什么是UML？ 怎么查看服务器默认的垃圾回收器是哪一个？ 简述Java的对象结构 什么是CAS 请解释StackOverflowError和OutOfMemeryError的区别？ Java中如何实现多线程 TCP编程与UDP编程有什么区别？ 用Java写一个单例类。 Js如何实现动态效果？ JIT 是什么？ Java反射创建对象效率高还是通过new创建对象的效率高？ 并发关键字 synchronized ？ 举例说明同步和异步。 Iterator 和 ListIterator 有什么区别？ 说一下HashMap的实现原理？ 什么是多态机制？Java语言是如何实现多态的？ 解释一下什么叫AOP（面向切面编程）？ 说说G1垃圾收集器的工作原理 TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？ 说一下 synchronized 底层实现原理？ 什么是 Busy spin？我们为什么要使用它？ Java 中 ConcurrentHashMap 的并发度是什么？ 对象的访问方式有哪些？ AQS支持两种同步方式： 你经常使用什么并发容器，为什么？ 在 Java 中 Executor 和 Executors 的区别？ 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？ 谈谈动态年龄判断 什么是 Callable 和 Future? Jsp包含那些隐藏对象或者内建对象 什么是集合 常见的计算机网络协议有那些？ 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？ 为什么要使用并发编程 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？ 怎么检查一个字符串只包含数字？解决方案 Java 中怎么打印数组？ JAVA 强引用 请解释将Tomcat作为一个Windows 服务运行会带来哪些好处? synchronized 和 volatile 的区别是什么？ 上传文件是如何做的？ 页面前进或者后退 多线程的好处 你知道哪些内存分配与回收策略？ 常用io类有那些？ 43.将下java中的math类有那些常用方法？ 描述一下什么情况下，对象会从年轻代进入老年代 JVM 的内存模型是什么？ Query接口的list方法和iterate方法有什么区别？ 什么是方法内联？ 线程类的构造方法、静态块是被哪个线程调用的 你将如何使用thread dump？你将如何分析Thread dump？ 线程池作用？ 什么时候使用模板方法 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？ 什么是ThreadLocal变量？ 如何检查出两个给定的字符串是反序的？ 用哪两种方式来实现集合的排序？ Html中a标签的target属性有哪些值？ 说出至少 5 点在 Java 中使用线程的最佳实践。 Java 中会存在内存泄漏吗，请简单描述。 HashMap 和 ConcurrentHashMap 的区别 你如何在Java中获取线程堆栈？ 标记整理算法(Mark-Compact) 面向对象的语言有那些特征？ Spring中自动装配的方式有哪些？ 说出 5 个 JDK 1.8 引入的新特性？ HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现 指出下面程序的运行结果 线程类的构造方法、静态块是被哪个线程调用的 JVM 的内存模型以及分区情况和作用 数组实例化有几种方式？ 重定向和请求转发的区别？ UML中有哪些常用的图？ 多线程中 synchronized 锁升级的原理是什么？ 抽象类必须要有抽象方法吗 notify()和notifyAll()有什么区别？ redux与mobx的区别? 用 Java 写一个线程安全的单例模式（Singleton）？ 访问修饰符public,private,protected,以及不写（默认）时的区别？ 如何边遍历边移除 Collection 中的元素？ SynchronizedMap 和 ConcurrentHashMap 有什么区别？ Java 中，抽象类与接口之间有什么不同？ 什么是Executors？ 死锁与活锁的区别，死锁与饥饿的区别？ 堆的作用是什么？ 垃圾回收的优点和原理。说说2种回收机制 React如何进行组件/逻辑复用? 请解释一下MAC代表什么? ThreadLocal是什么？有什么用？ 线程的生命周期？ 说几个常见的编译时异常类？ Java 如何实现多线程之间的通讯和协作？ 什么是Java Timer 类？如何创建一个有特定时间间隔的任务？ 使用js获取一个表单元素 多线程同步和互斥有几种实现方法，都是什么？ 什么是重排序 Java 中 java.util.Date 与 java.sql.Date 有什么区别？ 说说类加载的过程 React最新的生命周期是怎样的? 复制算法（copying） 用Java的套接字编程实现一个多线程的回显（echo）服务器。 Try.catch.finally是必须要存在的吗？ 你熟悉哪些垃圾收集算法？ 为什么HashTable是线程安全的？ finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？ 用最有效率的方法计算2乘以8？ 多线程应用场景 List 和 Set 的区别 实现可见性的方法有哪些？ 堆 为什么 Thread 类的 sleep()和 yield ()方法是静态的？ Java都有那些开发平台？ Java 中能创建 volatile 数组吗？ 线程 B 怎么知道线程 A 修改了变量 GC日志的real、user、sys是什么意思？ 你说你做过JVM参数调优和参数配置，请问如何查看JVM系统默认值 什么是ORM？ 串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？ 为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用 Java对象创建过程 java 中 IO 流分为几种？ 在Java中Executor和Executors的区别？ 说说 JVM 如何执行 class 中的字节码。 构造方法有哪些特性？ 如何将字符串反转？ 什么是Callable和Future? ZGC收集器中的染色指针有什么用？ TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？ Java 中，嵌套公共静态类与顶级类有什么不同？ == 和 equals 的区别是什么？ 你都有哪些手段用来排查内存溢出？ 本地方法栈的作用？ 工厂模式好处 用Java实现阻塞队列 你对 Time Slice的理解? 描述一下JVM加载class文件的原理机制？ Java 中的同步集合与并发集合有什么区别？ JVM垃圾回收机制，何时触发MinorGC等操作 对象分配内存的方式有哪些？ Java中用到的线程调度算法是什么 Session与cookie的区别？ 如何实现数组和 List 之间的转换？ 动态改变构造 说一下 HashSet 的实现原理？ 怎么获取 Java 程序使用的内存？堆使用的百分比？ JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？ synchronized和ReentrantLock的区别 Lock 接口和synchronized 对比同步它有什么优势？ 说说类加载的过程 接口是什么？为什么要使用接口而不是直接使用具体类？ 什么是并发容器的实现？ switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？ Java 中的 TreeMap 是采用什么树实现的？(答案) 那些地方用到了单例模式 什么是原子类 永久代 Semaphore有什么作用 什么是同步任务？什么是异步任务？ import java和javax有什么区别 什么是单例 什么是线程池？ 程序计数器 什么是外观模式 CopyOnWriteArrayList 是什么? 判断两个对象是否相同，能使用equlas比较吗？ 遇到过元空间溢出吗？ 你能保证 GC 执行吗？ GC的回收流程是怎样的？ Collection 和 Collections 有什么区别？ 并发编程有什么缺点 内存溢出和内存泄漏的区别？ 当父类引用指向子类对象的时候，子类重写了父类方法和属性，那么当访问属性的时候，访问是谁的属性？调用方法时，调用的是谁的方法？ JRE、JDK、JVM 及 JIT 之间有什么不同？ 解释 Java 堆空间及 GC？ 在Java中CycliBarriar和CountdownLatch有什么区别？ Java线程池中submit() 和 execute()方法有什么区别？ 什么是内存屏障？ 打印昨天的当前时刻。 String和StringBuilder、StringBuffer的区别？ 建造者模式的使用场景 Serial Old 收集器（单线程标记整理算法 ） Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？ 策略模式应用场景 setState到底是异步还是同步? 阐述final、finally、finalize的区别。 什么是父类引用指向子类对象？ ArrayList 和 Vector 的区别是什么？ 线程之间如何通信及线程之间如何同步 Java中你怎样唤醒一个阻塞的线程？ 你如何确保main()方法所在的线程是Java 程序最后结束的线程？ java 中的 Math.round(-1.5) 等于多少？ 线程的状态 FutureTask是什么 Hashtable 与 HashMap 有什么不同之处？ Thow与thorws区别 Java线程具有五中基本状态 构造方法能不能显式调用？ 哪些是 GC Roots？ 你知道哪些故障处理工具？ Java 中怎样将 bytes 转换为 long 类型？ 程序计数器有什么作用？ 如果一个类中有抽象方法，那么这个一定是抽象类？ 什么是隐式转换，什么是显式转换 如何创建守护线程？ 单例优缺点 标记清除算法（ Mark-Sweep） 在进行数据库编程时，连接池有什么作用？ 创建线程的四种方式 多线程场景下如何使用 ArrayList？ 线程的调度策略 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？ 栈溢出的原因？ JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的 &amp;和&amp;&amp;的区别？ 怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？ 强引用、软引用、弱引用、虚引用是什么，有什么区别？ String 是最基本的数据类型吗？ 使用sql写出一个分页程序？ 说一下 JVM 调优的工具？ react-redux是如何工作的? Java中有几种数据类型 Java线程数过多会造成什么异常？ 分代回收 调优命令有哪些？ Object类常用方法有那些？ Java 中，Serializable 与 Externalizable 的区别？ Executors类是什么？ 请解释一下什么时候可以使用“.”，什么时候可以使用“[]”? 创建一个对象用什么运算符？对象实体与对象引用有何不同？ 列出 5 个应该遵循的 JDBC 最佳实践 什么是FutureTask?使用ExecutorService启动任务。 对于JDK自带的监控和性能分析工具用过哪些？ 什么是类加载器，类加载器有哪些？ 各种回收算法 请解释什么是Tomcat Coyote ? 方法区溢出的原因？ 如何在jsp页面上显示一些特定格式的数字或者日期 ZGC 了解吗？ 你平时工作中用过的JVM常用基本配置参数有哪些？ 怎么看死锁的线程？ 类的实例化顺序 比较一下Java和JavaSciprt。 HashMap中的key，可以是普通对象么？需要什么注意的地方？ 如何判断一个常量是废弃常量 ？ synchronized关键字的用法？ 面向对象和面向过程的区别 在使用jdbc的时候，如何防止出现sql注入的问题。 介绍一下类文件结构吧！ 字符串常量存放在哪个区域？ 什么是多线程环境下的伪共享（false sharing）？ 编写多线程程序有几种实现方式？ 例如： if(a+1.0=4.0)，这样做好吗？ Get请求与post有什么区别？ JVM的引用类型有哪些？ 哪个类包含 clone 方法？是 Cloneable 还是 Object？ 有什么堆外内存的排查思路？ 什么是AQS 64 位 JVM 中，int 的长度是多数？ 生产环境 CPU 占用过高，你如何解决？ Java 中，怎么打印出一个字符串的所有排列？ 请解释Tomcat中使用的连接器是什么? 插入数据时 ArrayList、LinkedList、Vector谁速度较快？ java中会存在内存泄漏吗，请简单描述。 什么是方法重载？ 什么是模板方法 Java中的同步集合与并发集合有什么区别？ 说出 JDK 1.7 中的三个新特性？ 如何使用exception对象？ Serial 垃圾收集器（单线程、 复制算法） 为什么wait, notify 和 notifyAll这些方法不在thread类里面？ as-if-serial规则和happens-before规则的区别 什么是 CAS 两个相同的对象会有不同的的 hash code 吗？ 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？ final不可变对象，它对写并发应用有什么帮助？ Java中操作字符串使用哪个类？ 在 Java 程序中怎么保证多线程的运行安全？ JIT是什么？ 类加载有几个过程？ JSP中的静态包含和动态包含有什么区别？ 线程池的优点？ Java 中，怎么在格式化的日期中显示时区？ 什么是原型模式 Javascript中常用的事件有哪些？ 32 位和 64 位的 JVM，int 类型变量的长度是多数？ 常用的并发工具类有哪些？ 什么是不可变对象，它对写并发应用有什么帮助？ 单例模式的线程安全性 什么是阻塞式方法？ 调优工具 创建线程的三种方式的对比？ 什么是JDK?什么是JRE？ 在 Java 中，对象什么时候可以被垃圾回收？ Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别? 如何将字符串反转？ 如何通过反射获取和设置对象私有字段的值？ 并发队列的常用方法 Set接口有什么特点 说说你知道的几种主要的JVM参数 “a==b”和”a.equals(b)”有什么区别？ 什么是并发队列： Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？ Linux环境下如何查找哪个线程使用CPU最长 并发编程三要素？ 四种线程池的创建： 说说CMS垃圾收集器的工作原理 请解释如何配置Tomcat来使用IIS和NTLM ? 线程的sleep()方法和yield()方法有什么区别？ JAVA弱引用 方法区 Java应用程序与小程序之间有那些差别？ sleep方法和wait方法有什么区别? 普通类与抽象类有什么区别？ 现实生活中的模板方法 一个线程运行时发生异常会怎样？ 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ Java 中怎么创建 ByteBuffer？ Json是什么？ JVM调优命令有哪些？ 集合的特点 Java内存模型 什么是线程同步和线程互斥，有哪几种实现方式？ Java 中，throw 和 throws 有什么区别 运行时常量池溢出的原因？ 假如生产环境CPU占用过高，请谈谈你的分析思路和定位。 Java的双亲委托机制是什么？ 什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？ char 型变量中能不能存贮一个中文汉字，为什么？ 84.Map有什么特点 监听器有哪些作用和用法？ final 在 java 中有什么作用？ Minor GC与Full GC分别在什么时候发生？ Minor Gc和Full GC 有什么不同呢？ Java 中，怎样才能打印出数组中的重复元素？ 一个java类中包含那些内容？ synchronized 和 ReentrantLock 区别是什么？ 使用Log4j对程序有影响吗？ 在新生代-复制算法 对象是怎么从年轻代进入老年代的？ int和Integer有什么区别？ Java 中的内存映射缓存区是什么？ 你能解释一下里氏替换原则吗? 类加载的过程是什么？ 说出几点 Java 中使用 Collections 的最佳实践 程序计数器为什么是私有的? 为什么需要双亲委派模式？ HashSet与HashMap的区别 用 wait-notify 写一段代码来解决生产者-消费者问题？ 谈谈你知道的垃圾收集器 GC垃圾回收算法与垃圾收集器的关系？ 什么是B/S架构？什么是C/S架构 什么是事务？事务有那些特点？ Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？ 什么是happen-before原则？ 工厂模式分类 GC Roots 有哪些？ Static关键字有什么作用？ 如何部署一个web项目？ Jsp由哪些内容组成？ 为什么你应该在循环中检查等待条件? 重载和重写的区别 什么是Future？ 请说明select * from tab的输出结果是什么? JVM 提供的常用工具 CyclicBarrier和CountDownLatch的区别 Collection 和 Collections 有什么区别？ safepoint 是什么？ List、Map、Set三个接口存取元素时，各有什么特点？ 什么是线程池（thread pool）？ 什么是Executors框架？ Java中Synchronized关键字的使用？ 对象的内存布局了解吗？ 什么是链表 TCP 协议与 UDP 协议有什么区别？ 代理模式应用场景 Super与this表示什么？ volatile 能使得一个非原子操作变成原子操作吗？ 可以描述一下 class 文件的结构吗？ 聚集索引与非聚集索引有什么区别？ JAVA为什么需要接口？ 你知道哪些GC类型？ 62、volatile 变量和 atomic 变量有什么不同？ HashSet如何检查重复？HashSet是如何保证数据不可重复的？ volatile有什么用？能否用一句话说明下volatile的应用场景？ 异常的处理机制有几种？ 怎么在JDBC内调用一个存储过程 Collection接口下有那些集合框架？ MinorGC、MajorGC、FullGC 什么时候发生？ ReadWriteLock是什么 自动装箱与拆箱 设计模式的六大原则 给我一个符合开闭原则的设计模式的例子？ ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？ 如何避免线程死锁 类加载是什么？ 说说线程栈 url是什么？由哪些部分组成？ comparable 和 comparator的区别？ 在Java中定义一个不做事且没有参数的构造方法的作用 CopyOnWriteArrayList 的设计思想? 能够找到 Reference Chain 的对象，就一定会存活么？ 什么是竞争条件？你怎样发现和解决竞争？ 为什么代码会重排序？ 谈谈双亲委派模型 谈谈 JVM 中的常量池 JVM垃圾回收时候如何确定垃圾？什么是GC Roots？ Session加载实体对象的过程。 32 位和 64 位的 JVM，int 类型变量的长度是多数？ 为什么 ArrayList 的 elementData 加上 transient 修饰？ JAVA软引用 Parallel Scavenge 收集器（多线程复制算法、高效） Java 虚拟机栈的作用？ CAS的问题 什么情况会造成元空间溢出？ final、finalize 和 finally 的不同之处？ Sql优化有那些方法？ Files的常用方法都有哪些？ 32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？ 如何开启和查看 GC 日志？ 怎么判断并发队列是阻塞队列还是非阻塞队列 说说ZGC垃圾收集器的工作原理 3*0.1 == 0.3 将会返回什么？true 还是 false？ 什么时候会触发FullGC @Before 和 @BeforeClass 有什么区别？ 什么是线程局部变量？ Error与Exception区别？ 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？ 集合的特点 React有哪些优化性能是手段? 虚拟机栈(线程私有) 为什么要学习设计模式 构造器注入和 setter 依赖注入，那种方式更好？ 怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？ 什么时候使用访问者模式？ int 和 Integer 哪个会占用更多的内存？ mixin、hoc、render props、react-hooks的优劣如何？ 如何阻止表单提交 Java常用包有那些？ 什么是Daemon线程？它有什么意义？ 怎么利用 JUnit 来测试一个方法的异常？ Js如何跳转到到一个指定页面 阻塞队列和非阻塞队列区别 Java 中 interrupted 和 isInterrupted 方法的区别？ jspservlet中通信作用域有那些？ 重排序遵守的规则 类、方法、成员变量和局部变量的可用修饰符 如何判断一个类是无用的类? Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？ 在多线程环境下，SimpleDateFormat 是线程安全的吗？ String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？ 详细介绍一下JVM内存模型 i与i的区别 try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后? 使用集合框架的好处 Hibernate的对象有几种状态 HashMap是怎么解决哈希冲突的？ Thread类中的yield方法有什么作用？ 说一下 Atomic的原理？ 原子类的常用类 关于 OOP 和设计模式的面试题 JVM 监控与分析工具你用过哪些？介绍一下。 ArrayList与LinkedList有什么区别？ 什么时候会造成堆外内存溢出？ 什么是指令重排序？ final、finalize()、finally，性质不同 请说出与线程同步以及线程调度相关的方法。 线程之间是如何通信的？ HashMap的put方法的具体流程？ 什么是策略模式 Java中interrupted 和 isInterrupted方法的区别？ 嵌套静态类与顶级类有什么区别？ List、Set、Map是否继承自Collection接口？ 如何测试静态方法？() 假设把实例化的数组的变量当成方法参数，当方法执行的时候改变了数组内的元素，那么在方法外，数组元素有发生改变吗？ Java中的ReadWriteLock是什么？ 什么是建造者模式 Java 中如何格式化一个日期？如格式化为 ddMMyyyy 的形式？","link":"/2297f450f42d/"},{"title":"JVM","text":"JVM 面试题 基础怎样判断 JVM 是 32 位还是 64 位可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息。 32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。 编译期常量是什么公共静态不可变（public static final）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的 JAR。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。 对象分配内存是否线程安全对象创建十分频繁，即使修改一个指针的位置在并发下也不是线程安全的，可能正给对象 A 分配内存，指针还没来得及修改，对象 B 又使用了指针来分配内存。 解决方法 CAS 加失败重试保证更新原子性。 把内存分配按线程划分在不同空间，即每个线程在 Java 堆中预先分配一小块内存，叫做本地线程分配缓冲 TLAB，哪个线程要分配内存就在对应的 TLAB 分配，TLAB 用完了再进行同步。 Java 程序是怎样运行的 首先通过 Javac 编译器将 .java 转为 JVM 可加载的 .class 字节码文件。 javac 是由 Java 编写的程序，编译过程可以分为： 词法解析：通过空格分割出单词、操作符、控制符等信息，形成 token 信息流，传递给语法解析器； 语法解析：把 token 信息流按照 Java 语法规则组装成语法树； 语义分析：检查关键字使用是否合理、类型是否匹配、作用域是否正确等； 字节码生成：将前面各个步骤的信息转换为字节码； 字节码必须通过类加载过程加载到 JVM 后才可以执行，执行有三种模式，解释执行、JIT 编译执行、JIT 编译与解释器混合执行（主流 JVM 默认执行的方式）。混合模式的优势在于解释器在启动时先解释执行，省去编译时间。 之后通过即时编译器 JIT 把字节码文件编译成本地机器码。 Java 程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会认定其为「热点代码」，热点代码的检测主要有基于采样和基于计数器两种方式，为了提高热点代码的执行效率，虚拟机会把它们编译成本地机器码，尽可能对代码优化，在运行时完成这个任务的后端编译器被称为即时编译器。 还可以通过静态的提前编译器 AOT 直接把程序编译成与目标机器指令集相关的二进制代码。 说一下 Java 对象的创建过程 类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 分配内存：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有「指针碰撞」和「空闲列表」两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。选择以上 2 种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是「标记-清除」，还是「标记-整理」（也称作「标记-压缩」），值得注意的是，复制算法内存也是规整的。 在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：CAS + 失败重试：CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。TLAB：为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配 初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 设置对象头：初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 执行 init 方法：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 64 位 JVM 中，int 的长度是多少Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的 Java 虚拟机中，int 类型的长度是相同的。 守护线程和本地线程区别Java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。 任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(booleon);true 则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon() 必须在 Thread.start() 之前调用，否则运行时会抛出异常。 区别： 唯一的区别是判断虚拟机 JVM 何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。也可以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的线程；比如 JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线程时，Java 虚拟机会自动离开。 扩展： Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break 的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。 Java 会存在内存泄漏吗内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java 是有 GC 垃圾回收机制的，也就是说，不再被使用的对象，会被 GC 自动回收掉，自动从内存中清除 但是，即使这样，Java 也还是存在着内存泄漏的情况，Java 导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是 Java 中内存泄露的发生场景。 Java 对象的布局对象头区域此处存储的信息包括两部分： 对象自身的运行时数据(MarkWord)，占 8 字节 存储 hashCode、GC 分代年龄、锁类型标记、偏向锁线程 ID、CAS 锁指向线程 LockRecord 的指针等， synconized 锁的机制与这个部分( markwork )密切相关，用 markword 中最低的三位代表锁的状态，其中一位是偏向锁位，另外两位是普通锁位。 对象类型指针(Class Pointer)，占 4 字节 对象指向它的类元数据的指针、 JVM 就是通过它来确定是哪个 Class 的实例。 实例数据区域 此处存储的是对象真正有效的信息，比如对象中所有字段的内容 对齐填充区域 JVM 的实现 HostSpot 规定对象的起始地址必须是 8 字节的整数倍，换句话来说，现在 64 位的 OS 往外读取数据的时候一次性读取 64bit 整数倍的数据，也就是 8 个字节，所以 HotSpot 为了高效读取对象，就做了「对齐」，如果一个对象实际占的内存大小不是 8byte 的整数倍时，就「补位」到 8byte 的整数倍。所以对齐填充区域的大小不是固定的。 stackoverflow 错误、permgen space 错误stackoverflow 错误主要出现在虚拟机栈中（线程请求的栈深度大于虚拟机栈锁允许的最大深度） permgen space 错误（针对 JDK7 之前版本）： 大量加载 class 文件 常量池内存溢出 Java 有哪些引用类型 强引用：这种引用属于最普通最强硬的一种存在，只有在和 GC Roots 断绝关系时，才会被消灭掉。 软引用：软引用用于维护一些可有可无的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。可以看到，这种特性非常适合用在缓存技术上。比如网页缓存、图片缓存等。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。 弱引用：弱引用对象相比较软引用，要更加无用一些，它拥有更短的生命周期。当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。弱引用拥有更短的生命周期，在 Java 中，用 java.lang.ref.WeakReference 类来表示。它的应用场景和软引用类似，可以在一些对内存更加敏感的系统里采用。 虚引用：这是一种形同虚设的引用，在现实场景中用的不是很多。虚引用必须和引用队列（ReferenceQueue）联合使用。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。实际上，虚引用的 get，总是返回 null。 对象的访问定位有哪几种方式建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有 2 种： 句柄：如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 直接指针：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。 这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。 类描述一下 JVM 加载 class 文件的原理机制 JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中各类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的 .class 文件中的数据读入到内存中，通常是创建一个字节数组读入 .class 文件，然后产生与所加载类对应的 Class 对象。 加载完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后 JVM 对类进行初始化： 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类; 果类中存在初始化语句，就依次执行这些初始化语句。 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader 的子类）。 从 JDK2 开始，类加载过程采取了父亲委托机制（PDM）。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。 类加载器的说明： Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）； Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap； System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。 Class 文件Class 文件是一组以 8 位字节为基础单位的二进制流。各个数据项严格按顺序排列。 Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据。这样的伪结构仅仅有两种数据类型：无符号数和表。 无符号数：是基本数据类型。以 u1、u2、u4、u8 分别代表 1 个字节、2 个字节、4 个字节、8 个字节的无符号数，能够用来描写叙述数字、索引引用、数量值或者依照 UTF-8 编码构成的字符串值。 表：由多个无符号数或者其它表作为数据项构成的复合数据类型。全部表都习惯性地以 _info 结尾。 类加载器类加载器是 JVM 的组成部分之一。将字节码文件加载进 JVM，JDK 有三个类加载器： BootstrapClassLoader 根类加载器：ExtClassLoader 的加载，加载 %JAVA_HOME%/lib 下的 jar 包和 class 文件； ExtClassLoader 扩展类加载器：AppClassLoader 的加载器，加载 %JAVA_HOME%/lib/ext 文件夹下的的 jar 包和 class 类，开发者可以直接使用标准扩展类加载器； AppClassLoader 系统加载器：加载自定义的类，负责加载 classpath 下的类文件。线程上下文加载器（每个加载器都可以访问这个加载器）； CustomClassLoader 抽象类加载器：用户自定义的类加载器，继承 ClassLoader 即可实现自定义类加载器； JVM 默认采用的是双亲委派类加载机制，即先加载父类在加载子类，对上面四个类加载器采用自顶向下加载 类加载顺序有继承关系： 父类的静态字段或静态语句块（依据代码先后顺序）； 子类的静态字段或静态语句块（依据代码先后顺序）； 父类普通变量以及语句块加载（依据代码先后顺序）； 父类构造方法加载； 子类普通变量以及语句块加载（依据代码先后顺序）； 子类构造方法加载； 无继承关系： 静态字段或静态语句块（依据代码先后顺序）； 普通变量以及语句块加载（依据代码先后顺序）； 构造方法加载； JVM 类加载机制JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化。 加载加载是类加载过程中的一个阶段， 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象， 作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。 验证这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 准备准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为： 实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080， 将 v 赋值为 8080 的 put static 指令是程序被编译后，存放于类构造器方法之中。 但是注意如果声明为： public static final int v = 8080; 在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值为 8080。 解析解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的： CONSTANT_Class_info CONSTANT_Field_info CONSTANT_Method_info 等类型的常量。 符号引用 符号引用与虚拟机实现的布局无关， 引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。 直接引用 直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。 初始化初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。 类构造器 初始化阶段是执行类构造器方法的过程。方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子方法执行之前，父类的方法已经执行完毕， 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成()方法。 注意以下几种情况不会执行类初始化： 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 定义对象数组，不会触发该类的初始化。 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。 通过类名获取 Class 对象，不会触发类的初始化。 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。 类初始化的情况 遇到 new、getstatic、putstatic 或 invokestatic 字节码指令时，还未初始化。典型场景包括 new 实例化对象、读取或设置静态字段、调用静态方法。 对类反射调用时，还未初始化。 初始化类时，父类还未初始化。 虚拟机启动时，会先初始化包含 main 方法的主类。 使用 JDK7 的动态语言支持时，如果 MethodHandle 实例的解析结果为指定类型的方法句柄且句柄对应的类还未初始化。 接口定义了默认方法，如果接口的实现类初始化，接口要在其之前初始化。 其余所有引用类型的方式都不会触发初始化，称为被动引用。被动引用实例： 子类使用父类的静态字段时，只有父类被初始化。 通过数组定义使用类。 常量在编译期会存入调用类的常量池，不会初始化定义常量的类。 接口和类加载过程的区别：初始化类时如果父类没有初始化需要初始化父类，但接口初始化时不要求父接口初始化，只有在真正使用父接口时（如引用接口中定义的常量）才会初始化。 内存基本术语 堆：heap 栈：stack 方法区：method area 永久代：PermGen 元空间：MetaSpace 新生代： 老年代 Survivor From Survivor To Survivor Eden 内存分配寄存器：我们无法控制。 静态域：static 定义的静态成员。 常量池：编译时被确定并保存在 .class 文件中的（final）常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法和名称和描述符）。 非 RAM 存储：硬盘等永久存储空间。 堆内存：new 创建的对象和数组，由 Java 虚拟机自动垃圾回收器管理,存取速度慢。 栈内存：基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可以共享，但是大小与生存期必须确定，缺乏灵活性。 W JVM 内存区域JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。 线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。 线程共享区域随虚拟机的启动/关闭而创建/销毁。 直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于Channel与 Buffer的IO方式, 它可以使用Native函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。 W 内存结构JVM内存划分_疯一样的女子-CSDN博客_jvm内存 程序计数器 当前线程所执行的字节码的行号指示器，循环、异常处理、线程恢复等基础功能都需要依赖这个计数器； 此内存区域是唯一在 Java 虚拟机规范中没有规定任何 OOM 情况的区域； Java 虚拟机栈 每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息； 方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程，当方法被调用入栈，完成调用出栈。所有的栈帧都出栈后，线程就结束了； 局部变量表存放了编译器可知的各种基本数据类型、对象引用、returnAddress 类型。局部变量表所需的内存空间在编译器完成分配。当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小； 对象引用：reference 类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置； returnAddress：指向了一条字节码指令的地址； StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度； OutOfMemoryError：如果虚拟机栈可以动态扩展但无法申请到足够的内存； 本地方法栈 虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法。 堆 heap Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此区域的唯一目的就是存放对象实例； GC 的主要区域，因此很多时候也被称为 GC 堆； 从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB） 从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代，在细致一点的有 Eden 空间，From Survivor 空间，To Survivor 空间等； 方法区 各个线程共享内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据； 运行时常量池：用于存放类加载后的各种字面量和符号引用； Class 文件常量池：存放类的版本，字段，方法，接口等描述信息； JDK8 与元数据在 JDK8 中， 永久代已经被移除，被一个称为「元数据区」（元空间）的区域所取代。 元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 nativememory, 字符串池和类的静态变量放入 Java 堆中， 这样可以加载多少类的元数据就不再由 MaxPermSize 控制, 而由系统的实际可用空间来控制。 Java 中堆和栈有什么区别JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。 堆 heapJava 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space）JVM 的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在 JVM 启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。 堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些 对象回收掉之前，他们会一直占据堆内存空间。 说一下堆内存中对象的分配的基本策略Eden 区、s0 区、s1 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区 -&gt; Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。另外，大对象和长期存活的对象会直接进入老年代。 栈 stack栈帧都有哪些数据？JVM 的运行是基于栈的，和 C 语言的栈类似，它的大多数数据都是在堆里面的，只有少部分运行时的数据存在于栈上。 在 JVM 中，每个线程栈里面的元素，就叫 栈帧。 栈帧包含：局部变量表、操作数栈、动态连接、返回地址、附加信息等。 什么情况下会发生栈内存溢出？栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型。如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常，方法递归调用产生这种结果。如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将抛出一个OutOfMemory 异常。(线程启动过多)。 方法区的作用方法区用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。 JDK8 之前使用永久代实现方法区，容易内存溢出，因为永久代有 -XX:MaxPermSize 上限，即使不设置也有默认大小。JDK7 把放在永久代的字符串常量池、静态变量等移出，JDK8 中永久代完全废弃，改用在本地内存中实现的元空间代替，把 JDK7 中永久代剩余内容（主要是类型信息）全部移到元空间。 虚拟机规范对方法区的约束宽松，除和堆一样不需要连续内存和可选择固定大小/可扩展外，还可以不实现垃圾回收。垃圾回收在方法区出现较少，主要目标针对常量池和类型卸载。如果方法区无法满足新的内存分配需求，将抛出 OutOfMemoryError。 运行时常量池的作用运行时常量池是方法区的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译器生成的各种字面量与符号引用，这部分内容在类加载后存放到运行时常量池。一般除了保存 Class 文件中描述的符号引用外，还会把符号引用翻译的直接引用也存储在运行时常量池。 运行时常量池相对于 Class 文件常量池的一个重要特征是动态性，Java 不要求常量只有编译期才能产生，运行期间也可以将新的常量放入池中，这种特性利用较多的是 String 的 intern 方法。 运行时常量池是方法区的一部分，受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError。 程序计数器程序计数器是一块较小的内存空间，可以看作当前线程所执行字节码的行号指示器。每条线程都要有一个独立的程序计数器，这类内存也称为「线程私有」的内存。字节码解释器工作时通过改变计数器的值选取下一条执行指令。分支、循环、跳转、线程恢复等功能都需要依赖计数器完成。 如果线程正在执行 Java 方法，计数器记录正在执行的虚拟机字节码指令地址（当前指令的地址）。如果是本地方法，计数器值为 Undefined。 这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。 JVM 新生代中为什么要分为 Eden 和 Survivor如果没有 Survivor，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发 Major GC。老年代的内存空间远大于新生代，进行一次 Full GC 消耗的时间比 Minor GC 长得多,所以需要分为 Eden 和 Survivor。Survivor 的存在意义，就是减少被送到老年代的对象，进而减少 Full GC 的发生，Survivor 的预筛选保证，只有经历 16 次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。设置两个 Survivor 区最大的好处就是解决了碎片化，刚刚新建的对象在 Eden 中，经历一次 Minor GC，Eden 中的存活对象就会被移动到第一块 survivor space S0，Eden 被清空；等 Eden 区再满了，就再触发一次 Minor GC，Eden 和 S0 中的存活对象又会被复制送入第二块 survivor space S1（这个过程非常重要，因为这种复制算法保证了 S1 中来自 S0 和 Eden 两部分的存活对象占用连续的内存空间，避免了碎片化的发生） JDK8 为什么要将永久代替换为元空间呢？整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会出现 java.lang.OutOfMemoryError。你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX:MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。 解释内存中的栈、堆和方法区的用法通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用 JVM 中的栈空间；而通过 new 关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为 Eden、Survivor（又可分为 From Survivor 和 To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT 编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的 100、”hello” 和常量都是放在常量池中，常量池是方法区的一部分。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发 StackOverflowError，而堆和常量池空间不足则会引发 OutOfMemoryError。 1String str = new String(&quot;hello&quot;); 上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而 “hello” 这个字面量是放在方法区的。 补充1： 较新版本的 Java（从 JDK6 的某个更新开始）中，由于 JIT 编译器的发展和「逃逸分析」技术的逐渐成熟，栈上分配、标量替换等优化技术使得对象一定分配在堆上这件事情已经变得不那么绝对了。 补充2： 运行时常量池相当于 Class 文件常量池具有动态性，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 intern() 方法就是这样的。 看看下面代码的执行结果是什么并且比较一下 JDK7 以前和以后的运行结果是否一致。 1234String s1 = new StringBuilder(&quot;go&quot;).append(&quot;od&quot;).toString();System.out.println(s1.intern() == s1);String s2 = new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString();System.out.println(s2.intern() == s2); 什么情况下会出现内存溢出，内存泄漏内存泄漏的原因很简单： 对象是可达的（一直被引用） 但是对象不会被使用 常见的内存泄漏例子： 12345678910111213141516 public static void main(String[] args) { Set&lt;Object&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { Object object = new Object(); set.add(object); // 设置为空，该对象不再使用 object = null; } // 但是set集合中还维护object的引用，gc不会回收object对象 System.out.println(set); System.out.println(set.size()); }} 输出结果 12345678910111213[java.lang.Object@74a14482, java.lang.Object@677327b6, java.lang.Object@6d6f6e28, java.lang.Object@4554617c, java.lang.Object@45ee12a7, java.lang.Object@1b6d3586, java.lang.Object@7f31245a,java.lang.Object@135fbaa4,java.lang.Object@1540e19d, java.lang.Object@14ae5a5]10Process finished with exit code 0 解决这个内存泄漏问题也很简单，将 set 设置为 null，那就可以避免上述内存泄漏问题了。其他内存泄漏得一步一步分析了。 内存溢出的原因： 内存泄露导致堆栈内存不断增大，从而引发内存溢出。 大量的 jar，class 文件加载，装载类的空间不够，溢出 操作大量的对象导致堆内存空间已经用满了，溢出 nio 直接操作内存，内存过大导致溢出 解决： 查看程序是否存在内存泄漏的问题 设置参数加大空间 代码中是否存在死循环或循环产生过多重复的对象实体、 查看是否使用了 nio 直接操作内存。 双亲委派机制♥JVM相关知识体系详解♥ | Java 全栈知识体系 (pdai.tech) 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器没有找到所需的类时，子加载器才会尝试去加载该类。 打破双亲委派机制的例子 JNDI 通过引入线程上下文类加载器，可以在 Thread.setContextClassLoader 方法设置，默认是应用程序类加载器，来加载 SPI 的代码。有了线程上下文类加载器，就可以完成父类加载器请求子类加载器完成类加载的行为。打破的原因，是为了 JNDI 服务的类加载器是启动器类加载，为了完成高级类加载器请求子类加载器（即上文中的线程上下文加载器）加载类。 Tomcat，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器，加载不了才委派给父加载器。打破的目的是为了完成应用间的类隔离。 OSGi，实现模块化热部署，为每个模块都自定义了类加载器，需要更换模块时，模块与类加载器一起更换。其类加载的过程中，有平级的类加载器加载行为。打破的原因是为了实现模块热替换。 JDK9，Extension ClassLoader 被 Platform ClassLoader 取代，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。打破的原因，是为了添加模块化的特性。 双亲委派模型 安全性：避免用户自己编写的类动态替换 Java 的核心类，比如 String.class； 避免类重复加载：因为 JVM 中区分不同的类不仅仅根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的类； 垃圾回收在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。 算法分代收集算法当前主流 VM 垃圾收集都采用「分代收集」(Generational Collection) 算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如 JVM 中的新生代、老年代、永久代， 这样就可以根据各年代特点分别采用最适当的 GC 算法 新生代与复制算法目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1:1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。 老年代与标记复制算法而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。 1、 JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)， 它用来存储 class 类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。 2、 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代。 3、 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后， EdenSpace 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 FromSpace 进行清理。 4、 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。 5、 在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。 6、 当对象在 Survivor 去躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被移到老生代中。 垃圾收集算法GC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。 标记 -清除算法 「标记-清除」（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。 复制算法 「复制」（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。 标记-压缩算法 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存 分代收集算法 「分代收集」（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法 JVM 年轻代到年老代的晋升过程的判断条件 部分对象会在 From 和 To 区域中复制来复制去,如此交换 15 次（由 JVM 参数 MaxTenuringThreshold 决定,这个参数默认是 15），最终如果还是存活,就存入到老年代。 如果对象的大小大于 Eden 的二分之一会直接分配在 old，如果 old 也分配不下，会做一次 majorGC，如果小于 Eden 的一半但是没有足够的空间，就进行 minorgc 也就是新生代 GC。 minorGC 后，survivor 仍然放不下，则放到老年代 动态年龄判断 ，大于等于某个年龄的对象超过了 survivor 空间一半 ，大于等于某个年龄的对象直接进入老年代 垃圾收集器新生代垃圾收集器Serial 收集器 特点： Serial 收集器只能使用一条线程进行垃圾收集工作，并且在进行垃圾收集的时候，所有的工作线程都需要停止工作，等待垃圾收集线程完成以后，其他线程才可以继续工作。 使用算法：复制算法 ParNew 收集器 特点： ParNew 垃圾收集器是Serial收集器的多线程版本。为了利用 CPU 多核多线程的优势，ParNew 收集器可以运行多个收集线程来进行垃圾收集工作。这样可以提高垃圾收集过程的效率。 使用算法：复制算法 Parallel Scavenge 收集器 特点： Parallel Scavenge 收集器是一款多线程的垃圾收集器，但是它又和 ParNew 有很大的不同点。 Parallel Scavenge 收集器和其他收集器的关注点不同。其他收集器，比如 ParNew 和 CMS 这些收集器，它们主要关注的是如何缩短垃圾收集的时间。而 Parallel Scavenge 收集器关注的是如何控制系统运行的吞吐量。这里说的吞吐量，指的是 CPU 用于运行应用程序的时间和 CPU 总时间的占比，吞吐量 = 代码运行时间 / （代码运行时间 + 垃圾收集时间）。如果虚拟机运行的总的 CPU 时间是 100 分钟，而用于执行垃圾收集的时间为 1 分钟，那么吞吐量就是 99%。 使用算法：复制算法 老年代垃圾收集器Serial Old 收集器 特点： Serial Old 收集器是 Serial 收集器的老年代版本。这款收集器主要用于客户端应用程序中作为老年代的垃圾收集器，也可以作为服务端应用程序的垃圾收集器。 使用算法：标记-整理 Parallel Old 收集器 特点： Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本这个收集器是在 JDK1.6 版本中出现的，所以在 JDK1.6 之前，新生代的 Parallel Scavenge 只能和 Serial Old 这款单线程的老年代收集器配合使用。Parallel Old 垃圾收集器和 Parallel Scavenge 收集器一样，也是一款关注吞吐量的垃圾收集器，和 Parallel Scavenge 收集器一起配合，可以实现对 Java 堆内存的吞吐量优先的垃圾收集策略。 使用算法：标记-整理 CMS 收集器 特点： CMS 收集器是目前老年代收集器中比较优秀的垃圾收集器。CMS 是 Concurrent Mark Sweep，从名字可以看出，这是一款使用”标记-清除”算法的并发收集器。 CMS 垃圾收集器是一款以获取最短停顿时间为目标的收集器。如下图所示： 从图中可以看出，CMS 收集器的工作过程可以分为 4 个阶段： 1、 初始标记（CMS initial mark）阶段 2、 并发标记（CMS concurrent mark）阶段 3、 重新标记（CMS remark）阶段 4、 并发清除(（CMS concurrent sweep）阶段 使用算法：复制+标记清除 其他 G1 垃圾收集器 特点： 主要步骤：初始标记，并发标记，重新标记，复制清除。 使用算法：复制 + 标记整理 你了解过哪些垃圾收集器年轻代 Serial 垃圾收集器（单线程，通常用在客户端应用上。因为客户端应用不会频繁创建很多对象，用户也不会感觉出明显的卡顿。相反，它使用的资源更少，也更轻量级。） ParNew 垃圾收集器（多线程，追求降低用户停顿时间，适合交互式应用。） Parallel Scavenge 垃圾收集器（追求 CPU 吞吐量，能够在较短时间内完成指定任务，适合没有交互的后台计算。） 老年代 Serial Old 垃圾收集器 Parallel Old垃圾收集器 CMS 垃圾收集器（以获取最短 GC 停顿时间为目标的收集器，它在垃圾收集时使得用户线程和 GC 线程能够并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。） Parallel Old 收集器（多线程标记整理算法）Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6才开始提供。 在 JDK6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量， Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器， 如果系统对吞吐量要求比较高，可以优先考虑新生代Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。 分布式垃圾回收（DGC）是如何工作的DGC 叫做分布式垃圾回收。RMI 使用 DGC 来做自动垃圾回收。因为 RMI 包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC 使用引用计数算法来给远程对象提供自动内存管理。 Serial 与 Parallel GC 的区别Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而parallel 收集器使用多个 GC 线程来执行。 GC 如何判断对象可以被回收 引用计数法（主流虚拟机未采用）：当对象被引用，计数器 +1，引用释放 -1，当计数器为 0 时表示可以释放； 缺陷：当 A B 互相引用时，A B 都不会被释放； 可达性分析法：从 GC Roots 开始向下搜索，搜索走过的路径称之为引用链，当一个对象到 GC Roots 没有任何链接时，证明此对象不可用，是可回收对象。 虚拟机栈（栈中的本地变量表）中引用的对象； 方法区中类静态属性引用的对象； 方法区中常量引用的对象； 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象； 可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会，在虚拟机自动建立的 Finalizer 队列中判断是否需要执行 finalizer() 方法，如未重写，则直接将其回收。当方法执行完成之后，GC 会再次对可达性进行判断。每个对象只能触发一次 finalizer() 方法。 JVM 中一次完整的 GC 流程是怎样的，对象如何晋升到老年代当 Eden 区的空间满了， Java 虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor 区。大对象（需要大量连续内存空间的 Java 对象，如那种很长的字符串）直接进入老年态；如果对象在 Eden 出生，并经过第一次 Minor GC 后仍然存活，并且被 Survivor 容纳的话，年龄设为 1，每熬过一次 Minor GC，年龄 +1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行 Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。Major GC 发生在老年代的 GC，清理老年区，经常会伴随至少一次 Minor GC，比 Minor GC 慢 10 倍以上。 Java 内存分配与回收策率以及 Minor GC 和 Major GC1、 对象优先在堆的 Eden 区分配 2、 大对象直接进入老年代 3、 长期存活的对象将直接进入老年代 当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC。Minor GC 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高，回收速度比较快；Full GC/Major GC 发生在老年代，一般情况下，触发老年代 GC 的时候不会触发 Minor GC，但是通过配置，可以在 Full GC 之前进行一次 Minor GC 这样可以加快老年代的回收速度。 简单描述一下（分代）垃圾回收的过程分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。 新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下： 当年轻代中的Eden区分配满的时候，就会触发年轻代的GC（Minor GC）。具体过程如下： 在Eden区执行了 第一次GC之后，存活的对象会被移动到其中一个Survivor分区（以下简称from） Eden区再次GC，这时会采用复制算法，将Eden和from区一起清理。存活的对象会被复制到to区。接下来，只需要清空from区就可以了 问与答你能保证 GC 执行吗不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC 的执行。 被引用的对象就一定能存活吗不一定，看 Reference 类型，弱引用在 GC 时会被回收，软引用在内存不足的时候，即 OOM 前会被回收，但如果没有在 Reference Chain 中的对象就一定会被回收。 如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存不会，在下一个垃圾回调周期中，这个对象将是被可回收的，也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。 JVM 出现 fullGC 很频繁，怎么去线上排查问题这题就依据 full GC 的触发条件来做： 如果有 perm gen 的话(JDK8 就没了)，要给 perm gen 分配空间，但没有足够的空间时，会触发 full gc； 所以看看是不是 perm gen 区的值设置得太小了； System.gc()方法的调用； 当统计得到的 Minor GC 晋升到旧生代的平均大小大于老年代的剩余空间，则会触发 full gc(这就可以从多个角度上看了)； 是不是频繁创建了大对象(也有可能eden区设置过小)(大对象直接分配在老年代中，导致老年代空间不足—&gt;从而频繁 gc)； 是不是老年代的空间设置过小了(Minor GC 几个对象就大于老年代的剩余空间了) 你有哪些手段来排查 OOM 的问题？ 增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录 同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域 使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用 生产上如何配置垃圾收集器的首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。通常，堆空间我会设置成操作系统的2/3（这是想给其他进程和操作系统预留一些时间），超过8GB的堆优先选用 G1。 接下来，我会对JVM进行初步优化。比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例。 再接下来，就是专项优化，主要判断的依据就是系统容量、访问延迟、吞吐量等。我们的服务是高并发的，所以对STW的时间非常敏感。 我会通过记录详细的GC日志，来找到这个瓶颈点，借用gceasy（重点）这样的日志分析工具，很容易定位到问题。之所以选择采用工具，是因为gc日志看起来实在是太麻烦了，gceasy号称是AI学习分析问题，可视化做的较好。 拓展JVM 参数参数查询官网地址。建议面试时最好能记住 CMS 和 G1 的参数，特点突出使用较多，被问的概率大。Java 8 为例： 日志 -XX:+PrintFlagsFinal：打印 JVM 所有参数的值 -XX:+PrintGC：打印 GC 信息 -XX:+PrintGCDetails：打印 GC 详细信息 -XX:+PrintGCTimeStamps：打印 GC 的时间戳 -Xloggc:filename：设置 GC log 文件的位置 -XX:+PrintTenuringDistribution：查看熬过收集后剩余对象的年龄分布信息 内存设置 -Xms：设置堆的初始化内存大小 -Xmx：设置堆的最大内存 -Xmn：设置新生代内存大小 -Xss：设置线程栈大小 -XX:NewRatio：新生代与老年代比值 -XX:SurvivorRatio：新生代中 Eden 区与两个 Survivor 区的比值，默认为 8，即Eden:Survivor:Survivor=8:1:1 -XX:MaxTenuringThreshold：从年轻代到老年代，最大晋升年龄。CMS 下默认为 6，G1 下默认为 15 -XX:MetaspaceSize：设置元空间的大小，第一次超过将触发 GC -XX:MaxMetaspaceSize：元空间最大值 -XX:MaxDirectMemorySize：用于设置直接内存的最大值，限制通过 DirectByteBuffer 申请的内存 -XX:ReservedCodeCacheSize：用于设置 JIT 编译后的代码存放区大小，如果观察到这个值有限制，可以适当调大，一般够用即可 设置垃圾收集相关 -XX:+UseSerialGC：设置串行收集器 -XX:+UseParallelGC：设置并行收集器 -XX:+UseConcMarkSweepGC：使用 CMS 收集器 -XX:ParallelGCThreads：设置 Parallel GC 的线程数 -XX:MaxGCPauseMillis：GC 最大暂停时间 ms -XX:+UseG1GC：使用 G1 垃圾收集器 CMS 垃圾回收器相关 -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction：与前者配合使用，指定MajorGC的发生时机 -XX:+ExplicitGCInvokesConcurrent：代码调用 System.gc() 开始并行 FullGC，建议加上这个参数 -XX:+CMSScavengeBeforeRemark：表示开启或关闭在 CMS 重新标记阶段之前的清除（YGC）尝试，它可以降低 remark 时间，建议加上 -XX:+ParallelRefProcEnabled：可以用来并行处理 Reference，以加快处理速度，缩短耗时 G1 垃圾回收器相关 -XX:MaxGCPauseMillis：用于设置目标停顿时间，G1 会尽力达成 -XX:G1HeapRegionSize：用于设置小堆区大小，建议保持默认 -XX:InitiatingHeapOccupancyPercent：表示当整个堆内存使用达到一定比例（默认是 45%），并发标记阶段就会被启动 -XX:ConcGCThreads：表示并发垃圾收集器使用的线程数量，默认值随 JVM 运行的平台不同而变动，不建议修改 JVM -XX:+UseCompressedOops：当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从 32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU 缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM 主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过 -XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。 重排序实际执行的指令步骤 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术（ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 这些重排序对于单线程没问题，但是多线程都可能会导致多线程程序出现内存可见性问题。 invokedynamic 指令是干什么的？属于比较高级的题目。没看过虚拟机的一般是不知道的。所以如果你不太熟悉，不要气馁。 invokedynamic 是 JDK7 之后新加入的字节码指令，使用它可以实现一些动态类型语言的功能。我们使用的 Lambda 表达式，在字节码上就是 invokedynamic 指令实现的。它的功能有点类似反射，但它是使用方法句柄实现的，执行效率更高。 资料JVM - 掘金 (juejin.cn)","link":"/548314b5b0e6/"},{"title":"基础方法","text":"Java 基础方法 指定日期转换12345678910111213import java.text.ParseException;import java.text.SimpleDateFormat;public class Work_06 { public static void main(String[] args) throws ParseException {// String old = &quot;2018-03-04&quot;;// Date oldDate = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(old);// String newStr = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;).format(oldDate);// System.out.println(newStr); System.out.println(new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;).format(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(&quot;2018-03-04&quot;))); }}// 使用SimpleDateFormat类,把2018-03-04转换为2018年03月04日 当前日期转换123456789101112import java.text.SimpleDateFormat;import java.util.Date;public class Work_05 { public static void main(String[] args) {// Date date = new Date();// SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);// System.out.println(sdf.format(date)); System.out.println(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date())); }}// 请用代码实现:获取当前的日期,并把这个日期转换为指定格式的字符串,如2088-08-08 08:08:08。 获取指定日期星期123456789101112131415import java.text.ParseException;import java.text.SimpleDateFormat;public class Work_07 { public static void main(String[] args) throws ParseException {// String strOld = &quot;2018年2月14日&quot;;// SimpleDateFormat sdfOld = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);// SimpleDateFormat sdfNew = new SimpleDateFormat(&quot;EEEE&quot;);// Date date = sdfOld.parse(strOld);// String strNew = sdfNew.format(date);// System.out.println(strNew); System.out.println(new SimpleDateFormat(&quot;EEEE&quot;).format(new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;).parse(&quot;2018年2月14日&quot;))); }}// 用程序判断2018年2月14日是星期几 arraycopy 的使用12345678910public class Work_08 { public static void main(String[] args) { char[] c = new char[]{'i', 't', 'c', 'a', 's', 'a'}; System.arraycopy(c, 1, c, 5, 1); System.out.println(c); }}//八、现有一个字符数组{'i','t','c','a','s','a'}，// 请使用System类中的arraycopy()方法在控制台输出“itcast”。// （提示：将[1]号数组元素复制到最后位置并覆盖原有元素。） 判断字符串是否对称123456789101112131415161718192021222324252627public class Work_10 { public static void main(String[] args) { StringBuilder strB = new StringBuilder(&quot;&quot;); String[] strArr = new String[]{&quot;010&quot;, &quot;3223&quot;, &quot;666&quot;, &quot;7890987&quot;, &quot;123123&quot;}; int count = 0; for (int i = 0; i &lt; strArr.length; i++) { strB.append(strArr[i]).reverse(); if (strArr[i].equals(strB.toString())) { System.out.println(strArr[i] + &quot; 是对称的&quot;); count++; } strB.delete(0, strB.length()); } System.out.println(count); }}//分析以下需求，并用代码实现：//// (1)定义数字字符串数组{&quot;010&quot;,&quot;3223&quot;,&quot;666&quot;,&quot;7890987&quot;,&quot;123123&quot;}；//// (2)判断该数字字符串数组中的数字字符串是否是对称(第一个数字和最后一个数字相等，第二个数字和倒数第二个数字是相等的，依次类推)的，并逐个输出；//// (3)如：010 是对称的，3223 是对称的，123123 不是对称的；//// (4)最终打印该数组中对称字符串的个数。////注：判断对称可用 *reverse(),*将此字符序列用其反转形式取代。 Int 数组转集合1234567891011121314151617181920212223import java.util.ArrayList;import java.util.Collection;public class Work_03 { public static void main(String[] args) { int[] intArr = new int[]{0, 1, 2, 3, 4}; Collection&lt;Integer&gt; list = transformIntArrayIntoCollection(intArr); ArrayList&lt;Integer&gt; listArr = (ArrayList) list; for (int i : list) { System.out.println(listArr.get(i)); } } public static Collection&lt;Integer&gt; transformIntArrayIntoCollection(int[] intArr) { Collection&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i : intArr) { list.add(i); } return list; }}//定义一个方法，要求此方法把 int 数组转成存有相同元素的集合// (集合里面的元素是Integer)，并返回 集合转数组1234567891011121314151617181920import java.util.ArrayList;import java.util.Collection;public class Work_04 { public static void main(String[] args) { Collection&lt;String&gt; collList = new ArrayList&lt;&gt;(); collList.add(&quot;0&quot;); collList.add(&quot;1&quot;); collList.add(&quot;2&quot;); collList.add(&quot;3&quot;); collList.add(&quot;4&quot;); collList.add(&quot;5&quot;); Object[] obj = collList.toArray(); for (int i = 0; i &lt; obj.length; i++) { System.out.println(obj[i]); } }}//四、定义一个集合，并把集合(集合里面的元素是Integer)转成存有相同元素的数组// 并将结果输出在控制台。（可以使用Object[]数组类型接收转换的数组） 泛型方法交换元素位置12345678910111213141516171819202122232425public class Work_11 { public static void main(String[] args) { Integer[] intArr = new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; exchangeLocation(intArr, 0, 1); String[] strArr = new String[]{&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;0&quot;}; exchangeLocation(strArr, 0, 1); Character[] charArr = new Character[]{'1', '2', '3', '4', '5', '6', '7', '8', '9', '0'}; exchangeLocation(charArr, 0, 1); } public static &lt;M&gt; void exchangeLocation(M[] m, int indexFront, int indexBack) { M temp = m[indexFront]; m[indexFront] = m[indexBack]; m[indexBack] = temp; for (int i = 0; i &lt; m.length; i++) { System.out.print(m[i] + &quot; &quot;); } }}//编写一个泛型方法，实现任意引用类型数组指定位置元素交换。 泛型方法反转数组元素123456789101112131415161718192021222324252627public class Work_12 { public static void main(String[] args) { Integer[] intArr = new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; intArr = reveral(intArr); String[] strArr = new String[]{&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;0&quot;}; strArr = reveral(strArr); Character[] charArr = new Character[]{'1', '2', '3', '4', '5', '6', '7', '8', '9', '0'}; charArr = reveral(charArr); } public static &lt;M&gt; M[] reveral(M[] m) { M temp; for (int i = 0; i &lt; m.length / 2; i++) { temp = m[i]; m[i] = m[m.length - i - 1]; m[m.length - i - 1] = temp; } for (int i = 0; i &lt; m.length; i++) { System.out.print(m[i] + &quot; &quot;); } return m; }}//编写一个泛型方法，接收一个任意引用类型的数组，并反转数组中的所有元素 LinkedList 基本方法12345678910111213141516171819202122232425262728293031323334import java.util.LinkedList;public class Work_05 { public static void main(String[] args) { LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;(); linked.add(&quot;1&quot;); linked.add(&quot;1&quot;); linked.add(&quot;1&quot;); linked.set(1, &quot;2&quot;); System.out.println(linked.get(1)); System.out.println(linked.remove(0)); linked.clear(); System.out.println(linked.size()); linked.addFirst(&quot;0&quot;); linked.addLast(&quot;9&quot;); System.out.println(linked.getFirst()); System.out.println(linked.getLast()); System.out.println(linked.removeFirst()); System.out.println(linked.removeLast()); linked.push(&quot;0&quot;); System.out.println(linked.pop()); }}/*根据要求练习LinkedList方法：（1）基本方法：add, set, get, remove, clear, size等方法；（2）特有方法：addFirst, addLast, getFirst, getLast, removeFirst,removeLast, push, pop, clear等方法。 */ 两种方法遍历 LinkedHashSet1234567891011121314151617181920212223import java.util.Collections;import java.util.Iterator;import java.util.LinkedHashSet;public class Work_08 { public static void main(String[] args) { LinkedHashSet&lt;String&gt; linked = new LinkedHashSet&lt;&gt;(); Collections.addAll(linked, &quot;王昭君&quot;, &quot;王昭君&quot;, &quot;西施&quot;, &quot;杨玉环&quot;, &quot;貂蝉&quot;); Iterator&lt;String&gt; it = linked.iterator(); while (it.hasNext()) { System.out.println(it.next()); } for (String s : linked) { System.out.println(s); } }}/*使用LinkedHashSet存储以下元素：&quot;王昭君&quot;,&quot;王昭君&quot;,&quot;西施&quot;,&quot;杨玉环&quot;,&quot;貂蝉&quot;。使用迭代器和增强for循环遍历LinkedHashSet。 */ 字符串去重1234567891011121314151617181920import java.util.LinkedHashSet;import java.util.Scanner;public class Work_11 { public static void main(String[] args) { LinkedHashSet&lt;Character&gt; linked = new LinkedHashSet&lt;&gt;(); char[] getCharArr = new Scanner(System.in).nextLine().toCharArray(); for (int i = 0; i &lt; getCharArr.length; i++) { linked.add(getCharArr[i]); } for (char s : linked) { System.out.print(s); } }}/*键盘录入一个字符串，去掉其中重复字符，打印出不同的那些字符，必须保证顺序。例如输入：aaaabbbcccddd，打印结果为：abcd。 */ 双色球123456789101112131415161718192021import java.util.LinkedHashSet;import java.util.Random;public class Work_12 { public static void main(String[] args) { Random r = new Random(); LinkedHashSet&lt;Integer&gt; linked = new LinkedHashSet(); while (linked.size() &lt; 6) { linked.add(r.nextInt(33) + 1); } for (int i : linked) { System.out.print(i + &quot; &quot;); } System.out.println(r.nextInt(16) + 1); }}/*双色球规则：双色球每注投注号码由6个红色球号码和1个蓝色球号码组成。红色球号码从1—33中选择；蓝色球号码从1—16中选择；请随机生成一注双色球号码。（要求同色号码不重复） */ 成绩排序Main： 1234567891011121314151617181920212223242526272829303132import java.util.ArrayList;import java.util.Collections;public class Main { public static void main(String[] args) { ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student(&quot;liusan&quot;, 20, 90.0F)); list.add(new Student(&quot;lisi&quot;, 22, 90.0F)); list.add(new Student(&quot;wangwu&quot;, 20, 99.0F)); list.add(new Student(&quot;sunliu&quot;, 22, 100.0F));// Collections.sort(list, new Comparator&lt;Student&gt;() {// @Override// public int compare(Student o1, Student o2) {// int big = 0;// if (o1.getScore() &gt; o2.getScore()) {// big = -1;// } else if (o1.getScore() &lt; o2.getScore()) {// big = 1;// } else {// return o2.getAge() - o1.getAge();// }// return big;// }// }); Collections.sort(list,new Student()); System.out.println(list); }}/*分别用Comparable和Comparator两个接口对下列四位同学的成绩做降序排序，如果成绩一样，那在成绩排序的基础上按照年龄由小到大排序。 */ Student： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.Comparator;public class Student implements Comparator&lt;Student&gt; { private String name; private int age; private float score; @Override public String toString() { return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + &quot;, score=&quot; + score + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public float getScore() { return score; } public void setScore(float score) { this.score = score; } public Student() { } public Student(String name, int age, float score) { this.name = name; this.age = age; this.score = score; } @Override public int compare(Student o1, Student o2) { int big = 0; if (o1.getScore() &gt; o2.getScore()) { big = -1; } else if (o1.getScore() &lt; o2.getScore()) { big = 1; } else { return o2.getAge() - o1.getAge(); } return big; }} 四种方法遍历 Map12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;public class Work_04 { public static void main(String[] args) { HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;一&quot;, 11); map.put(&quot;二&quot;, 22); map.put(&quot;三&quot;, 33); map.put(&quot;四&quot;, 44); map.put(&quot;五&quot;, 55); // 键找值 Set&lt;String&gt; set = map.keySet(); // 增强 for for (String s : set) { System.out.println(map.get(s)); } // Iterator Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) { System.out.println(map.get(it.next())); } // 键值对 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet(); // 增强 for for (Map.Entry entry : entries) { System.out.println(entry.getKey() + &quot; &quot; + entry.getValue()); } // Iterator Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it_1 = entries.iterator(); while (it_1.hasNext()) { Map.Entry&lt;String, Integer&gt; entry = it_1.next(); System.out.println(entry.getKey() + &quot; &quot; + entry.getValue()); } }}// 往一个 Map 集合中添加若干元素。// 获取 Map 中的所有 value，// 并使用增强 for 和迭代器遍历输出每个 value。//// tips: 参阅 Map 接口中 values()方法 统计字符出现次数1234567891011121314151617181920212223242526272829303132import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Set;public class Work_08 { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;abc&quot;); list.add(&quot;bcd&quot;); HashMap&lt;Character, Integer&gt; map = new HashMap(); for (String s : list) { for (char c : s.toCharArray()) { if (map.containsKey(c)) { map.put(c, map.get(c) + 1); } else { map.put(c, 1); } } } Set&lt;Character&gt; characters = map.keySet(); for (Character c : characters) { System.out.print(c + &quot; = &quot; + map.get(c) + &quot;,&quot;); } }}/*定义一个泛型为String类型的List集合，统计该集合中每个字符（注意，不是字符串）出现的次数。例如：集合中有”abc”、”bcd”两个元素，程序最终输出结果为：“a = 1,b = 2,c = 2,d = 1”。 */ Map 存储自定义元素并遍历Main： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;public class Main { public static void main(String[] args) { HashMap&lt;Car, Integer&gt; map = new HashMap&lt;&gt;(); map.put(new Car(&quot;宝马&quot;, &quot;黑色&quot;), 200000); map.put(new Car(&quot;奔驰&quot;, &quot;白色&quot;), 200000); map.put(new Car(&quot;奥迪&quot;, &quot;灰色&quot;), 200000); map.put(new Car(&quot;奥迪&quot;, &quot;灰色&quot;), 200000); // keySet: Set&lt;Car&gt; cars = map.keySet(); // 增强 for for (Car s : cars) { System.out.println(s.toString() + map.get(s)); } // Iterator Iterator&lt;Car&gt; it = cars.iterator(); while (it.hasNext()) { Car getCar = it.next(); System.out.println(getCar.toString() + map.get(getCar)); } // entrySet Set&lt;Map.Entry&lt;Car, Integer&gt;&gt; entries = map.entrySet(); // 增强 for for (Map.Entry&lt;Car, Integer&gt; entry : entries) { System.out.println(entry.getKey().toString() + entry.getValue()); } // Iterator Iterator&lt;Map.Entry&lt;Car, Integer&gt;&gt; it_1 = entries.iterator(); while (it_1.hasNext()) { Map.Entry&lt;Car, Integer&gt; carss = it_1.next(); System.out.println(carss.getKey().toString() + carss.getValue()); } }}//请使用Map集合存储自定义数据类型Car做键，// 对应的价格做值。// 并使用keySet和entrySet两种方式遍历Map集合。 Car： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Car { private String name; private String color; public Car() { } public String getName() { return name; } @Override public String toString() { return name + color; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Car car = (Car) o; if (name != null ? !name.equals(car.name) : car.name != null) return false; return color != null ? color.equals(car.color) : car.color == null; } @Override public int hashCode() { int result = name != null ? name.hashCode() : 0; result = 31 * result + (color != null ? color.hashCode() : 0); return result; } public void setName(String name) { this.name = name; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } public Car(String name, String color) { this.name = name; this.color = color; }} 自定义注册异常Main： 12345678910111213141516171819202122import java.util.ArrayList;import java.util.Collections;import java.util.Scanner;public class Main { static ArrayList&lt;String&gt; allUsername = new ArrayList&lt;&gt;(); static { Collections.addAll(allUsername, &quot;Tom&quot;, &quot;Bob&quot;, &quot;Lucy&quot;, &quot;Jack&quot;); } public static void main(String[] args) throws RegisterException { String getUserName = new Scanner(System.in).next(); checkName(getUserName); } public static void checkName(String receiveName) throws RegisterException { if (allUsername.contains(receiveName)) { throw new RegisterException(); } System.out.println(&quot;Success&quot;); }} RegisterException： 12345678public class RegisterException extends Exception{ public RegisterException() { } public RegisterException(String message) { super(message); }} 十个人过山洞Main： 12345678910111213141516171819public class Main { public static void main(String[] args) { CrossHole crossHole = new CrossHole(); String[] name = new String[]{&quot;Bob&quot;, &quot;Lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;, &quot;Anna&quot;, &quot;Brace&quot;, &quot;Tim&quot;, &quot;Oasis&quot;, &quot;Linda&quot;, &quot;Cindy&quot;}; for (int i = 0; i &lt; name.length; i++) { new Thread(crossHole,name[i]).start(); } }}/* 1.这个山洞每次只能通过一个人，每个人通过山洞的时间为5秒；2.随机生成10个人，同时准备过此山洞， 并且定义一个变量用于记录通过隧道的人数。 显示每次通过山洞人的姓名，和通过顺序； */ CrossHole： 1234567891011121314151617public class CrossHole implements Runnable { Integer crossIndex = 1; Object obj = new Object(); @Override public void run() { synchronized (obj) { System.out.println(Thread.currentThread().getName() + &quot; 正在过山洞，TA 是第 &quot; + crossIndex++ + &quot; 个过山洞的人。&quot;); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } }} 包子店Main： 1234567public class Main { public static void main(String[] args) { Bun b = new Bun(); new Make(b).start(); new Eat(b).start(); }} Make： 12345678910111213141516171819202122public class Make extends Thread { private Bun b; public Make(Bun bun) { this.b = bun; } @Override public void run() { while (true) { synchronized (b) { if (b.haveBun == true) { try { b.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;包子铺正在生产包子...&quot;); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;包子铺生产了包子。&quot;); b.haveBun = true; b.notify(); } } }} Bun： 1234public class Bun {// String filling; boolean haveBun = false;} Eat： 123456789101112131415161718192021222324public class Eat extends Thread{ private Bun b; public Eat(Bun b) { this.b = b; } @Override public void run() { while (true){ synchronized (b){ if(b.haveBun==false){ try { b.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;正在吃包子&quot;); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } b.haveBun=false; System.out.println(&quot;吃完了。&quot;); b.notify(); System.out.println(&quot;==============================================&quot;); } } }} Lambda 计算器Main： 12345678910111213141516171819public class Main { public static void main(String[] args) { // 请分别使用Lambda【标准格式】及【省略格式】调用invokeCalc方法来计算130-120的结果ß invokeCalc(130, 120, (int a, int b) -&gt; { return a - b; }); invokeCalc(130, 120, (a, b) -&gt; a - b); } private static void invokeCalc(int a, int b, Calculator calculator) { int result = calculator.calc(a, b); System.out.println(&quot;结果是：&quot; + result); }}/*给定一个计算器 Calculator 接口，内含抽象方法 calc (减法)，其功能是可以将两个数字进行相减，并返回差值。使用Lambda表达式在Test中完成调用。请分别使用Lambda的标准格式及省略格式调用 invokeCalc 方法 */ Calculator： 123public interface Calculator { int calc(int a, int b);} 计算文件夹大小12345678910111213141516171819202122232425262728import java.io.File;import java.util.Scanner;/** * @Author:hr947x * @Date:2018-12-14 20:12 * @version:1.0 */public class Work_14_GetDirectorySize { public static void main(String[] args) { System.out.println(getSize(new File(new Scanner(System.in).nextLine()))); } public static Long getSize(File file) { Long allSize = 0L; for (File fileFor : file.listFiles()) { if (fileFor.isFile()) { allSize += fileFor.length(); } else { allSize += getSize(fileFor); } } return allSize; }}/*从键盘接收一个文件夹路径,获得该文件夹大小并输出到控制台 */ 不死神兔12345678910111213141516171819202122232425262728/** * @Author:hr947x * @Date:2018-12-14 19:57 * @version:1.0 */public class Work_10 { private static int count = 0; public static void main(String[] args) { System.out.println(getRabbit(24) * 2); } public static int getRabbit(int months) { if (months == 1 || months == 2) { return 1; } else { // 如果是第3个月就返回前两个月的值 return getRabbit(months - 1) + getRabbit(months - 2); } }}/*用递归实现不死神兔故事得从西元1202年说起，话说有一位意大利青年，名叫斐波那契。在他的一部著作中提出了一个有趣的问题：假设一对刚出生的小兔一个月后就能长成大兔，再过一个月就能生下一对小兔，并且此后每个月都生一对小兔，没有发生死亡，问：现有一对刚出生的兔子2年后(24个月)会有多少对兔子? */ 删除所有文件123456789101112131415161718192021222324252627import java.io.File;import java.util.Scanner;/** * @Author:hr947x * @Date:2018-12-14 20:11 * @version:1.0 */public class Work_13_DeleteAllFiles { public static void main(String[] args) { deleteALlFiles(new File(new Scanner(System.in).nextLine())); } public static void deleteALlFiles(File f) { if(f.isDirectory()){ for (File file : f.listFiles()) { deleteALlFiles(file); } } f.delete(); }}/*键盘录入一个文件夹路径，删除该文件夹以及文件夹路径下的所有文件。要求：录入的文件夹里面要有多个文件，不能包含有子文件夹。提示：如果文件夹里面有文件，则需要先将文件删除才能删除文件夹。 */ 获取指定文件夹中指定格式文件1234567891011121314151617181920212223242526import java.io.File;/** * @Author:hr947x * @Date:2018-12-15 14:36 * @version:1.0 */public class GetAllFiles { public static void main(String[] args) { printALlFiles(new File(&quot;D:\\\\&quot;)); } public static void printALlFiles(File f) { File[] allFiles = f.listFiles(pathname -&gt; pathname.getName().endsWith(&quot;.java&quot;) || pathname.isDirectory()); if (allFiles != null) { for (File getFiles : allFiles) { if (getFiles.isFile()) { System.out.println(getFiles); } else { printALlFiles(getFiles); } } } }} 字节流读取文件123456789101112131415161718192021222324import java.io.FileInputStream;import java.io.IOException;/** * @Author:hr947x * @Date:2018-12-16 18:37 * @version:1.0 */public class Work_05 { public static void main(String[] args) throws IOException { FileInputStream fis = new FileInputStream(&quot;D:\\\\a.txt&quot;); int len = -1; byte[] bytes = new byte[1024]; while ((len = fis.read(bytes)) != -1) { System.out.println(new String(bytes, 0, len)); } fis.close(); }}/*利用字节输入流读取D盘文件b.txt的内容，文件内容确定都为纯ASCII字符,使用循环读取，一次读取一个字节数组，直到读取到文件末尾，将读取到的字节数组转换成字符串输出到控制台。 */ 缓冲流复制文件123456789101112131415161718192021222324252627import java.io.*;/** * @Author:hr947x * @Date:12/17/2018 10:54 AM * @version:1.0 */public class Work_03 { public static void main(String[] args) throws IOException { BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;D:\\\\1.jpg&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;D:\\\\2.jpg&quot;)); int len = -1; byte[] bytes = new byte[1024]; while ((len = bis.read(bytes)) != -1) { bos.write(bytes, 0, len); } bos.close(); bis.close(); }}/*利用高效字节输入流和高效字节输出流完成文件的复制。要求：1.将C盘下的c.png文件复制到D盘下2.一次读写一个字节数组方式复制 */ 转换流输出123456789101112131415161718192021222324import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;/** * @Author:hr947x * @Date:12/17/2018 10:54 AM * @version:1.0 */public class Work_05 { public static void main(String[] args) throws IOException { OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;D:\\\\a.txt&quot;), &quot;GBK&quot;); osw.write(&quot;我爱 Java&quot;); osw.close(); }}/*现有一字符串：”我爱Java”。将该字符串保存到当前项目根目录下的a.txt文件中。要求：使用gbk编码保存。注意：idea的默认编码是utf-8,所以可以通过filesettingsfile encodings设置为gbk格式，否则打开a.txt文件看到的将会是乱码。 */ 转换流读取12345678910111213141516171819202122232425import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;/** * @Author:hr947x * @Date:12/17/2018 10:54 AM * @version:1.0 */public class Work_06 { public static void main(String[] args) throws IOException { InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;D:\\\\a.txt&quot;), &quot;GBK&quot;); int len = -1; char[] chars = new char[1024]; while ((len = isr.read(chars)) != -1) { System.out.print(new String(chars, 0, len)); } isr.close(); }}/*利用转换输入流将当前项目根目录下使用gbk编码的a.txt文件的内容读取出来，并打印在控制台上。要求：不能出现乱码的情况。 */ 序列化流12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.io.*;/** * @Author:hr947x * @Date:12/17/2018 10:54 AM * @version:1.0 */public class Work_07_And_08 { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;D:\\\\a.txt&quot;)); oos.writeObject(new Student(&quot;Oasis&quot;,22,&quot;Boy&quot;)); oos.close(); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;D:\\\\a.txt&quot;)); Student s = (Student) ois.readObject(); System.out.println(s); ois.close(); } public static class Student implements Serializable{ private static final long serialVersionUID = 0L; private String name; private Integer age; private String gender; @Override public String toString() { return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + &quot;, gender='&quot; + gender + '\\'' + '}'; } public Student(String name, Integer age, String gender) { this.name = name; this.age = age; this.gender = gender; } }}/*定义一个学生类，包含姓名，年龄，性别等成员变量，提供setters和getters方法以及构造方法。在测试类中创建一个学生对象，给学生对象的三个成员变量赋值。然后将该对象保存到当前项目根目录下的stu.txt文件中。 */ 多线程上传文件Client： 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;import java.net.Socket;/** * @Author:hr947x * @Date:2018/12/19 19:19 * @version:1.0 */public class Client_09 { public static void main(String[] args) throws IOException { File file = new File(&quot;D:\\\\1.jpg&quot;); if (!file.exists() || file.length() &gt;= 2048 * 1024) { System.out.println(&quot;文件过大或者不存在！&quot;); return; } BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); Socket s = new Socket(&quot;127.0.0.1&quot;, 13579); OutputStream os = s.getOutputStream(); InputStream is = s.getInputStream(); int len = -1; byte[] bytes = new byte[1024]; while ((len = bis.read(bytes)) != -1) { os.write(bytes, 0, len); } s.shutdownOutput(); len = is.read(bytes); System.out.println(new String(bytes, 0, len)); is.close(); os.close(); bis.close(); s.close(); }}/*客户端需求：把一个图片文件发送到服务端并读取回馈信息。要求判断文件是否存在及格式是否为jpg并要求文件小于2M。 */ Server： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.*;import java.net.ServerSocket;import java.net.Socket;import java.util.Random;/** * @Author:hr947x * @Date:2018/12/19 19:18 * @version:1.0 */public class Server_09 { public static void main(String[] args) throws IOException { while (true) { ServerSocket ss = new ServerSocket(13579); Socket s = ss.accept(); new Thread(() -&gt; { try { BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;D:\\\\Get_&quot; + (new Random().nextInt(99999) + 9999) + &quot;.jpg&quot;)); InputStream is = s.getInputStream(); OutputStream os = s.getOutputStream(); int len = -1; byte[] bytes = new byte[1024]; while ((len = is.read(bytes)) != -1) { bos.write(bytes, 0, len); } os.write(&quot;Done.&quot;.getBytes()); os.close(); is.close(); bos.close(); } catch (IOException e) { e.printStackTrace(); } }).start(); } }}/*服务端需求：接收客户端发送过来的图片数据。进行存储后，回馈一个“上传成功”字样。支持多用户的并发访问。 */ 函数式接口计算器Main： 1234567891011121314151617181920212223/** * @Author:hr947x * @Date:2018/12/20 16:35 * @version:1.0 */public class Main { static void getProduct(int a, int b, IntCalc ic) { System.out.println(ic.calc(a, b)); } public static void main(String[] args) { getProduct(12, 12, (a, b) -&gt; a * b); }}/*1. 定义一个函数式接口IntCalc, 其中抽象方法int calc(int a , int b)， 使用注解@FunctionalInterface2. 在测试类中定义 static void getProduct(int a , int b ,IntCalc calc), 该方法的预期行为是使用calc得到a和b的乘积并打印结果3. 测试getProduct(),通过lambda表达式完成需求 */ IntCalc： 12345678910/** * @Author:hr947x * @Date:2018/12/20 16:36 * @version:1.0 */@FunctionalInterfacepublic interface IntCalc { int calc(int a, int b);} 函数式接口例子Main： 1234567891011121314151617181920212223/** * @Author:hr947x * @Date:2018/12/20 19:33 * @version:1.0 */public class Main { static void getIntegerArray(int length, ArrayBuilder&lt;Integer&gt; builder) { System.out.println(builder.buildArray(length)); } public static void main(String[] args) { getIntegerArray(10, (i) -&gt; new Integer[i]); }}/*1. 定义一个函数式接口ArrayBuilder&lt;T&gt;, 提供带泛型的抽象方法T[] buildArray(int length)， 使用注解@FunctionalInterface2. 在测试类中定义static void getIntegerArray(int length , ArrayBuilder&lt;Integer&gt; builder), 该方法的预期行为是使用builder创建一个长度为length的Integer数组并打印其内存地址3. 测试getIntegerArray (),使用方法引用完成需求 */ ArrayBuilder： 12345678910/** * @Author:hr947x * @Date:2018/12/20 19:34 * @version:1.0 */@FunctionalInterfacepublic interface ArrayBuilder&lt;T&gt; { T[] buildArray(int length);} Consumer 示例1234567891011121314151617181920212223242526272829import java.util.function.Consumer;/** * @Author:hr947x * @Date:2018/12/20 20:56 * @version:1.0 */public class Work_003 { public static void main(String[] args) { String[] arr = {&quot;谢霆锋,男&quot;, &quot;林志玲,女&quot;, &quot;吴彦祖,男&quot;, &quot;周哲,男&quot;, &quot;金城武,男&quot;}; print_(arr, str -&gt; System.out.println(&quot;姓名：&quot; + str.split(&quot;,&quot;)[0]), str -&gt; System.out.println(&quot;性别：&quot; + str.split(&quot;,&quot;)[1])); } private static void print_(String[] s, Consumer&lt;String&gt; c1, Consumer&lt;String&gt; c2) { for (String str : s) { c1.andThen(c2).accept(str); } }}/* 1，字符串数组当中存有多条信息，请按照格式“姓名：XX。性别：XX。”的格式将信息打印出来。 2，要求将打印姓名的动作作为第一个Consumer接口的Lambda实例， 3，将打印性别的动作作为第二个Consumer接口的Lambda实例， 4，将两个Consumer接口按照顺序“拼接”到一起 5，String[] arr = { &quot;谢霆锋,男&quot;, &quot;林志玲,女&quot;, &quot;吴彦祖,男&quot; , &quot;周哲,男&quot;,&quot;金城武,男&quot;}; */ Predicate 示例12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;import java.util.function.Predicate;/** * @Author:hr947x * @Date:2018/12/21 9:19 * @version:1.0 */public class Work_004 { public static void main(String[] args) { String[] array = {&quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot;}; ArrayList&lt;String&gt; list = getList(array, str -&gt; str.split(&quot;,&quot;)[1].equals(&quot;女&quot;), str -&gt; str.split(&quot;,&quot;)[0].length() == 4); System.out.println(list); } public static ArrayList&lt;String&gt; getList(String[] strArr, Predicate&lt;String&gt; p1, Predicate&lt;String&gt; p2) { ArrayList&lt;String&gt; newList = new ArrayList&lt;&gt;(); for (String s : strArr) if (p1.and(p2).test(s)) newList.add(s); return newList; }}/*集合信息筛选1，String[] array = { &quot;迪丽热巴,女&quot;, &quot;古力娜扎,女&quot;, &quot;马尔扎哈,男&quot;, &quot;赵丽颖,女&quot; };,2，请通过Predicate接口的拼装将符合要求的字符串筛选到集合ArrayList中，需要同时满足两个条件： 1. 必须为女生； 2. 姓名为4个字。分析: 1.有两个判断条件,所以需要使用两个Predicate接口,对条件进行判断 2.必须同时满足两个条件,所以可以使用and方法连接两个判断条件 */ Function 示例1234567891011121314151617181920212223242526272829import java.util.function.Function;/** * @Author:hr947x * @Date:2018/12/21 9:29 * @version:1.0 */public class Work_005 { public static void main(String[] args) { String str = &quot;花美男,20&quot;; System.out.println(change(str, s -&gt; s.split(&quot;,&quot;)[1], s -&gt; Integer.parseInt(s), i -&gt; i + 100)); } public static int change(String str, Function&lt;String, String&gt; f1, Function&lt;String, Integer&gt; f2, Function&lt;Integer, Integer&gt; f3) { return f1.andThen(f2).andThen(f3).apply(str); }}/*请使用Function进行函数模型的拼接，按照顺序需要执行的多个函数操作为： String str = &quot;花美男,20&quot;;分析:1. 将字符串截取数字年龄部分，得到字符串； Function&lt;String,String&gt; &quot;花美男,20&quot;-&gt;&quot;20&quot;2. 将上一步的字符串转换成为int类型的数字； Function&lt;String,Integer&gt; &quot;20&quot;-&gt;203. 将上一步的int数字累加100，得到结果int数字。 Function&lt;Integer,Integer&gt; 20-&gt;120 */ Stream 流示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.function.Predicate;import java.util.stream.Stream;/** * @Author:hr947x * @Date:2018/12/22 16:46 * @version:1.0 */public class Work_01 { public static void main(String[] args) { Integer[] arr = {-12345, 9999, 520, 0, -38, -7758520, 941213}; Predicate&lt;Integer&gt; p1 = n -&gt; n &gt;= 0; Predicate&lt;Integer&gt; p2 = n -&gt; Math.abs(n) &gt; 100; Predicate&lt;Integer&gt; p3 = n -&gt; n % 2 == 0; Stream&lt;Integer&gt; arrStream = Stream.of(arr); int positiveNum = 0; // 自然数 int minusNum = 0; // 负整数 int evenNumBig100 = 0; // 绝对值大于100的偶数 int minusNumOrEvenNum = 0; // 负整数或者偶数 for (Integer i : arr) { if (p1.test(i)) { positiveNum++; } if (p2.and(p3).test(i)) { evenNumBig100++; } if (p3.or(p1.negate()).test(i)) { minusNumOrEvenNum++; } } minusNum = (int) (arrStream.count() - positiveNum); System.out.println(&quot;自然数：&quot; + positiveNum); System.out.println(&quot;负整数：&quot; + minusNum); System.out.println(&quot;绝对值大于100的偶数：&quot; + evenNumBig100); System.out.println(&quot;负整数或者偶数：&quot; + minusNumOrEvenNum); }}/*1. 请在测试类main方法中完成以下需求已知有Integer[] arr = {-12345, 9999, 520, 0,-38,-7758520,941213}a) 使用lambda表达式创建Predicate对象p1,p1能判断整数是否是自然数(大于等于0)b) 使用lambda表达式创建Predicate对象p2,p2能判断整数的绝对值是否大于100c) 使用lambda表达式创建Predicate对象p3,p3能判断整数是否是偶数 遍历arr，仅利用已创建的Predicate对象(不使用任何逻辑运算符)，完成以下需求i. 打印自然数的个数ii. 打印负整数的个数iii. 打印绝对值大于100的偶数的个数iv. 打印是负整数或偶数的数的个数 */ Annotation 示例Main： 12345678910111213141516171819202122232425262728293031/** * @Author:hr947x * @Date:2018/12/23 20:37 * @version:1.0 */public class Main { @Check public void arrays(){ int[] i = new int[1]; System.out.println(i[2]); } @Check public void add() { System.out.println(&quot;9 + 0 = &quot; + (9 + 0)); } @Check public void sub() { System.out.println(&quot;9 - 0 = &quot; + (9 - 0)); } @Check public void mul() { System.out.println(&quot;9 * 0 = &quot; + (9 * 0)); } @Check public void div() { System.out.println(&quot;9 / 0 = &quot; + (9 / 0)); } public void done() { System.out.println(&quot;No bugs!&quot;); }} CheckTest： 1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedWriter;import java.io.FileWriter;import java.lang.reflect.Method;/** * @Author:hr947x * @Date:2018/12/23 20:43 * @version:1.0 */public class CheckTest { public static void main(String[] args) throws Exception { Main m = new Main(); Class cls = m.getClass(); Method[] ms = cls.getMethods(); int count = 0; BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;D:\\\\a.txt&quot;)); for (Method method : ms) { if (method.isAnnotationPresent(Check.class)) { try { method.invoke(m); } catch (Exception e) { count++; bw.write(method.getName() + &quot; 出现了异常。&quot;); bw.newLine(); bw.write(&quot;异常的名称：&quot; + e.getCause().getClass().getSimpleName()); bw.newLine(); bw.write(&quot;异常的原因：&quot; + e.getCause().getMessage()); bw.newLine(); bw.write(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;); bw.newLine(); } } } bw.write(&quot;一共出现了：&quot; + count + &quot; 次异常！&quot;); bw.flush(); bw.close(); }} Check： 123456789101112131415import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * @Author:hr947x * @Date:2018/12/23 20:37 * @version:1.0 */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Check {} Junit 单元测试addTest： 123456789101112131415161718192021222324252627282930313233import _14.JunitTest.Calc;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;/** * @Author:hr947x * @Date:2018/12/23 15:48 * @version:1.0 */public class addTest { @Before public void init() { System.out.println(&quot;Start...&quot;); } @Test public void testadd() { Calc a = new Calc(); int result = a.add(1, 2); Assert.assertEquals(2, result); } @After public void close() { System.out.println(&quot;Done...&quot;); } public static void main(String[] args) { }} Calc： 12345678910/** * @Author:hr947x * @Date:2018/12/23 15:48 * @version:1.0 */public class Calc { public int add(int a, int b) { return a * b; }} 反射Test： 1234567891011121314151617181920212223242526272829import java.io.InputStream;import java.lang.reflect.Method;import java.util.Properties;/** * @Author:hr947x * @Date:2018/12/23 11:50 * @version:1.0 */public class Test { public static void main(String[] args) throws Exception { // 类加载器获取文件路径： ClassLoader cl = Test.class.getClassLoader(); InputStream ras = cl.getResourceAsStream(&quot;setting.properties&quot;); Properties p = new Properties(); p.load(ras); String cn = p.getProperty(&quot;className&quot;); String mn = p.getProperty(&quot;methodName&quot;); // 加载该类的内容 Class cls = Class.forName(cn); Object o = cls.newInstance(); Method m = cls.getMethod(mn); m.invoke(o); }} Car： 12345678910111213/** * @Author:hr947x * @Date:2018/12/23 14:57 * @version:1.0 */public class Car { public String name; private int price; public void run() { System.out.println(&quot;Go!Go!Go!&quot;); }} 多线程麻将发牌12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.ArrayList;import java.util.Collections;import java.util.LinkedHashMap;import java.util.Random;/** * @Author:hr947x * @Date:2018/12/21 14:11 * @version:1.0 */public class GetMajong_Map_Thread { private static LinkedHashMap&lt;Integer, String&gt; ALL_MAHJONG_MAP = new LinkedHashMap&lt;&gt;(); private static ArrayList&lt;Integer&gt; index = new ArrayList&lt;&gt;(); public static void main(String[] args) { String[] colorOfMahjong = new String[]{&quot;筒&quot;, &quot;条&quot;, &quot;万&quot;}; String[] numberOfMahjong = new String[]{&quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot;}; int count = 0; for (String s : numberOfMahjong) { for (String ss : colorOfMahjong) { for (int i = 0; i &lt; 4; i++) { index.add(count); ALL_MAHJONG_MAP.put(count++, s + ss); } } } new Thread(new GetMahjong(), &quot;Oasis&quot;).start(); new Thread(new GetMahjong(), &quot;Anna&quot;).start(); new Thread(new GetMahjong(), &quot;Bob&quot;).start(); new Thread(new GetMahjong(), &quot;Tom&quot;).start(); } public synchronized static void printHaveMahjong(ArrayList&lt;Integer&gt; getMahjong) { Collections.sort(getMahjong); System.out.print(Thread.currentThread().getName() + &quot; 有 &quot; + getMahjong.size() + &quot; 牌：&quot;); for (int i = 0; i &lt; getMahjong.size(); i++) { System.out.print(ALL_MAHJONG_MAP.get(getMahjong.get(i)) + &quot; &quot;); } System.out.println(); } public static class GetMahjong implements Runnable { @Override public void run() { ArrayList&lt;Integer&gt; getMahjong = new ArrayList&lt;&gt;(); Random r = new Random(); int indexDel, randomGetMahjong; while (true/*|| getMahjong.size() &lt;= 27*/) { try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (ALL_MAHJONG_MAP) { if (index.size() == 0 /*|| getMahjong.size() == 27*/) { break; } indexDel = r.nextInt(index.size()); randomGetMahjong = index.get(indexDel); System.out.println(Thread.currentThread().getName() + &quot;拿到了 &quot; + randomGetMahjong + &quot; 号麻将：&quot; + ALL_MAHJONG_MAP.get(randomGetMahjong) + &quot;。剩余 &quot; + index.size() + &quot; 张&quot;); getMahjong.add(randomGetMahjong); index.remove(indexDel); } } printHaveMahjong(getMahjong); } }}/*一副麻将使用四个线程进行「发」牌 */ 日期百分比123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;/** * @Author:hr947x * @Date:2018/12/21 10:08 * @version:1.0 */public class PercentOfThisYear_Date { private static String TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;; // 全局时间格式 public static void main(String[] args) throws ParseException { // 获取今年是哪年 int nowYear = Calendar.getInstance().get(Calendar.YEAR); // 获取今年一共有多少毫秒 Long nowYearSecond = getSecondOfYear(nowYear); // 获取当前时间的毫秒值 Long nowTimeSecond = getSecondOfNow(getNowTime(), nowYear); // 将毫秒值进行转型 double nowYearSecondDou = (double) nowYearSecond; double nowTimeSecondDou = (double) nowTimeSecond; System.out.println(&quot;今年仅剩：&quot; + (nowYearSecondDou - nowTimeSecondDou) / nowYearSecondDou * 100 + &quot;%&quot;); } private static Long getSecondOfNow(String nowTime, int nowYear) throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat(TIME_FORMAT); Long nowTimeSecond = sdf.parse(nowTime).getTime(); Long nowYearSecond = sdf.parse(nowYear + &quot;-1-1 00:00:00&quot;).getTime(); return nowTimeSecond - nowYearSecond; } private static Long getSecondOfYear(int year) throws ParseException { // 获取某年总共有多少毫秒 SimpleDateFormat sdf = new SimpleDateFormat(TIME_FORMAT); String beginYear = year + &quot;-1-1 00:00:00&quot;; String endYear = (++year) + &quot;-1-1 00:00:00&quot;; Long beginYearSecond = sdf.parse(beginYear).getTime(); Long endYearSecond = sdf.parse(endYear).getTime(); return endYearSecond - beginYearSecond; } private static String getNowTime() { // 获取当前时间 Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(TIME_FORMAT); return sdf.format(date); }}/*计算当前时间是今年总时间的百分比1.使用 Calender 获取当前年份2.获取年初、年底的时间毫秒值与毫秒差值3.获取当前时间毫秒值4.for 循环持续输出已消耗的百分比（double） */","link":"/5d893ccff440/"},{"title":"基础代码","text":"Java 基础代码 判断语句switch123456789101112switch (表达式) {case 常量值 1: // 语句体 1; break;case 常量值 2: // 语句体 2; break;... default: // 语句体 n + 1; break;} Scanner包：java.util.Scanner 使用方法： 1234Scanner sc = new Scanner(System.in);int i = sc.nextInt(); // 接收一个数字String s = sc.next(); // 接收一个字符串String ss = sc.nextLine(); // 接收一行 Random包：java.util.Random 使用方法： 123Random r = new Random();int i = r.nextInt(10); // 随机生成 0 - 9 中的数字int j = r.nextInt(10) + 1; // 随机生成 1 - 10 的数字 String构造方法public String()：初始化新创建的 String对象，以使其表示空字符序列。 public String(char[] value) ：通过当前参数中的字符数组来构造新的String。 public String(byte[] bytes) ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的 String。 12345678// 无参构造String str_1 = new String();// 通过字符串构造char[] chars = {'a','b','c'};String str_2 = new String(chars);// 通过字节数组构造byte[] bytes = {1, 2, 3};String str_3 = new String(bytes); 常用方法public boolean equals (Object anObject) ：将此字符串与指定对象进行比较。 public boolean equalsIgnoreCase (String anotherString) ：将此字符串与指定对象进行比较，忽略大小写。 public int length () ：返回此字符串的长度。 public String concat (String str) ：将指定的字符串连接到该字符串的末尾。 public char charAt (int index) ：返回指定索引处的 char 值。 public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。 public String substring (int beginIndex) ：返回一个子字符串，从 beginIndex 开始截取字符串到字符 串结尾。 public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从 beginIndex 到 endIndex 截取字符串。含 beginIndex，不含 endIndex。 public char[] toCharArray () ：将此字符串转换为新的字符数组。 public byte[] getBytes () ：使用平台的默认字符集将该 String 编码转换为新的字节数组。 public String replace (CharSequence target, CharSequence replacement) ：将与 target 匹配的字符串使 用 replacement 字符串替换。 public String[] split(String regex)：将此字符串按照给定的 regex（规则）拆分为字符串数组。 public boolean isEmpty()：判断字符串是否为空； 方法示例12345678910111213141516171819202122232425262728293031String str_1 = &quot;AaBb789&quot;;String str_2 = &quot;aabb789&quot;;// 比较两字符串内容是否相同：falseboolean b_1 = str_1.equals(str_2);// 比较时忽略大小写：trueboolean b_2 = str_1.equalsIgnoreCase(str_2);// 返回字符串长度：7int i = str_1.length();// 返回两字符串相加的结果：AaBb789aabb789String getStr_1 = str_1.concat(str_2);// 返回指定索引的 char 值：bchar getChar = str_1.charAt(3);// 返回子字符串第一次在字符串中出现的索引：3// 未出现则返回 -1int j = str_1.indexOf(&quot;b71&quot;);// 返回从索引直至末尾的字符串：Bb789String getStr_2 = str_1.substring(2);// 返回两索引值之间的字符串：aBbString getStr_3 = str_1.substring(1, 4);// 将字符串转换成 char[] 数组：char[] getCharArr = str_1.toCharArray();// 将字符串转换成 byte[] 数组：byte[] getBytesArr = str_1.getBytes();// 将字符串中指定 字符 进行全部替换：Aacb789String getStr_4 = str_1.replace('B','c');// 将字符串中指定 字符串 进行全部替换：AaCc789String getStr_5 = str_1.replace(&quot;Bb&quot;,&quot;Cc&quot;);// 使用指定字符串将字符串分割，返回值为数组：{&quot;AaB&quot;, &quot;789&quot;}String[] getStrArr = str_1.split(&quot;b&quot;);// 判断字符串是否为空：falseboolean b_3 = str_1.isEmpty(); Arrays包：java.util.Arrays 常用方法public static String toString(int[] a)：返回指定数组内容的字符串表示形式。 public static void sort(int[] a)：对指定的 int 型数组按数字升序进行排序。 方法示例12345int[] intArr = new int[]{7, 3, 1, 4, 2};// 返回数组中的内容：[7, 3, 1, 4, 2]String getStr = Arrays.toString(intArr);// 升序排序：[1, 2, 3, 4, 7]Arrays.sort(intArr); Math包：java.lang.Math 基本运算方法public static double abs(double a)：返回 double 值的绝对值。 public static double ceil(double a)：返回大于等于参数参数的最小整数。（向上取整） public static double floor(double a)：返回小于等于参数最大的整数。（向下取整） public static long round(double a)：返回最接近参数的 long。（相当于四舍五入方法） 方法示例12345678// 返回绝对值：1111int getInt = Math.abs(-1111);// 向上取整：6.0double getDouble_1 = Math.ceil(5.1);// 向下取整：5.0double getDouble_2 = Math.floor(5.9);// 四舍五入：4Long getLong = Math.round(3.5); Objects包：java.util.Objects 常用方法public static boolean equals(Object a, Object b)：判断两个对象是否相等。（可以避免出现空指针异常） 方法示例12345String str_1 = &quot;123&quot;;String str_2 = null;// 与 null 进行比较不会出现空指针异常boolean b_2 = Objects.equals(str_1, str_2);System.out.println(b_2); Date包：java.util.Date 构造方法public Date()：分配并初始化 Date 对象，以表示分配它的时间（精确到毫秒）。 public Date(Long date)：分配并初始化 Date 对象，以表示从标准基准时间（「历元（epoch）」即 1970 年 1 月 1 日 00:00:00 GMT）以来的指定毫秒数。 我们处于东八区，所以我们的基准时间为：1970 年 1 月 1 日 08:00:00 GMT 常用方法public long getTime()：把日期对象转换成对应的时间毫秒值。 方法示例12345678910// 创建日期对象，并输出当前时间：// Fri Dec 07 14:24:32 CST 2018System.out.println(new Date());// 创建日期对象，并将毫秒值转成日期对象：// Thu Jan 01 08:00:11 CST 1970System.out.println(new Date(11000L));Date date = new Date();// 把日期对象装换成对应时间的毫秒值：1544164030712Long getTime = date.getTime();System.out.println(getTime); DateFormat包：java.text.DateFormat java.text.SimpleDateFormat 格式化：按照指定的格式，从Date对象转换为String对象。 解析：按照指定的格式，从String对象转换为Date对象。 构造方法DateFormat 为抽象类，不能直接使用，所以需要常用的子类 java.text.SimpleDateFormat。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为： public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。 参数 pattern 是一个字符串，代表日期时间的自定义格式。 格式规则 标识字母（区分大小写） 含义 y 年 M 年中的月份 w 年中的周数 W 月份中的周数 D 年中的天数 d 月份中的天数 F 月份中的星期 E 星期中的天数 a am / pm 标记 H 一天中的小时数（0 - 23） k 一天中的小时数（1 - 24） K am / pm 中的小时数（0 - 11） h am / pm 中的小时数（1 - 12） m 小时中的分钟数 s 分钟中的秒数 S 毫秒数 z 时区 Z 时区 备注：更详细的格式规则，可以参考 SimpleDateFormat 类的 API 文档 0。 常用方法public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 方法示例12345678Date date = new Date();// 创建日期格式化对象，在获取格式化对象时可以指定风格DateFormat df = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;);// 将 Date 对象格式化为字符串String str = df.format(date); // 2018年12月07日// 将字符串解析为 Date 对象date = df.parse(str);System.out.println(date); // Fri Dec 07 00:00:00 CST 2018 Calendar包：java.util.Calendar 静态方法public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 123public static void main(String[] args) { Calendar cal = Calendar.getInstance();} 常用方法 public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar 时间值（从历元到现在的毫秒偏移量）的Date对象。 Calendar 类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（从 0 开始，可以+1 使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12 小时制） HOUR_OF_DAY 时（24 小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为 1，可以 -1 使用） get / set 方法get 方法用来获取指定字段的值，set 方法用来设置指定字段的值。 add 方法add 方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。 getTime 方法Calendar 中的 getTime 方法并不是获取毫秒时刻，而是拿到对应的 Date 对象。 西方星期的开始为周日，中国为周一。 在 Calendar 类中，月份的表示是以 0 - 11 代表 1 - 12 月。 日期是有大小关系的，时间靠后，时间越大。 方法示例123456789101112131415161718// 创建 Calendar 对象Calendar cal = Calendar.getInstance();// 设置年份为 2020 年cal.set(Calendar.YEAR, 2020);// 使用 add 方法cal.add(Calendar.DAY_OF_MONTH, 2); // 加 2 天cal.add(Calendar.YEAR, -3); // 减 3 年// 获取年int getYear = cal.get(Calendar.YEAR);// 获取月int getMonth = cal.get(Calendar.MONTH) + 1;// 获取日int getDayOfMonth = cal.get(Calendar.DAY_OF_MONTH);// 输出：2017年12月9日System.out.print(getYear + &quot;年&quot; + getMonth + &quot;月&quot; + getDayOfMonth + &quot;日&quot;);// 获取对应日期对象：Sat Dec 09 19:30:36 CST 2017Date date = cal.getTime();System.out.println(date); System包：java.lang.System 静态方法public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 参数序号 参数名称 参数类型 参数含义 1 src Object 源数组 2 srcPos int 源数组索引起始位置 3 dest Object 目标数组 4 destPos int 目标数组索引起始位置 5 length int 复制元素个数 方法示例123456// 获取当前时间毫秒值：1544183290919System.out.println(System.currentTimeMillis());int[] src = new int[]{1, 2, 3, 4, 5};int[] dest = new int[]{6, 7, 8, 9, 10};// dest：[1, 2, 3, 9, 10]System.arraycopy(src, 0, dest, 0, 3); StringBuilder包：java.lang.StringBuilder 构造方法public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个 StringBuilder 容器，并将字符串添加进去。 常用方法public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 public StringBuilder reverse()：将此字符序列用其反转形式取代。 方法示例1234567891011121314151617// 无参构造StringBuilder strBd_1 = new StringBuilder();// 有参构造StringBuilder strBd_2 = strBd_1.append(&quot;hello&quot;);// 对比一下System.out.println(strBd_1 + &quot; &quot; + strBd_2); // hello helloSystem.out.println(strBd_1 == strBd_2); // true// 可以添加任何类型strBd_1.append(&quot;world&quot;);strBd_1.append(true);strBd_1.append(100);// 删除元素strBd_1.delete(0, strBd_1.length());// 链式编程strBd_1.append(&quot;Hello&quot;).append(&quot;world&quot;).append(&quot;.&quot;);String str = strBd_1.toString();System.out.println(str); // Helloworld. Collection常用方法public boolean add(E e)：把给定的对象添加到当前集合中 。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 public void clear() :清空集合中所有的元素。 方法示例12345678910111213141516171819202122// 使用多态形式创建集合对象Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();coll.add(&quot;1&quot;);coll.add(&quot;2&quot;);coll.add(&quot;3&quot;);// 判断元素在集合中是否存在boolean b = coll.contains(&quot;2&quot;); // true// 删除集合中指定元素System.out.println(coll.remove(&quot;3&quot;)); // true// 集合长度System.out.println(coll.size()); // 2System.out.println(coll);// Object[] toArray()转换成一个Object数组Object[] objects = coll.toArray();// 遍历数组for (int i = 0; i &lt; objects.length; i++) { System.out.println(objects[i]);}// 清空集合coll.clear();// 判断是否为空System.out.println(coll.isEmpty()); Iterator包：java.util.Iterator 构造方法public Iterator iterator()：获取集合对应的迭代器，用来遍历集合中的元素的。 常用方法public E next()：返回迭代的下一个元素。 public boolean hasNext()：如果仍有元素可以迭代，则返回 true。 方法示例123456789101112// 使用多态方式创建对象Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();coll.add(&quot;1&quot;);coll.add(&quot;2&quot;);coll.add(&quot;3&quot;);// 使用迭代器遍历Iterator&lt;String&gt; it = coll.iterator();// 泛型指的是迭代出元素的数据类型while (it.hasNext()) { // 判断是否有迭代元素 String s = it.next(); // 获取迭代出的元素 System.out.println(s);} 增强 for遍历数组1234int[] arr = {3, 5, 6, 87};for (int a : arr) { // a 代表数组中的每个元素 System.out.println(a);} 遍历集合1234567Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();coll.add(&quot;1&quot;);coll.add(&quot;2&quot;);coll.add(&quot;3&quot;);for (String s : coll) { // 变量 s 接收被遍历到的集合元素 System.out.println(s);} 泛型含有泛型的类定义格式修饰符 class 类名&lt;代表泛型的变量&gt; { } API 中的 ArrayList 集合： 123456class ArrayList&lt;E&gt;{ public boolean add(E e){ } public E get(int index){ } ....} 创建对象时： ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 变量 E 的值就是 String 类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;String&gt;{ public boolean add(String e){ } public String get(int index){ } ...} 再例如： ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); 此时，变量 E 的值就是 Integer 类型,那么我们的类型就可以理解为： 123456class ArrayList&lt;Integer&gt; { public boolean add(Integer e) { } public Integer get(int index) { } ...} 自定义泛型类定义123456789101112public class MyGenericClass&lt;MVP&gt; { // 没有 MVP 类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型 private MVP mvp; public void setMVP(MVP mvp) { this.mvp = mvp; } public MVP getMVP() { return mvp; }} 使用123456789101112131415public class GenericClassDemo { public static void main(String[] args) { // 创建一个泛型为 String 的类 MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;(); // 调用 setMVP my.setMVP(&quot;大胡子登登&quot;); // 调用 getMVP String mvp = my.getMVP(); System.out.println(mvp); //创建一个泛型为 Integer 的类 MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); my2.setMVP(123); Integer mvp2 = my2.getMVP(); }} 含有泛型的方法定义格式修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){ } 例如： 123456789public class MyGenericMethod { public &lt;MVP&gt; void show(MVP mvp) { System.out.println(mvp.getClass()); } public &lt;MVP&gt; MVP show2(MVP mvp) { return mvp; }} 使用格式调用方法时，确定泛型的类型 12345678910public class GenericMethodDemo { public static void main(String[] args) { // 创建对象 MyGenericMethod mm = new MyGenericMethod(); // 演示看方法提示 mm.show(&quot;aaa&quot;); mm.show(123); mm.show(12.45); }} 含有泛型的接口定义格式修饰符 interface接口名&lt;代表泛型的变量&gt; { } 例如： 12345public interface MyGenericInterface&lt;E&gt;{ public abstract void add(E e); public abstract E getE(); } 使用格式1、定义类时确定泛型的类型 例如 1234567891011public class MyImp1 implements MyGenericInterface&lt;String&gt; { @Override public void add(String e) { // 省略... } @Override public String getE() { return null; }} 此时，泛型E的值就是String类型。 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型 例如 1234567891011public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; { @Override public void add(E e) { // 省略... } @Override public E getE() { return null; }} 确定泛型： 123456789/* * 使用 */public class GenericInterface { public static void main(String[] args) { MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add(&quot;aa&quot;); }} 泛型通配符当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符 &lt;?&gt; 表示。但是一旦使用泛型的通配符后，只能使用 Object 类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用泛型的通配符：不知道使用什么类型来接收的时候,此时可以使用 ?,? 表示未知通配符。 此时只能接受数据，不能往该集合中存储数据。 举个例子大家理解使用即可： 12345678public static void main(String[] args) { Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2);}public static void getElement(Collection&lt;?&gt; coll){}// ？代表可以接收任意类型 tips：泛型不存在继承关系Collection&lt;Object&gt; list = new ArrayList&lt;String&gt;();这种是错误的。 通配符高级使用—-受限泛型之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在 JAVA 的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 比如：现已知 Object 类，String 类，Number 类，Integer 类，其中 Number 是 Integer 的父类 123456789101112131415161718192021public static void main(String[] args) { Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement1(list1); getElement1(list2);// 报错 getElement1(list3); getElement1(list4);// 报错 getElement2(list1);// 报错 getElement2(list2);// 报错 getElement2(list3); getElement2(list4); }// 泛型的上限：此时的泛型?，必须是 Number 类型或者 Number 类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll){}// 泛型的下限：此时的泛型 ?，必须是 Number 类型或者 Number 类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll){} List包：java.util.List 常用方法public void add(int index, E element)：将指定的元素，添加到该集合中的指定位置上。 public E get(int index)：返回集合中指定位置的元素。 public E remove(int index)：移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element)：用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 方法示例详情见 ArrayList ArrayList包：java.util.ArrayList &lt;E&gt; &lt;E&gt; ：泛型 格式ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); 方法public boolean add(E e)：将指定的元素添加到此集合的尾部。 public E remove(int index) ：移除此集合中指定位置上的元素。返回被删除的元素。 public E get(int index)：返回此集合中指定位置上的元素。返回获取的元素。 public int size() ：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。 方法示例1234567891011ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();// 将「Hello」添加到集合尾部。list.add(&quot;Hello&quot;);// 将「World」添加到集合尾部。list.add(&quot;World&quot;);// 将 0 号元素赋值给 getStringString getString = list.get(0);// 移除 0 号元素，并返回元素内容。String strRemove = list.remove(0);// 获取集合长度int i = list.size(); LinkedListpublic void addFirst(E e)：将指定元素插入此列表的开头。 public void addLast(E e)：将指定元素添加到此列表的结尾。 public E getFirst()：返回此列表的第一个元素。 public E getLast()：返回此列表的最后一个元素。 public E removeFirst()：移除并返回此列表的第一个元素。 public E removeLast()：移除并返回此列表的最后一个元素。 public E pop()：从此列表所表示的堆栈处弹出一个元素。 public void push(E e)：将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回 true。 方法示例12345678910111213141516171819202122// 不可使用多态LinkedList&lt;String&gt; linked = new LinkedList&lt;&gt;();linked.add(&quot;2&quot;);linked.add(&quot;3&quot;);// 在开头添加一个元素：linked.addFirst(&quot;1&quot;); // [1, 2, 3]// 在末尾添加一个元素：linked.addLast(&quot;4&quot;); // [1, 2, 3, 4]// 在开头添加一个元素：linked.push(&quot;0&quot;); // [0, 1, 2, 3, 4]// 获取开头的元素：String getFirstStr = linked.getFirst(); // 0// 获取末尾的元素：String getLastStr = linked.getLast(); // 4// 移除开头的元素：linked.removeFirst(); // [1, 2, 3, 4]// 移除末尾的元素：linked.removeLast(); // [1, 2, 3]// 移除末尾的元素：linked.pop(); // [1, 2]// 集合是否为空：linked.isEmpty(); // false Set包：java.util.Set HashSet包：java.util.HashSet 元素不可重复，且无序（存取顺序不一致）。底层实现由 java.util.HashMap 支持。 根据对象的哈希值来确定元素在集合中的存储位置，良好的存取和查找性能。保证元素的唯一性依赖于：hashCode 与 equsls 方法。 1234567Set&lt;String&gt; set = new HashSet&lt;&gt;();set.add(&quot;aae&quot;);set.add(&quot;aab&quot;);set.add(&quot;aac&quot;);set.add(&quot;aad&quot;);set.add(&quot;aaa&quot;);System.out.println(set); // [aaa, aac, aab, aae, aad] 存储自定义类型元素给 HashSet 中存放自定义类型元素时，需要重写对象中的 hashCode 和 equals 方法，建立自己的比较方式，才能保证 HashSet 集合中的对象唯一。 创建自定义 Student 类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); } @Override public int hashCode() { return Objects.hash(name, age); }} main 方法： 123456789101112131415161718192021public class HashSetDemo2 { public static void main(String[] args) { // 创建集合对象该集合中存储 Student 类型对象 HashSet&lt;Student&gt; stuSet = new HashSet&lt;Student&gt;(); // 存储 Student stu = new Student(&quot;于谦&quot;, 43); stuSet.add(stu); stuSet.add(new Student(&quot;郭德纲&quot;, 44)); stuSet.add(new Student(&quot;于谦&quot;, 43)); stuSet.add(new Student(&quot;郭麒麟&quot;, 23)); stuSet.add(stu); for (Student stu2 : stuSet) { System.out.println(stu2); } }}// 执行结果：// Student [name=郭德纲, age=44]// Student [name=于谦, age=43]// Student [name=郭麒麟, age=23] LinkedHashSet在HashSet下面有一个子类 java.util.LinkedHashSet，它是链表和哈希表组合的一个数据存储结构。 演示代码如下: 123456789101112131415161718public class LinkedHashSetDemo { public static void main(String[] args) { Set&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(); set.add(&quot;bbb&quot;); set.add(&quot;aaa&quot;); set.add(&quot;abc&quot;); set.add(&quot;bbc&quot;); Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext()) { System.out.println(it.next()); } }}// 结果：// bbb// aaa// abc// bbc 可变参数格式修饰符 返回值类型 方法名(参数类型... 形参名){ } 等价于： 修饰符 返回值类型 方法名(参数类型[] 形参名){ } 后面这种定义，调用时必须传递数组，前者直接传递数据即可。 方法示例123456789101112131415161718192021222324252627282930public class ChangeArgs { public static void main(String[] args) { int[] arr = { 1, 4, 62, 431, 2 }; int sum = getSum(arr); System.out.println(sum); // 求这几个元素和 6 7 2 12 2121 int sum2 = getSum(6, 7, 2, 12, 2121); System.out.println(sum2); } /* * 完成数组所有元素的求和原始写法 public static int getSum(int[] arr){ int sum = 0; for(int a : arr){ sum += a; } return sum; } */ // 可变参数写法 public static int getSum(int... arr) { int sum = 0; for (int a : arr) { sum += a; } return sum; }} tips：上述 add 方法在同一个类中，只能存在一个。因为会发生调用的不确定性 注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。 Collections包：java.utils.Collections 常用方法public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements) ：往集合中添加一些元素。public static void shuffle(List&lt;?&gt; list) 打乱顺序：打乱集合顺序。public static &lt;T&gt; void sort(List&lt;T&gt; list)：将集合中元素按照默认规则排序。public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )：将集合中元素按照指定规则排序。 方法示例12345678910111213141516171819public class CollectionsDemo { public static void main(String[] args) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); // 原来写法 // list.add(12); // list.add(14); // list.add(15); // list.add(1000); // 采用工具类完成往集合中添加元素 Collections.addAll(list, 5, 222, 1，2); System.out.println(list); // 排序方法 Collections.sort(list); System.out.println(list); }}// 结果：// [5, 222, 1, 2]// [1, 2, 5, 222] 想要指定顺序参见 Comparator 比较器。 Comparator 比较器格式public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ) public int compare(String o1, String o2)：比较其两个参数的顺序。 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序，则 o1 小于 o2，返回（负数），相等返回 0，o1 大于 o2 返回（正数）如果要按照降序排序则 o1 小于 o2，返回（正数），相等返回 0，o1 大于 o2 返回（负数） 方法示例1234567891011121314151617public class CollectionsDemo3 { public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;cba&quot;); list.add(&quot;aba&quot;); list.add(&quot;sba&quot;); list.add(&quot;nba&quot;); // 排序方法按照第一个单词的降序 Collections.sort(list, new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { return o2.charAt(0) - o1.charAt(0); } }); System.out.println(list); }} 结果：[sba, nba, cba, aba] Comparable 和 Comparator 两个接口的区别Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compareTo 方法被称为它的自然比较方法。只能在类中实现 compareTo() 一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过 Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Comparator：强行对某个对象进行整体排序。可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用 Comparator 来控制某些数据结构（如有序set 或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。 扩展测试类： 123456789101112131415161718192021222324252627282930313233public class Demo { public static void main(String[] args) { // 创建四个学生对象，存储到集合中 ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); list.add(new Student(&quot;rose&quot;,18)); list.add(new Student(&quot;jack&quot;,16)); list.add(new Student(&quot;abc&quot;,16)); list.add(new Student(&quot;ace&quot;,17)); list.add(new Student(&quot;mark&quot;,16)); /* 让学生按照年龄排序升序 */// Collections.sort(list); //要求该 list 中元素类型必须实现比较器 Comparable 接口 Collections.sort(list, new Comparator&lt;Student&gt;() { @Override public int compare(Student o1, Student o2) { // 年龄降序 int result = o2.getAge()-o1.getAge(); // 年龄降序 if(result==0){ // 第一个规则判断完了 下一个规则姓名的首字母升序 result = o1.getName().charAt(0)-o2.getName().charAt(0); } return result; } }); for (Student student : list) { System.out.println(student); } }} Student 类重写： 1234567public class Student implements Comparable&lt;Student&gt;{ // 忽略其余代码 @Override public int compareTo(Student o) { return this.age-o.age; // 升序 }} 结果如下： 12345Student{name='rose', age=18}Student{name='ace', age=17}Student{name='abc', age=16}Student{name='jack', age=16}Student{name='mark', age=16} Map包：java.util.Map 常用方法public V put(K key, V value)：把指定的键与指定的值添加到Map集合中。 public V remove(Object key)：把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key)：根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) ：判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet()：获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：获取到Map集合中所有的键值对对象的集合(Set集合)。 tips: 使用 put 方法时，若指定的键（key）在集合中没有，则没有这个键对应的值，返回 null，并把指定的键值添加到集合中； 若指定的键（key）在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 HashMap包：java.util.HashMap 常用方法public V put(K key, V value)：把指定的键与指定的值添加到 Map 集合中。 public V remove(Object key)：把指定的键所对应的键值对元素 在 Map 集合中删除，返回被删除元素的值。 public V get(Object key)：根据指定的键，在 Map 集合中获取对应的值。 boolean containsKey(Object key) ：判断集合中是否包含指定的键。 public Set&lt;K&gt; keySet()：获取 Map 集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：获取到 Map 集合中所有的键值对对象的集合（Set 集合）。 方法示例123456789101112131415HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(&quot;1&quot;, &quot;1&quot;);map.put(&quot;2&quot;, &quot;2&quot;);map.put(&quot;3&quot;, &quot;3&quot;);map.put(&quot;4&quot;, &quot;4&quot;);map.put(&quot;4&quot;, &quot;3&quot;); // key 不可重复：{1=1, 2=2, 3=3, 4=3}map.remove(&quot;1&quot;); // {2=2, 3=3, 4=3}// 获取指定 key 的 value，不存在返回 nullString getValue_1 = map.get(&quot;1&quot;);System.out.println(getValue_1); // nullString getValue_2 = map.get(&quot;2&quot;);System.out.println(getValue_2); // 2boolean b = map.containsKey(&quot;1&quot;); // falseSet&lt;String&gt; set = map.keySet();System.out.println(map); 四种方法遍历 HashMap12345678910111213141516171819202122232425262728293031HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(&quot;一&quot;, 11);map.put(&quot;二&quot;, 22);map.put(&quot;三&quot;, 33);map.put(&quot;四&quot;, 44);map.put(&quot;五&quot;, 55);// 键找值Set&lt;String&gt; set = map.keySet();// 增强 forfor (String s : set) { System.out.println(map.get(s));}// IteratorIterator&lt;String&gt; it = set.iterator();while (it.hasNext()) { System.out.println(map.get(it.next()));}// 键值对Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();// 增强 forfor (Map.Entry entry : entries) { System.out.println(entry.getKey() + &quot; &quot; + entry.getValue());}// IteratorIterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it_1 = entries.iterator();while (it_1.hasNext()) { Map.Entry&lt;String, Integer&gt; entry = it_1.next(); System.out.println(entry.getKey() + &quot; &quot; + entry.getValue());} 存储自定义类型 注意，学生姓名相同并且年龄相同视为同一名学生。 学生类： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); } @Override public int hashCode() { return Objects.hash(name, age); }} 编写测试类： 12345678910111213141516171819public class HashMapTest { public static void main(String[] args) { // 1,创建 Hashmap 集合对象。 Map&lt;Student,String&gt;map = new HashMap&lt;Student,String&gt;(); // 2,添加元素。 map.put(newStudent(&quot;lisi&quot;,28), &quot;上海&quot;); map.put(newStudent(&quot;wangwu&quot;,22), &quot;北京&quot;); map.put(newStudent(&quot;zhaoliu&quot;,24), &quot;成都&quot;); map.put(newStudent(&quot;zhouqi&quot;,25), &quot;广州&quot;); map.put(newStudent(&quot;wangwu&quot;,22), &quot;南京&quot;); // 3,取出元素。键找值方式 Set&lt;Student&gt;keySet = map.keySet(); for(Student key: keySet){ Stringvalue = map.get(key); System.out.println(key.toString()+&quot;.....&quot;+value); } }} 当给 HashMap 中存放自定义对象时，如果自定义对象作为 key 存在，这时要保证对象唯一，必须复写对象的 hashCode 和 equals 方法(如果忘记，请回顾 HashSet 存放自定义对象)。 如果要保证 map 中存放的 key 和取出的顺序一致，可以使用 java.util.LinkedHashMap 集合来存放。 LinkedHashMap链表和哈希表组合的一个数据存储结构。 123456789101112public class LinkedHashMapDemo { public static void main(String[] args) { LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;(); map.put(&quot;邓超&quot;, &quot;孙俪&quot;); map.put(&quot;李晨&quot;, &quot;范冰冰&quot;); map.put(&quot;刘德华&quot;, &quot;朱丽倩&quot;); Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet(); for (Entry&lt;String, String&gt; entry : entrySet) { System.out.println(entry.getKey() + &quot; &quot; + entry.getValue()); } }} 结果： 123邓超 孙俪李晨 范冰冰刘德华 朱丽倩 异常五个关键字：try、catch、finally、throw、throws 抛出异常 throw格式throw new 异常类名(参数); 12throw new NullPointerException(&quot;要访问的 arr 数组不存在&quot;);throw new ArrayIndexOutOfBoundsException(&quot;该索引在数组中不存在，已超出范围&quot;); 方法示例1234567891011121314151617181920212223public class ThrowDemo { public static void main(String[] args) { // 创建一个数组 int[] arr = {2,4,52,2}; // 根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println(&quot;over&quot;); } // 根据索引找到数组中对应的元素 public static int getElement(int[] arr,int index){ // 判断索引是否越界 if(index&lt;0 || index&gt;arr.length‐1){ // 判断条件如果满足，当执行完 throw 抛出异常对象后，方法已经无法继续运算。 // 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 throw new ArrayIndexOutOfBoundsException(&quot;哥们，角标越界了~~~&quot;); } int element = arr[index]; return element; }} Objects 非空判断public static &lt;T&gt; T requireNonNull(T obj)：查看指定引用对象不是 null。 方法示例12345public static &lt;T&gt; T requireNonNull(T obj) { if (obj == null) throw new NullPointerException() ; return obj;} throws 声明异常修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{ } 方法示例123456789101112public class ThrowsDemo { public static void main(String[] args) throws FileNotFoundException { read(&quot;a.txt&quot;); } // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用 throws 关键字进行声明 public static void read(String path) throws FileNotFoundException { if (!path.equals(&quot;a.txt&quot;)) { // 如果不是 a.txt 这个文件 // 我假设如果不是 a.txt 认为该文件不存在 是一个错误也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); } }} throws 用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在 throws 后面可以写多个异常类，用逗号隔开。 1234567891011121314public class ThrowsDemo2 { public static void main(String[] args) throws IOException { read(&quot;a.txt&quot;); } public static void read(String path)throws FileNotFoundException, IOException { if (!path.equals(&quot;a.txt&quot;)) { // 如果不是 a.txt 这个文件 // 我假设如果不是 a.txt 认为该文件不存在是一个错误也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); } if (!path.equals(&quot;b.txt&quot;)) { throw new IOException(); } }} try…catch 捕获异常try：该代码块中编写可能产生异常的代码。catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意：try 和 catch 都不能单独使用，必须连用。 123456try{ 编写可能会出现异常的代码}catch(异常类型 e){ 处理异常的代码 // 记录日志 / 打印异常信息 / 继续抛出异常} 方法示例123456789101112131415161718public class TryCatchDemo { public static void main(String[] args) { try { // 当产生异常时，必须有处理方式。要么捕获，要么声明。 read(&quot;b.txt&quot;); } catch (FileNotFoundException e) { // 括号中需要定义什么呢？ // try 中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); } System.out.println(&quot;over&quot;); } // 我们当前的这个方法中有异常有编译期异常 public static void read(String path) throws FileNotFoundException { if (!path.equals(&quot;a.txt&quot;)) {//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为该文件不存在是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); } }} 查看异常信息public String getMessage()：获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。public String toString()：获取异常的类型和异常描述信息(不用)。public void printStackTrace()：打印异常的跟踪栈信息并输出到控制台。 finally 代码块 注意：finally 不能单独使用。 当只有在 try 或者 catch 中调用退出 JVM 的相关方法，此时 finally 才不会执行，否则 finally 永远会执行。 1234567891011121314151617181920public class TryCatchDemo4 { public static void main(String[] args) { try { read(&quot;a.txt&quot;); } catch (FileNotFoundException e) { // 抓取到的是编译期异常抛出去的是运行期 throw new RuntimeException(e); } finally { System.out.println(&quot;不管程序怎样，这里都将会被执行。&quot;); } System.out.println(&quot;over&quot;); } // 我们当前的这个方法中有异常有编译期异常 public static void read(String path) throws FileNotFoundException { if (!path.equals(&quot;a.txt&quot;)) { // 如果不是 a.txt 这个文件 // 我假设如果不是 a.txt 认为该文件不存在是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); } }} 多线程包：java.lang.Thread 构造方法``public Thread()：分配一个新的线程对象。 public Thread(String name)：分配一个指定名字的新的线程对象。 public Thread(Runnable target)：分配一个带有指定目标新的线程对象。 public Thread(Runnable target,String name)`：分配一个带有指定目标新的线程对象并指定名字。 常用方法public String getName()：获取当前线程名称。public void start()：导致此线程开始执行；Java 虚拟机调用此线程的 run 方法。public void run()：此线程要执行的任务在此处定义代码。public static void sleep(long millis)：使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。public static Thread currentThread()：返回对当前正在执行的线程对象的引用。 创建多线程的两种方法第一种1234567891011121314public class MyThread extends Thread { // 定义指定线程名称的构造方法 public MyThread(String name) { // 调用父类的 String 参数的构造方法，指定线程的名称 super(name); } // 重写 run 方法，完成该线程执行的逻辑 @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(getName()+&quot;：正在执行！&quot;+i); } }} 第二种12345678public class MyRunnable implements Runnable{ @Override public void run() { for (int i = 0; i &lt; 20; i++) { System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); } }} 123456789101112public class Demo { public static void main(String[] args) { // 创建自定义类对象线程任务对象 MyRunnable mr = new MyRunnable(); // 创建线程对象 Thread t = new Thread(mr, &quot;小强&quot;); t.start(); for (int i = 0; i &lt; 20; i++) { System.out.println(&quot;旺财 &quot; + i); } }} 线程安全同步代码块123synchronized(同步锁){ // 需要同步操作的代码} 锁对象可以是任意类型。 多个线程对象要使用同一把锁。注意：在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外等着（BLOCKED）。 同步方法123public synchronized void method(){ // 可能会产生线程安全问题的代码} 同步锁是谁?对于非 static 方法,同步锁就是 this。对于 static 方法，我们使用当前方法所在类的字节码对象（类名.class）。 Lock 锁包：java.util.concurrent.locks.Lock public void lock()：加同步锁。public void unlock()：释放同步锁。 1234Lock lock = new ReentrantLock();lock.lock();// 需要锁住的代码块lock.unlock(); 线程状态 线程状态 导致状态发生条件 NEW（新建） 线程刚被创建，但是并未启动。还没调用 start 方法。 Runnable（可运行） 线程可以在 java 虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。 Blocked（锁阻塞） 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入 Blocked 状态；当该线程持有锁时，该线程将变成 Runnable 状态。 Waiting（无线等待） 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用 notify 或者 notifyAll 方法才能够唤醒。 TimedWaiting（计时等待） 同 waiting 状态，有几个方法有超时参数，调用他们将进入 Timed Waiting 状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有 Thread.sleep 、Object.wait。 Teminated（被终止） 因为 run 方法正常退出而死亡，或者因为没有捕获的异常终止了 run 方法而死亡。 File包：java.io.File 构造方法public File(String pathname)：通过将给定的路径名字符串转换为抽象路径名来创建新的 File 实例。public File(String parent, String child)：从父路径名字符串和子路径名字符串创建新的 File 实例。public File(File parent, String child)：从父抽象路径名和子路径名字 方法示例1234567891011121314151617// 文件路径名String pathname = &quot;D:\\\\aaa.txt&quot;;File file1 = new File(pathname);// 文件路径名String pathname2 = &quot;D:\\\\aaa\\\\bbb.txt&quot;;File file2 = new File(pathname2);// 通过父路径和子路径字符串String parent = &quot;d:\\\\aaa&quot;;String child = &quot;bbb.txt&quot;;File file3 = new File(parent, child);// 通过父级 File 对象和子路径字符串File parentDir = new File(&quot;d:\\\\aaa&quot;);String child = &quot;bbb.txt&quot;;File file4 = new File(parentDir, child); 一个 File 对象代表硬盘中实际存在的一个文件或者目录。 无论该路径下是否存在文件或者目录，都不影响 File 对象的创建。 绝对路径：从盘符开始的路径，这是一个完整的路径。相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。 常用方法获取功能的方法public String getAbsolutePath()：返回此 File 的绝对路径名字符串。public String getPath()：将此 File 转换为路径名字符串。public String getName()：返回由此 File 表示的文件或目录的名称。public long length()：返回由此 File 表示的文件的长度。 方法示例123456789101112131415161718192021222324252627public static void main(String[] args) { File f = new File(&quot;D:/aaa/bbb.java&quot;); System.out.println(&quot;文件绝对路径:&quot; + f.getAbsolutePath()); System.out.println(&quot;文件构造路径:&quot; + f.getPath()); System.out.println(&quot;文件名称:&quot; + f.getName()); System.out.println(&quot;文件长度:&quot; + f.length() + &quot;字节&quot;); File f2 = new File(&quot;D:/aaa&quot;); System.out.println(&quot;目录绝对路径:&quot; + f2.getAbsolutePath()); System.out.println(&quot;目录构造路径:&quot; + f2.getPath()); System.out.println(&quot;目录名称:&quot; + f2.getName()); System.out.println(&quot;目录长度:&quot; + f2.length()); // 项目下的 bbb.java 文件 File f2 = new File(&quot;bbb.java&quot;); System.out.println(f2.getAbsolutePath());}/*输出结果：文件绝对路径:d:\\aaa\\bbb.java文件构造路径:d:\\aaa\\bbb.java文件名称:bbb.java文件长度:636字节目录绝对路径:d:\\aaa目录构造路径:d:\\aaa目录名称:aaa目录长度:4096D:\\idea_project_test4\\bbb.java*/ 判断功能的方法public boolean exists()：此 File 表示的文件或目录是否实际存在。public boolean isDirectory()：此 File 表示的是否为目录。public boolean isFile()：此 File 表示的是否为文件。 方法示例1234567891011121314151617public static void main(String[] args) { File f = new File(&quot;d:\\\\aaa\\\\bbb.java&quot;); File f2 = new File(&quot;d:\\\\aaa&quot;); // 判断是否存在 System.out.println(&quot;d:\\\\aaa\\\\bbb.java 是否存在:&quot;+f.exists()); System.out.println(&quot;d:\\\\aaa 是否存在:&quot;+f2.exists()); // 判断是文件还是目录 System.out.println(&quot;d:\\\\aaa 文件?:&quot;+f2.isFile()); System.out.println(&quot;d:\\\\aaa 目录?:&quot;+f2.isDirectory());}/*输出结果：d:\\aaa\\bbb.java 是否存在:trued:\\aaa 是否存在:trued:\\aaa 文件?:falsed:\\aaa 目录?:true*/ 创建删除功能的方法public boolean createNewFile()：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。public boolean delete()：删除由此File表示的文件或目录。public boolean mkdir()：创建由此File表示的目录。public boolean mkdirs()：创建由此File表示的目录，包括任何必需但不存在的父目录。 方法示例12345678910111213141516171819202122public static void main(String[] args) throws IOException { // 文件的创建 File f = new File(&quot;aaa.txt&quot;); System.out.println(&quot;是否存在:&quot;+f.exists()); // false System.out.println(&quot;是否创建:&quot;+f.createNewFile()); // true System.out.println(&quot;是否存在:&quot;+f.exists()); // true // 目录的创建 File f2= new File(&quot;newDir&quot;); System.out.println(&quot;是否存在:&quot;+f2.exists()); // false System.out.println(&quot;是否创建:&quot;+f2.mkdir()); // true System.out.println(&quot;是否存在:&quot;+f2.exists()); // true // 创建多级目录 File f3= new File(&quot;newDira\\\\newDirb&quot;); System.out.println(f3.mkdir()); // false File f4= new File(&quot;newDira\\\\newDirb&quot;); System.out.println(f4.mkdirs()); // true // 文件的删除 System.out.println(f.delete()); // true // 目录的删除 System.out.println(f2.delete()); // true System.out.println(f4.delete()); // false} 目录的遍历public String[] list()：返回一个String数组，表示该File目录中的所有子文件或目录。public File[] listFiles()：返回一个File数组，表示该File目录中的所有的子文件或目录。 方法示例12345678910111213public static void main(String[] args) { File dir = new File(&quot;d:\\\\java_code&quot;); // 获取当前目录下的文件以及文件夹的名称。 String[] names = dir.list(); for(String name : names){ System.out.println(name); } // 获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息 File[] files = dir.listFiles(); for (File file : files) { System.out.println(file); }} IO 流输入流 ：把数据从其他设备上读取到内存中的流。输出流 ：把数据从内存中写出到其他设备上的流。 输入流 输出流 字节流 字节输入流 InputStream 字节输出流 OutputStream 字符流 字符输入流 Reader 字符输出流 Writer 字节流OutPutStream 字节输出流包：java.io.OutputStream public void close()：关闭此输出流并释放与此流相关联的任何系统资源。public void flush()：刷新此输出流并强制任何缓冲的输出字节被写出。public void write(byte[] b)：将 b.length 字节从指定的字节数组写入此输出流。public void write(byte[] b, int off, int len)：从指定的字节数组写入 len 字节，从偏移量 off 开始输出到此输出流。public abstract void write(int b)：将指定的字节输出流。 当完成流的操作时，必须调用 close 方法，释放系统资源。 FileOutputStream 类构造方法public FileOutputStream(File file)：创建文件输出流以写入由指定的 File 对象表示的文件。public FileOutputStream(String name)：创建文件输出流以指定的名称写入文件。 方法示例123456789101112131415161718192021222324252627public static void main(String[] args) throws IOException { FileOutputStream fos = new FileOutputStream(&quot;D:\\\\a.txt&quot;); // 写出字节数据 fos.write('a'); // a fos.write(98); // b // 换行 fos.write(System.lineSeparator().getBytes()); // 写出字节数组数据 byte[] bytes = &quot;123456&quot;.getBytes(); fos.write(bytes); // 123456 // 换行 fos.write(&quot;\\r\\n&quot;.getBytes()); // 写出指定长度 fos.write(bytes, 2, 3); // 345 // 关闭资源 fos.close(); // 数据追加续写 FileOutputStream fos1 = new FileOutputStream(&quot;D:\\\\a.txt&quot;, true); fos1.write('a'); // a 追加在原有文件尾部 fos1.close();} InputStream 字节输入流包：java.io.InputStream public void close()：关闭此输入流并释放与此流相关联的任何系统资源。public abstract int read()：从输入流读取数据的下一个字节。public int read(byte[] b)：从输入流中读取一些字节数，并将它们存储到字节数组 b 中 。 FileInputStream 类包：java.io.FileInputStream 构造方法FileInputStream(File file)：通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file 命名。FileInputStream(String name)：通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name 命名。 方法示例123456789public class FileInputStreamConstructor throws IOException{ public static void main(String[] args) { // 使用 File 对象创建流对象 File file = new File(&quot;a.txt&quot;); FileInputStream fos = new FileInputStream(file); // 使用文件名称创建流对象 FileInputStream fos = new FileInputStream(&quot;b.txt&quot;); }} 读取字节数据123456789101112131415161718192021public class FISRead { public static void main(String[] args) throws IOException{ // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream(&quot;read.txt&quot;); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=‐1) { // 每次读取后，把数组的有效字节部分，变成字符串打印 System.out.println(new String(b，0，len));// len 每次读取的有效字节个数 } // 关闭资源 fis.close(); }}// 输出结果：// ab// cd// e 字节流：图片复制12345678910111213141516171819202122public class Copy { public static void main(String[] args) throws IOException { // 1.创建流对象 // 1.1 指定数据源 FileInputStream fis = new FileInputStream(&quot;D:\\\\test.jpg&quot;); // 1.2 指定目的地 FileOutputStream fos = new FileOutputStream(&quot;test_copy.jpg&quot;); // 2.读写数据 // 2.1 定义数组 byte[] b = new byte[1024]; // 2.2 定义长度 int len; // 2.3 循环读取 while ((len = fis.read(b))!=‐1) { // 2.4 写出数据 fos.write(b, 0 , len); } // 3.关闭资源 fos.close(); fis.close(); }} 字符流字符流，只能操作文本文件，不能操作图片，视频等非文本文件。 字符输入流：Reader包：java.io.Reader 方法public void close()：关闭此流并释放与此流相关联的任何系统资源。public int read()：从输入流读取一个字符。public int read(char[] cbuf)：从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中 。 FileReader 类java.io.FileReader：读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 构造方法 FileReader(File file)：创建一个新的 FileReader ，给定要读取的 File 对象。 FileReader(String fileName)：创建一个新的 FileReader ，给定要读取的文件的名称。 123456789public class FileReaderConstructor throws IOException{ public static void main(String[] args) { // 使用 File 对象创建流对象 File file = new File(&quot;a.txt&quot;); FileReader fr = new FileReader(file); // 使用文件名称创建流对象 FileReader fr = new FileReader(&quot;b.txt&quot;); }} 使用字符数组读取数据1234567891011121314151617181920public class FISRead { public static void main(String[] args) throws IOException { // 使用文件名称创建流对象 FileReader fr = new FileReader(&quot;read.txt&quot;); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=‐1) { System.out.println(new String(cbuf,0,len)); } // 关闭资源 fr.close(); }}// 输出结果：// 黑马// 程序// 员 Writer 字符输出流包：java.io.Writer 方法void write(int c)：写入单个字符。void write(char[] cbuf)：写入字符数组。abstract void write(char[] cbuf, int off, int len)：写入字符数组的某一部分，off 数组的开始索引，len 写的字符个数。void write(String str)：写入字符串。void write(String str, int off, int len)：写入字符串的某一部分，off 字符串的开始索引，len 写的字符个数。void flush()：刷新该流的缓冲。void close()：关闭此流，但要先刷新它。 FileWriter 类包：java.io.FileWriter 构造方法 FileWriter(File file)：创建一个新的 FileWriter，给定要读取的 File 对象。 FileWriter(String fileName)：创建一个新的 FileWriter，给定要读取的文件的名称。 构造举例123456789public class FileWriterConstructor { public static void main(String[] args) throws IOException { // 使用File对象创建流对象 File file = new File(&quot;a.txt&quot;); FileWriter fw = new FileWriter(file); // 使用文件名称创建流对象 FileWriter fw = new FileWriter(&quot;b.txt&quot;); }} 关闭与刷新1234567891011121314151617public class FWWrite { public static void main(String[] args) throws IOException { // 使用文件名称创建流对象 FileWriter fw = new FileWriter(&quot;fw.txt&quot;); fw.write(30000); // 写出1个字符，中文编码表中30000对应一个汉字。 // 写出数据，通过flush fw.write('刷'); // 写出第1个字符 fw.flush(); fw.write('新'); // 继续写出第2个字符，写出成功 fw.flush(); // 写出数据，通过close fw.write('关'); // 写出第1个字符 fw.close(); fw.write('闭'); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed fw.close(); }} IO 异常处理略 属性集java.util.Properties 继承 Hashtable 表示一个持久的属性集。使用键值结构存储数据，每个键及其对应值都是一个字符串。 Properties 类构造方法public Properties()：创建一个空的属性列表。 基本的存储方法public Object setProperty(String key, String value)：保存一对属性。public String getProperty(String key)：使用此属性列表中指定的键搜索属性值。public Set&lt;String&gt; stringPropertyNames()：所有键的名称的集合。 12345678910111213141516171819202122232425262728293031public class ProDemo { public static void main(String[] args) throws FileNotFoundException { // 创建属性集对象 Properties properties = new Properties(); // 添加键值对元素 properties.setProperty(&quot;filename&quot;, &quot;a.txt&quot;); properties.setProperty(&quot;length&quot;, &quot;209385038&quot;); properties.setProperty(&quot;location&quot;, &quot;D:\\\\a.txt&quot;); // 打印属性集对象 System.out.println(properties); // 通过键，获取属性值 System.out.println(properties.getProperty(&quot;filename&quot;)); System.out.println(properties.getProperty(&quot;length&quot;)); System.out.println(properties.getProperty(&quot;location&quot;)); // 遍历属性集，获取所有键的集合 Set&lt;String&gt; strings = properties.stringPropertyNames(); // 打印键值对 for (String key : strings ) { System.out.println(key+&quot; ‐‐ &quot;+properties.getProperty(key)); } }}/*输出结果：{filename=a.txt, length=209385038, location=D:\\a.txt}a.txt209385038D:\\a.txtfilename ‐‐ a.txtlength ‐‐ 209385038location ‐‐ D:\\a.txt*/ 与流相关的方法public void load(InputStream inStream)：从字节输入流中读取键值对。 文本数据格式： 123filename=a.txtlength=209385038location=D:\\a.txt 代码演示： 12345678910111213141516171819public class ProDemo2 { public static void main(String[] args) throws FileNotFoundException { // 创建属性集对象 Properties pro = new Properties(); // 加载文本中信息到属性集 pro.load(new FileInputStream(&quot;read.txt&quot;)); // 遍历集合并打印 Set&lt;String&gt; strings = pro.stringPropertyNames(); for (String key : strings ) { System.out.println(key+&quot; ‐‐ &quot;+pro.getProperty(key)); } }}/*输出结果：filename ‐‐ a.txtlength ‐‐ 209385038location ‐‐ D:\\a.txt*/ 文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。","link":"/ed1aec34eb15/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","link":"/tags/ElasticSearch/"},{"name":"Kafka","slug":"Kafka","link":"/tags/Kafka/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"Netty","slug":"Netty","link":"/tags/Netty/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"日常问题处理","slug":"日常问题处理","link":"/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"name":"代码","slug":"代码","link":"/tags/%E4%BB%A3%E7%A0%81/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"摄影","slug":"摄影","link":"/tags/%E6%91%84%E5%BD%B1/"},{"name":"高项","slug":"高项","link":"/tags/%E9%AB%98%E9%A1%B9/"},{"name":"Canal","slug":"Canal","link":"/tags/Canal/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Harbor","slug":"Harbor","link":"/tags/Harbor/"},{"name":"Kettle","slug":"Kettle","link":"/tags/Kettle/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Nacos","slug":"Nacos","link":"/tags/Nacos/"},{"name":"TomCat","slug":"TomCat","link":"/tags/TomCat/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"疑难解答","slug":"疑难解答","link":"/tags/%E7%96%91%E9%9A%BE%E8%A7%A3%E7%AD%94/"},{"name":"IO","slug":"IO","link":"/tags/IO/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"动态代理","slug":"动态代理","link":"/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"Stream","slug":"Stream","link":"/tags/Stream/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"JDK","slug":"JDK","link":"/tags/JDK/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"VMware","slug":"VMware","link":"/tags/VMware/"},{"name":"RabbitMQ","slug":"RabbitMQ","link":"/tags/RabbitMQ/"},{"name":"分布式","slug":"分布式","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"集合","slug":"集合","link":"/tags/%E9%9B%86%E5%90%88/"},{"name":"理论","slug":"理论","link":"/tags/%E7%90%86%E8%AE%BA/"},{"name":"线程","slug":"线程","link":"/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"未解答","slug":"未解答","link":"/tags/%E6%9C%AA%E8%A7%A3%E7%AD%94/"}],"categories":[{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"疑难解答","slug":"疑难解答","link":"/categories/%E7%96%91%E9%9A%BE%E8%A7%A3%E7%AD%94/"},{"name":"Java基础","slug":"面试/Java基础","link":"/categories/%E9%9D%A2%E8%AF%95/Java%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"技术/Java","link":"/categories/%E6%8A%80%E6%9C%AF/Java/"},{"name":"教程","slug":"技术/教程","link":"/categories/%E6%8A%80%E6%9C%AF/%E6%95%99%E7%A8%8B/"},{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"}]}