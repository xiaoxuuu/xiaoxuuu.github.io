<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>集合 - 小徐&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="小徐&#039;s Blog"><meta name="msapplication-TileImage" content="icons/touch-icon-iphone.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="小徐&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="144x144" href="icons/touch-icon-iphone.png"><link rel="apple-touch-icon" sizes="152x152" href="icons/touch-icon-ipad.png"><link rel="apple-touch-icon" sizes="72x72" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="96x96" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="128x128" href="icon/logo.ico"><link rel="apple-touch-icon" sizes="256x256" href="icon/logo.ico"><meta name="description" content="集合面试题"><meta property="og:type" content="article"><meta property="og:title" content="集合"><meta property="og:url" content="https://blog.hr947x.com/0588b982f188/"><meta property="og:site_name" content="小徐&#039;s Blog"><meta property="og:description" content="集合面试题"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/056/58/114_10.png#alt=114%5C_10.png"><meta property="og:image" content="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/056/58/114_11.png#alt=114%5C_11.png"><meta property="og:image" content="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/056/58/114_12.png#alt=114%5C_12.png"><meta property="article:published_time" content="2022-02-15T08:09:00.000Z"><meta property="article:modified_time" content="2022-02-15T08:09:00.000Z"><meta property="article:author" content="小徐"><meta property="article:tag" content="面试"><meta property="article:tag" content="集合"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/056/58/114_10.png#alt=114%5C_10.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hr947x.com/0588b982f188/"},"headline":"集合","image":["https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/056/58/114_10.png#alt=114%5C_10.png","https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/056/58/114_11.png#alt=114%5C_11.png","https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/056/58/114_12.png#alt=114%5C_12.png"],"datePublished":"2022-02-15T08:09:00.000Z","dateModified":"2022-02-15T08:09:00.000Z","author":{"@type":"Person","name":"小徐"},"publisher":{"@type":"Organization","name":"小徐's Blog","logo":{"@type":"ImageObject","url":{"text":"小徐's Blog"}}},"description":"集合面试题"}</script><link rel="canonical" href="https://blog.hr947x.com/0588b982f188/"><link rel="icon" href="/img/avatar.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">小徐&#039;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">博客</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="踽踽独行" href="https://www.hr947x.com">踽踽独行</a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-15T08:09:00.000Z" title="2/15/2022, 8:09:00 AM">2022-02-15</time>发表</span><span class="level-item"><time dateTime="2022-02-15T08:09:00.000Z" title="2/15/2022, 8:09:00 AM">2022-02-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><span> / </span><a class="link-muted" href="/categories/%E9%9D%A2%E8%AF%95/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span><span class="level-item">1 小时读完 (大约7453个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">集合</h1><div class="content"><p>集合面试题</p>
<span id="more"></span>

<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>集合按照其存储结构可以分为两大类</p>
<ul>
<li><p>单列集合 java.util.Collection</p>
<ul>
<li><code>java.util.List</code>：List 的特点是元素有序、元素可重复。主要实现类有 <code>java.util.ArrayList</code> 和 <code>java.util.LinkedList</code></li>
<li>``java.util.Set<code>：Set 的特点是元素无序，而且不可重复。主要实现类有 </code>java.util.HashSet<code>和</code>java.util.TreeSet`</li>
</ul>
</li>
<li><p>双列集合 java.util.Map</p>
</li>
</ul>
<h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><ol>
<li>Vector：比 Arraylist 多了个 synchronized（线程安全），因为效率较低，现在已经不太建议使用。</li>
<li>hashTable：就比 HashMap 多了个 synchronized (线程安全)，不建议使用。</li>
<li>ConcurrentHashMap：是 Java5 中支持高并发、高吞吐量的线程安全 HashMap 实现。它由 Segment 数组结构和 HashEntry 数组结构组成。Segment 数组在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键-值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap 类似，是一种数组和链表结构；一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素；每个 Segment 守护着一个 HashEntry 数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的 Segment 锁。（推荐使用）</li>
</ol>
<h3 id="什么是-Hash-算法"><a href="#什么是-Hash-算法" class="headerlink" title="什么是 Hash 算法"></a>什么是 Hash 算法</h3><p>哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>不包含重复元素的 <code>Collection</code></p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43298772/article/details/90118530">Set接口及其实现类_但行好事 无问西东-CSDN博客_set接口的主要实现类</a></p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet 实现 Set 接口，底层数据结构由哈希表（实际上是一个 HashMap 实例）支持，不是线程安全的，默认初始容量是 <strong>16</strong>，加载因子是<br><strong>0.75</strong>。它不保证 Set 的存取顺序。此类允许使用 null 元素。</p>
<h3 id="唯一性与无序性"><a href="#唯一性与无序性" class="headerlink" title="唯一性与无序性"></a>唯一性与无序性</h3><ol>
<li>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 <code>hashCode()</code> 方法来得到该对象的 hashCode 值；</li>
<li>然后根据 hashCode 值决定该元素所处的对象数组中的索引值，确定要放入集合的元素的值是否和该索引处的链表上的各个元素相等，<ul>
<li>如果 hashCode 不相等，就将该元素链接在表尾；</li>
<li>如果 hashCode 相等，就不会链接，通过这样就确保了集合中的元素的<strong>唯一性</strong>；</li>
</ul>
</li>
<li>也正是因为在存的过程中会通过哈希值来确定在数组位置的索引，所以实现的<strong>无序性</strong>。</li>
</ol>
<h3 id="去重原理"><a href="#去重原理" class="headerlink" title="去重原理"></a>去重原理</h3><p>调用被添加元素的 <code>hashCode()</code> 与 HashSet 中已有元素的 <code>hashCode()</code> 比较是否相同：</p>
<ul>
<li>不相同：直接存储</li>
<li>相同：调用 <code>equals()</code> 方法比较是否相同<ul>
<li>不相同：直接存储元素</li>
<li>相同：认为是同一元素，不存储</li>
</ul>
</li>
</ul>
<h3 id="无序性"><a href="#无序性" class="headerlink" title="无序性"></a>无序性</h3><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>底层数据结构有两个： </p>
<ul>
<li>链表：保证存取顺序</li>
<li>哈希表：保证元素唯一</li>
</ul>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>底层数据结构是<strong>二叉树</strong>，集合中<strong>元素唯一</strong>，并且可以对元素进行排序。</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li>自然排序：构造器空参构造</li>
<li>比较器排序：构造器有参构造</li>
</ul>
<p>注意：实现自然排序需要元素自身实现 <code>Comparable</code> 接口并重写 <code>comPareTo</code> 方法，根据此方法返回值来确定元素在二叉树的位置，否则无法进行自然排序，<code>Integer</code> 已经实现该类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><ul>
<li>有序的集合；</li>
<li>带有索引的集合：通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）；</li>
<li>可以有重复的元素，通过元素的 <code>equals()</code> 方法，来比较是否为重复的元素； </li>
<li>允许插入 null；</li>
<li>常见的实现：ArrayList, LinkedList</li>
</ul>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>非同步，实现了可变大小的元素数组</p>
<ol>
<li>使用数组存储元素</li>
<li>随机访问元素较快，时间复杂度 O(1)，插入移除元素较慢，时间复杂度 O(n)</li>
<li>线程不安全，若需保证线程安全使用 SynchronizedList 和 CopyOnWriteArrayList 代替</li>
<li>继承于 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable<ul>
<li>实现了List：使得具有 List 集合的特性；</li>
<li>实现了 Deque 接口：使得 LinkedList 类也具有队列的特性；</li>
<li>实现了 Cloneable：表示能被克隆；</li>
<li>实现了 java.io.Serializable：表示支持序列化。</li>
</ul>
</li>
</ol>
<h3 id="并发下的可能问题"><a href="#并发下的可能问题" class="headerlink" title="并发下的可能问题"></a>并发下的可能问题</h3><p><strong>添加元素越界 IndexOutOfBoundsException</strong></p>
<p>若当前 elementData 数组长度为 2，size=1 (即初始化了一个长度为 2 的 ArrayList，并且已经添加了一个元素)， 此时存在多个线程同时对该 ArrayList 执行 add 极端情况下则可能会出现该情形： calculateCapacity 方法判断是否需要扩容时，结果均为不需要扩容，而在 elementData[size++]=e 对 size 赋值时，size 的值会超出当前数组范围，产生越界异常 IndexOutOfBoundsException。看如下示例：</p>
<figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            a.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            a.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            a.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>并发修改异常 ConcurrentModificationException</strong></p>
<p>若某个线程正在修改一个 ArrayList，同时另外存在一个线程则遍历该 ArrayList，则会出现该异常，如下对上边的案例做了下修改，减少了添加元素的数量，同时在后边打印该数组。</p>
<figure class="highlight java"><figcaption><span>点击展开代码 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            a.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            a.add(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ol>
<li>使用链表存储元素</li>
<li>新增插入快，随机查找慢</li>
<li>线程不安全，可以使用 <code>Collections.synchronizedList(new LinkedList(...));</code> 创建线程安全的 LinkedList</li>
<li>继承自 AbstractSequentialList，实现了 List, Deque, Cloneable, java.io.Serializable 接口<ul>
<li>实现了 List：使得具有 List 集合的特性；</li>
<li>实现了 Deque 接口：使得 LinkedList 类也具有队列的特性；</li>
<li>实现了 Cloneable：表示能被克隆；</li>
<li>实现了 java.io.Serializable：表示支持序列化。</li>
</ul>
</li>
</ol>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Stack</p>
<h3 id="什么是-Vector"><a href="#什么是-Vector" class="headerlink" title="什么是 Vector"></a>什么是 Vector</h3><p>Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，访问它比访问 ArrayList 慢很多</p>
<p>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。ArrayList 的缺点是每个元素之间不能有间隔。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="ArrayList-与-LinkedList"><a href="#ArrayList-与-LinkedList" class="headerlink" title="ArrayList 与 LinkedList"></a>ArrayList 与 LinkedList</h3><ul>
<li>ArrayList 动态数组，需要连续内存，适合随机访问，指定初始容量并且在尾部插入性能比 LinkedList 好；</li>
<li>LinkedList 链表，可分散存储，适合插入删除，不适合随机访问，只能用迭代器访问，且注意不要用 indexOf 等返回元素索引，如果该元素不存在，就会遍历整个集合</li>
</ul>
<h3 id="List-与-Set"><a href="#List-与-Set" class="headerlink" title="List 与 Set"></a>List 与 Set</h3><ul>
<li>List 可以允许多个 null 元素，Set 单个 null；</li>
<li>List Set 均有迭代器遍历，List 还有 get 方法</li>
</ul>
<h3 id="ArrayList-和-LinkedList-的区别"><a href="#ArrayList-和-LinkedList-的区别" class="headerlink" title="ArrayList 和 LinkedList 的区别"></a>ArrayList 和 LinkedList 的区别</h3><ol>
<li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>
<li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>
<li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>
<li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li>
<li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>
<li>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li>
<li>LinkedList 的双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</li>
</ol>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><ul>
<li>Map 每个元素由键与值两部分组成</li>
<li>Map 键不能重复，每个键对应一个值</li>
<li>键和值可以为 null</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903958658416648">Java Map - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6917607264148783118">Java Map整理 - 掘金 (juejin.cn)</a></p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="HashMap-扩容机制"><a href="#HashMap-扩容机制" class="headerlink" title="HashMap 扩容机制"></a>HashMap 扩容机制</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40871196/article/details/101855801">关于HashMap常见面试考点（底层原理+扩容机制）_撒有啦啦Q的博客-CSDN博客</a></p>
<ul>
<li>链表 + 数组，在 JDK8，链表高度达到 8，数组长度超过 64，链表就会转为红黑树，是为了解决哈希碰撞后链表索引效率的问题；<ul>
<li>  计算 key 的 hash，然后二次 hash 再对数组长度取模，对应到数组下标；</li>
<li>  如对应下标无元素，就直接创建 node 存入。</li>
<li>  如果有元素，就先进行 equals 比较，相同就取代该元素，不同则判断链表高度插入链表，链表高度达到 8，数组长度超过 64，链表就会转为红黑树，高度低于 6 则会转换回链表；</li>
</ul>
</li>
<li>  key 为 null 的键值对永远都放在以 <code>table[0]</code> 为头结点的链表中。</li>
<li>  默认长度是 16，扩容后的长度必须是 2 的幂；</li>
<li>  JDK8 以前碰撞节点会在链表头部插入，对于扩容操作后的链表顺序会倒置；</li>
<li>  JDK8 开始碰撞节点会在链表尾部插入，对于扩容操作后的链表顺序会保持原来的顺序；</li>
<li>  initialCapacity（初始容量）代表了初始容量，但扩容时还是会按照 2 的幂扩容；</li>
<li>  loadFactor（加载因子）代表已用容量与总容量的比值，越大对空间利用越充分，但查找效率会降低，太小则会造成空间浪费；</li>
</ul>
<h3 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方"></a>HashMap 的长度为什么是 2 的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p>
<p><strong>这个算法应该如何设计呢？</strong></p>
<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p>
<p><strong>那为什么是两次扰动呢？</strong></p>
<p>这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p>
<h3 id="HashMap-什么情况下线程不安全"><a href="#HashMap-什么情况下线程不安全" class="headerlink" title="HashMap 什么情况下线程不安全"></a>HashMap 什么情况下线程不安全</h3><ul>
<li>  <code>put()</code> 时：由于 哈希碰撞的存在，所以可能导致两次 <code>put()</code> 方法同时操作到一条链表的头节点，那么必定有一次 <code>put()</code> 操作的数据会丢失；</li>
<li>  <code>resize()</code> 时：当多个线程检测到数组容量不够，那么就会各自生成多个新的数组并赋值给底层的 Table，但最终只能有一个成功赋值，其它的都会丢失。而且当某些线程完成赋值，而其它线程刚开始时，就会使用已赋值的 table 作为原始数组，这样也会有问题。</li>
</ul>
<h3 id="HashMap-的扩容操作是怎么实现的？"><a href="#HashMap-的扩容操作是怎么实现的？" class="headerlink" title="HashMap 的扩容操作是怎么实现的？"></a>HashMap 的扩容操作是怎么实现的？</h3><p><strong>1、</strong> 在 JDK8 中，<code>resize()</code> 方法是在 HashMap 中的键值对大于阀值时或者初始化时，就调用 <code>resize()</code> 方法进行扩容；</p>
<p><strong>2、</strong> 每次扩展的时候，都是扩展 2 倍；</p>
<p><strong>3、</strong> 扩展后 Node 对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p>
<p>在 <code>putVal()</code> 中，我们看到在这个函数里面使用到了 2 次 <code>resize()</code> 方法，<code>resize()</code> 方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是 JDK8 版本的一个优化的地方，在 JDK7 中，扩容之后需要重新去计算其 Hash 值，根据 Hash 值对其进行分发，但在 JDK8 版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为 0，重新进行 hash 分配后，该元素的位置要么停留在原始位置，要么移动到 原始位置+增加的数组大小 这个位置上</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><ul>
<li>保证遍历顺序是元素插入的顺序；</li>
<li>遍历有序</li>
</ul>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><ul>
<li>JDK7：ReentrantLock + Segment + HashEntry，一个 Segment 中包含一个 HashEntry 数组，每个 HashEntry 又是一个链表结构；<ul>
<li>  元素查询：二次 hash，第一次 hash 定位 Segment，第二次 hash 定位元素所在链表的头部；</li>
<li>  锁：Segment 分段锁，Segment 继承了 ReentrantLock，锁定操作的 Segment，其余的 Segment 不受影响，并发为 Segment 的个数，可在构造函数指定，数组扩容不影响其余 Segment；</li>
<li>  get：无需枷锁，volatile 保证</li>
</ul>
</li>
<li>JDK8：synchronized + CAS + Node + 红黑树，Node 的 val 和 next 都用 volatile 修饰，表示可见性，查找、替换、赋值都使用 CAS；<ul>
<li>  锁：锁链表的 head 节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写操作，并发扩容；</li>
</ul>
</li>
<li>读操作无锁：<ul>
<li>  Node 的 Val 和 next 使用 volatile 修饰，读写线程对该变量互相可见；</li>
<li>  数组用 volatile 修饰，保证扩容时被读线程感知；</li>
</ul>
</li>
</ul>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><ul>
<li>  在所有方法上添加 synchronized 保证线程安全，全局锁；</li>
<li>  不允许 key 与 value 为 null；</li>
</ul>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ol>
<li>TreeMap 是一个<strong>有序的key-value集合</strong>，它是通过红黑树实现的。</li>
<li>TreeMap基于<strong>红黑树（Red-Black tree）实现</strong>。该映射根据<strong>其键的自然顺序进行排序</strong>，或者根据<strong>创建映射时提供的 Comparator 进行排序</strong>，具体取决于使用的构造方法。</li>
<li>TreeMap是线程<strong>非同步</strong>的。</li>
</ol>
<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p>改进的 HashMap，实现了「弱引用」，如果一个 key 不被引用，则被 GC 回收</p>
<h2 id="HashEntry"><a href="#HashEntry" class="headerlink" title="HashEntry"></a>HashEntry</h2><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><ul>
<li>保证最高或者最低优先级的的元素总是在队列头部；</li>
<li>遍历无序</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h3 id="能否使用任何类作为-Map-的-key"><a href="#能否使用任何类作为-Map-的-key" class="headerlink" title="能否使用任何类作为 Map 的 key"></a>能否使用任何类作为 Map 的 key</h3><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：</p>
<ol>
<li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li>
<li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li>
<li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li>
<li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li>
</ol>
<h3 id="ConcurrentHashMap-和-HashTable-的区别"><a href="#ConcurrentHashMap-和-HashTable-的区别" class="headerlink" title="ConcurrentHashMap 和 HashTable 的区别"></a>ConcurrentHashMap 和 HashTable 的区别</h3><p>ConcurrentHashMap 是 Java5 中支持高并发、高吞吐量的线程安全 HashMap 实现。它由 Segment 数组结构和 HashEntry 数组结构组成。Segment 数组在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键-值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap 类似，是一种数组和链表结构；一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素；每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。</p>
<p><strong>看不懂？？？很正常，我也看不懂</strong></p>
<p><strong>总结：</strong></p>
<ol>
<li>HashTable 就是实现了 HashMap 加上了 synchronized，而 ConcurrentHashMap 底层采用分段的数组+链表实现，线程安全</li>
<li>ConcurrentHashMap 通过把整个 Map 分为 N 个 Segment，可以提供相同的线程安全，但是效率提升 N 倍，默认提升 16 倍。</li>
<li>并且读操作不加锁，由于 HashEntry 的 value 变量是 volatile 的，也能保证读取到最新的值。</li>
<li>Hashtable 的 synchronized 是针对整张 Hash 表的，即每次锁住整张表让线程独占，ConcurrentHashMap 允许多个修改操作并发进行，其关键在于使用了锁分离技术</li>
<li>扩容：段内扩容（段内元素超过该段对应 Entry 数组长度的 75% 触发扩容，不会对整个 Map 进行扩容），插入前检测需不需要扩容，有效避免无效扩容</li>
</ol>
<h3 id="LinkedHashMap-和-PriorityQueue-的区别"><a href="#LinkedHashMap-和-PriorityQueue-的区别" class="headerlink" title="LinkedHashMap 和 PriorityQueue 的区别"></a>LinkedHashMap 和 PriorityQueue 的区别</h3><p>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 可保证遍历顺序是元素插入的顺序。</p>
<h3 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<p><strong>底层数据结构</strong>：</p>
<p>JDK7 的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p>
<p><strong>实现线程安全的方式</strong>：</p>
<p><strong>1、</strong> 在 JDK7 的时候，ConcurrentHashMap（分段锁对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配 16 个 Segment，比 Hashtable 效率提高 16 倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK6 以后 对 synchronized 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p>
<p><strong>2、</strong> <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
<p><strong>两者的对比图</strong>：</p>
<p><strong>1、</strong> HashTable</p>
<p><img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/056/58/114_10.png#alt=114%5C_10.png"></p>
<p><strong>2、</strong>  JDK1.7的ConcurrentHashMap</p>
<p><img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/056/58/114_11.png#alt=114%5C_11.png"></p>
<p><strong>3、</strong> JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）</p>
<p><img src="https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/056/58/114_12.png#alt=114%5C_12.png"></p>
<p>ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题使用了synchronized 关键字，所以 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p>
<h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><h2 id="Iterator-是什么"><a href="#Iterator-是什么" class="headerlink" title="Iterator 是什么"></a>Iterator 是什么</h2><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p>
<p>因为所有 Collection 接继承了 Iterator 迭代器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Iterator-怎么用"><a href="#Iterator-怎么用" class="headerlink" title="Iterator 怎么用"></a>Iterator 怎么用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
<h2 id="迭代器的实现原理"><a href="#迭代器的实现原理" class="headerlink" title="迭代器的实现原理"></a>迭代器的实现原理</h2><p>当遍历集合时，首先通过调用集合的 <code>iterator()</code> 方法获得迭代器对象，然后使用 <code>hashNext()</code> 方法判断集合中是否存在下一个元素，如果存在，则调用 <code>next()</code> 方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p>
<p>Iterator 迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，在调用 Iterator 的 <code>next()</code> 方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的 <code>next()</code> 方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用 <code>next()</code> 方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到 <code>hasNext()</code> 方法返回 false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h2 id="我们能自己写一个容器类，然后使用-for-each-循环码？"><a href="#我们能自己写一个容器类，然后使用-for-each-循环码？" class="headerlink" title="我们能自己写一个容器类，然后使用 for-each 循环码？"></a>我们能自己写一个容器类，然后使用 for-each 循环码？</h2><p>可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。</p>
<h2 id="有几种遍历方式"><a href="#有几种遍历方式" class="headerlink" title="有几种遍历方式"></a>有几种遍历方式</h2><p><strong>遍历方式有以下几种：</strong></p>
<ul>
<li><p>for 循环遍历：基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</p>
</li>
<li><p>迭代器遍历 Iterator：Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</p>
</li>
<li><p>foreach 循环遍历：foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。</p>
<ul>
<li>优点是代码简洁，不易出错；</li>
<li>缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li>
</ul>
</li>
<li><p>stream 流也可以实现遍历的功能；</p>
</li>
</ul>
<p><strong>最佳实践：</strong></p>
<p>Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p>
<ul>
<li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</li>
<li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li>
<li>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</li>
</ul>
<h2 id="集合的快速失败机制-fail-fast"><a href="#集合的快速失败机制-fail-fast" class="headerlink" title="集合的快速失败机制 fail-fast"></a>集合的快速失败机制 fail-fast</h2><p>是 Java 集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p>
<p><strong>例如：</strong>假设存在两个线程（线程1、线程2），线程 1 通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制。</p>
<p><strong>原因：</strong>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用 <code>hashNext()</code>/<code>next()</code> 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p><strong>解决办法：</strong></p>
<ol>
<li>在遍历过程中，所有涉及到改变 modCount 值得地方全部加上 synchronized；</li>
<li>使用 CopyOnWriteArrayList 来替换 ArrayList；</li>
</ol>
<h1 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h1><h2 id="数据结构中元素的存取特点"><a href="#数据结构中元素的存取特点" class="headerlink" title="数据结构中元素的存取特点"></a>数据结构中元素的存取特点</h2><ul>
<li>栈：stack，又称堆栈，特点是：先进后出。即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素。</li>
<li>队列：queue，特点是：先进先出。即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素。</li>
<li>数组：Array，是有序的元素序列，对元素的存取特点是：<ul>
<li>查找元素快：通过索引，可以快速访问指定位置的元素</li>
<li>增删元素慢<ul>
<li>指定索引位置增加元素：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。</li>
<li>指定索引位置删除元素：需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。</li>
</ul>
</li>
</ul>
</li>
<li>链表：linked list，对元素的存取有如下的特点：<ul>
<li>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</li>
<li>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素。</li>
<li>增删元素快：增加删除元素均只需要修改连接下个元素的地址即可。</li>
</ul>
</li>
</ul>
<h2 id="Comparable-和-Comparator-的区别。"><a href="#Comparable-和-Comparator-的区别。" class="headerlink" title="Comparable 和 Comparator 的区别。"></a>Comparable 和 Comparator 的区别。</h2><ul>
<li>Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 <code>compareTo()</code> 方法被称为它的自然比较方法。只能在类中实现 <code>compareTo()</code> 一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过 <code>Collections.sort()</code>（和 <code>Arrays.sort()</code>）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。<ul>
<li>Comparator：强行对某个对象进行整体排序。可以将 Comparator 传递给 <code>sort()</code> 方法（如 <code>Collections.sort()</code> 或 <code>Arrays.sort()</code>），从而允许在排序顺序上实现精确控制。还可以使用 Comparator 来控制某些数据结构（如有序 set 或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。</li>
</ul>
</li>
</ul>
<h2 id="如何实现-Array-和-List-之间的转换"><a href="#如何实现-Array-和-List-之间的转换" class="headerlink" title="如何实现 Array 和 List 之间的转换"></a>如何实现 Array 和 List 之间的转换</h2><ul>
<li>Array 转 List：<code>Arrays.asList(array)</code></li>
<li>List 转 Array：<code>List.toArray()</code></li>
</ul>
<h2 id="Java-中能创建-volatile-数组么"><a href="#Java-中能创建-volatile-数组么" class="headerlink" title="Java 中能创建 volatile 数组么"></a>Java 中能创建 volatile 数组么</h2><p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</p>
<h2 id="poll-和-remove-的区别"><a href="#poll-和-remove-的区别" class="headerlink" title="poll() 和 remove() 的区别"></a>poll() 和 remove() 的区别</h2><p><code>poll()</code> 和 <code>remove()</code> 都是从队列中取出一个元素，但是 <code>poll()</code> 在获取元素失败的时候会返回空，但是 <code>remove()</code> 失败的时候会抛出异常。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>集合</p><p><a href="https://blog.hr947x.com/0588b982f188/">https://blog.hr947x.com/0588b982f188/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>小徐</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-02-15</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-02-15</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9B%86%E5%90%88/">集合</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/3d68a730359e/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">设计模式</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2297f450f42d/"><span class="level-item">未解答</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#基础"><span class="level-left"><span class="level-item">1</span><span class="level-item">基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#分类"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">分类</span></span></a></li><li><a class="level is-mobile" href="#线程安全的集合"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">线程安全的集合</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是-Hash-算法"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">什么是 Hash 算法</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#数组"><span class="level-left"><span class="level-item">2</span><span class="level-item">数组</span></span></a></li><li><a class="level is-mobile" href="#Set"><span class="level-left"><span class="level-item">3</span><span class="level-item">Set</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#HashSet"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">HashSet</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#唯一性与无序性"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">唯一性与无序性</span></span></a></li><li><a class="level is-mobile" href="#去重原理"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">去重原理</span></span></a></li><li><a class="level is-mobile" href="#无序性"><span class="level-left"><span class="level-item">3.1.3</span><span class="level-item">无序性</span></span></a></li></ul></li><li><a class="level is-mobile" href="#LinkedHashSet"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">LinkedHashSet</span></span></a></li><li><a class="level is-mobile" href="#TreeSet"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">TreeSet</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#排序"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">排序</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#List"><span class="level-left"><span class="level-item">4</span><span class="level-item">List</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ArrayList"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">ArrayList</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#并发下的可能问题"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">并发下的可能问题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#LinkedList"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">LinkedList</span></span></a></li><li><a class="level is-mobile" href="#Vector"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">Vector</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是-Vector"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">什么是 Vector</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">总结</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ArrayList-与-LinkedList"><span class="level-left"><span class="level-item">4.4.1</span><span class="level-item">ArrayList 与 LinkedList</span></span></a></li><li><a class="level is-mobile" href="#List-与-Set"><span class="level-left"><span class="level-item">4.4.2</span><span class="level-item">List 与 Set</span></span></a></li><li><a class="level is-mobile" href="#ArrayList-和-LinkedList-的区别"><span class="level-left"><span class="level-item">4.4.3</span><span class="level-item">ArrayList 和 LinkedList 的区别</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Map"><span class="level-left"><span class="level-item">5</span><span class="level-item">Map</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#HashMap"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">HashMap</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#HashMap-扩容机制"><span class="level-left"><span class="level-item">5.1.1</span><span class="level-item">HashMap 扩容机制</span></span></a></li><li><a class="level is-mobile" href="#HashMap-的长度为什么是-2-的幂次方"><span class="level-left"><span class="level-item">5.1.2</span><span class="level-item">HashMap 的长度为什么是 2 的幂次方</span></span></a></li><li><a class="level is-mobile" href="#HashMap-什么情况下线程不安全"><span class="level-left"><span class="level-item">5.1.3</span><span class="level-item">HashMap 什么情况下线程不安全</span></span></a></li><li><a class="level is-mobile" href="#HashMap-的扩容操作是怎么实现的？"><span class="level-left"><span class="level-item">5.1.4</span><span class="level-item">HashMap 的扩容操作是怎么实现的？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#LinkedHashMap"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">LinkedHashMap</span></span></a></li><li><a class="level is-mobile" href="#ConcurrentHashMap"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">ConcurrentHashMap</span></span></a></li><li><a class="level is-mobile" href="#HashTable"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">HashTable</span></span></a></li><li><a class="level is-mobile" href="#TreeMap"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">TreeMap</span></span></a></li><li><a class="level is-mobile" href="#WeakHashMap"><span class="level-left"><span class="level-item">5.6</span><span class="level-item">WeakHashMap</span></span></a></li><li><a class="level is-mobile" href="#HashEntry"><span class="level-left"><span class="level-item">5.7</span><span class="level-item">HashEntry</span></span></a></li><li><a class="level is-mobile" href="#PriorityQueue"><span class="level-left"><span class="level-item">5.8</span><span class="level-item">PriorityQueue</span></span></a></li><li><a class="level is-mobile" href="#总结-1"><span class="level-left"><span class="level-item">5.9</span><span class="level-item">总结</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#能否使用任何类作为-Map-的-key"><span class="level-left"><span class="level-item">5.9.1</span><span class="level-item">能否使用任何类作为 Map 的 key</span></span></a></li><li><a class="level is-mobile" href="#ConcurrentHashMap-和-HashTable-的区别"><span class="level-left"><span class="level-item">5.9.2</span><span class="level-item">ConcurrentHashMap 和 HashTable 的区别</span></span></a></li><li><a class="level is-mobile" href="#LinkedHashMap-和-PriorityQueue-的区别"><span class="level-left"><span class="level-item">5.9.3</span><span class="level-item">LinkedHashMap 和 PriorityQueue 的区别</span></span></a></li><li><a class="level is-mobile" href="#ConcurrentHashMap-和-Hashtable-的区别"><span class="level-left"><span class="level-item">5.9.4</span><span class="level-item">ConcurrentHashMap 和 Hashtable 的区别</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#迭代"><span class="level-left"><span class="level-item">6</span><span class="level-item">迭代</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Iterator-是什么"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">Iterator 是什么</span></span></a></li><li><a class="level is-mobile" href="#Iterator-怎么用"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">Iterator 怎么用</span></span></a></li><li><a class="level is-mobile" href="#迭代器的实现原理"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">迭代器的实现原理</span></span></a></li><li><a class="level is-mobile" href="#我们能自己写一个容器类，然后使用-for-each-循环码？"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">我们能自己写一个容器类，然后使用 for-each 循环码？</span></span></a></li><li><a class="level is-mobile" href="#有几种遍历方式"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">有几种遍历方式</span></span></a></li><li><a class="level is-mobile" href="#集合的快速失败机制-fail-fast"><span class="level-left"><span class="level-item">6.6</span><span class="level-item">集合的快速失败机制 fail-fast</span></span></a></li></ul></li><li><a class="level is-mobile" href="#整理"><span class="level-left"><span class="level-item">7</span><span class="level-item">整理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#数据结构中元素的存取特点"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">数据结构中元素的存取特点</span></span></a></li><li><a class="level is-mobile" href="#Comparable-和-Comparator-的区别。"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">Comparable 和 Comparator 的区别。</span></span></a></li><li><a class="level is-mobile" href="#如何实现-Array-和-List-之间的转换"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">如何实现 Array 和 List 之间的转换</span></span></a></li><li><a class="level is-mobile" href="#Java-中能创建-volatile-数组么"><span class="level-left"><span class="level-item">7.4</span><span class="level-item">Java 中能创建 volatile 数组么</span></span></a></li><li><a class="level is-mobile" href="#poll-和-remove-的区别"><span class="level-left"><span class="level-item">7.5</span><span class="level-item">poll() 和 remove() 的区别</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-20T05:35:04.000Z">2022-04-20</time></p><p class="title"><a href="/4e2ca58138aa/">Linux sed 教程</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-04-07T13:14:08.000Z">2022-04-07</time></p><p class="title"><a href="/e7a6f47a5edd/">IDEA 快捷键</a></p><p class="categories"><a href="/categories/%E6%95%99%E7%A8%8B/">教程</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-20T08:38:54.000Z">2022-03-20</time></p><p class="title"><a href="/de4a65c796a3/">Java 基础</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a> / <a href="/categories/%E9%9D%A2%E8%AF%95/Java%E5%9F%BA%E7%A1%80/">Java基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-19T10:01:25.000Z">2022-03-19</time></p><p class="title"><a href="/906fcab3c166/">Java 新特性</a></p><p class="categories"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a> / <a href="/categories/%E9%9D%A2%E8%AF%95/Java%E5%9F%BA%E7%A1%80/">Java基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-19T05:27:25.000Z">2022-03-19</time></p><p class="title"><a href="/9d30f1f85362/">macOS 环境搭建</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">小徐&#039;s Blog</a><p class="is-size-7"><span>&copy; 2022 小徐</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="蜀ICP备20016181号-1" href="https://beian.miit.gov.cn/">蜀ICP备20016181号-1</a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>